<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="google7750c428b5128303">
  <meta name="baidu-site-verification" content="DsamQtmEvVB9mvoD">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.difan.tech","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideDownIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.  语言特性1.1 常量nullptr代替NULL传统C++会把NULL，0视为同一个东西，有些定义((void*)0)，有些会定义为0，但是有问题：  C++不允许void * 隐式类型转换，void* 0 0会给C++重载特性带来混乱  constexpr明确声明函数或者对象在编译期会成为常量表达式， C++14开始，constexpr函数可以使用局部变量、循环、分支等简单语句。 1234">
<meta property="og:type" content="article">
<meta property="og:title" content="现代C++">
<meta property="og:url" content="https://blog.difan.tech/2022/06/20/%E7%8E%B0%E4%BB%A3C++/index.html">
<meta property="og:site_name" content="木慕的博客">
<meta property="og:description" content="1.  语言特性1.1 常量nullptr代替NULL传统C++会把NULL，0视为同一个东西，有些定义((void*)0)，有些会定义为0，但是有问题：  C++不允许void * 隐式类型转换，void* 0 0会给C++重载特性带来混乱  constexpr明确声明函数或者对象在编译期会成为常量表达式， C++14开始，constexpr函数可以使用局部变量、循环、分支等简单语句。 1234">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-16T04:55:05.296Z">
<meta property="article:author" content="木慕的博客">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.difan.tech/2022/06/20/%E7%8E%B0%E4%BB%A3C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>现代C++ | 木慕的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="木慕的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木慕的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Stay naive, stay simple.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.difan.tech/2022/06/20/%E7%8E%B0%E4%BB%A3C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.jpg">
      <meta itemprop="name" content="木慕的博客">
      <meta itemprop="description" content="木慕的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木慕的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          现代C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-20T00:00:00+08:00">2022-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/06/20/%E7%8E%B0%E4%BB%A3C++/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/06/20/%E7%8E%B0%E4%BB%A3C++/" itemprop="commentCount"></span>
    </a>
  </span>
  
  



        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-语言特性"><a href="#1-语言特性" class="headerlink" title="1.  语言特性"></a>1.  语言特性</h2><h3 id="1-1-常量"><a href="#1-1-常量" class="headerlink" title="1.1 常量"></a>1.1 常量</h3><p><strong>nullptr代替NULL</strong><br>传统C++会把NULL，0视为同一个东西，有些定义((void*)0)，有些会定义为0，但是有问题：</p>
<ul>
<li>C++不允许void * 隐式类型转换，void* 0</li>
<li>0会给C++重载特性带来混乱</li>
</ul>
<p><strong>constexpr</strong><br>明确声明函数或者对象在编译期会成为常量表达式， C++14开始，constexpr函数可以使用局部变量、循环、分支等简单语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//c++11 编译不了</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>字面量：</strong><br>C++14带来很多新的字面量:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::complex_literals;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i * i = &quot;</span> &lt;&lt; <span class="number">1</span>i * <span class="number">1</span>i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::chrono_literals;</span><br><span class="line">this_thread::sleep_for(<span class="number">500</span>ms);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals::string_literals;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span>s.substr(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">bitset</span>&lt;9&gt;(mask) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-变量及其初始化"><a href="#1-2-变量及其初始化" class="headerlink" title="1.2 变量及其初始化"></a>1.2 变量及其初始化</h3><p>C++17 可以将<strong>变量放在语句内(C++17)</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">	*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>初始化列表(C++11)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::initializer_list</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end(); it++) &#123;</span><br><span class="line">		vec.push_back(*it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几乎可以在所有初始化对象的地方使用大括号而不是小括号。当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Obj(1.0)唯一区别在于{1.0}拒绝窄转换，只允许调用Obj(double).</p>
<p><strong>结构化绑定（C++17）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f() return std::&lt;int, double, std::string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = f();</span><br></pre></td></tr></table></figure>

<p><strong>类数据成员的默认初始化（C11）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Complex() &#123;&#125;</span><br><span class="line">  Complex(<span class="keyword">float</span> re) : re_(re) &#123;&#125;</span><br><span class="line">  Complex(<span class="keyword">float</span> re, <span class="keyword">float</span> im)</span><br><span class="line">    : re_(re) , im_(im) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">float</span> re_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> im_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>内联变量（C++17）</strong><br>C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，const 缺省是不内联的，而 constexpr 缺省就是内联的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">magic</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">42</span>;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-类型推导"><a href="#1-3-类型推导" class="headerlink" title="1.3 类型推导"></a>1.3 类型推导</h3><p><strong>auto</strong><br>    - 自动类型推断<br>    - C++ 20开始可以函数传参<br>    - C++14开始可以用于返回值（包括decltype）</p>
<p>auto实际使用规则类似于函数模板参数推导<br>    -  <code>auto a = expr</code> 意味着用expr去匹配一个假想的 <code>template &lt;typename T&gt; f(T)</code> 函数模板，结果为值类型<br>    - <code>const auto&amp; a = expr</code> 意味着expr去匹配一个<code>template &lt;typename T&gt; f(const T&amp;)</code> 结果为常左值引用类型<br>    - <code>auto&amp;&amp; a = expr;</code> 意味着<code>template &lt;typename T&gt; f(T&amp;&amp;)</code> 函数模板</p>
<p>即根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。</p>
<p><strong>decltype</strong> </p>
<ul>
<li>decltype(变量名) 可以获得变量名的精确类型</li>
<li>decltype(表达式) -&gt; 获得表达式的引用<ul>
<li>如果是个纯右值（prvalue），结果仍然是值类型</li>
</ul>
</li>
</ul>
<p>尾返回类型（C++11）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x + y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值推导（C++14）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>decltype(auto) (C++14)</strong><br>写auto时要确定引用还是值类型，decltype(auto)可以根据表达式通用地决定返回的是值类型还是引用类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lookup1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类模板实参推导 (CTAD)(C++17 起)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span> pr&#123;<span class="number">1</span>, <span class="number">42</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span> a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h3><p><strong>if constexpr</strong> <strong>（C++17）</strong><br>允许代码中声明常量表达式的判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区间for（C++11）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-5-模板"><a href="#1-5-模板" class="headerlink" title="1.5 模板"></a>1.5 模板</h3><p>模板的哲学在于将问题丢到编译期去处理，大幅度优化运行时的性能，C++的黑魔法之一。</p>
<p><strong>外部模板</strong><br>为了解决重复实例化的问题，<strong>C++11</strong> 引入外部模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;; <span class="comment">// 强制实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;; <span class="comment">// 不在当前文件中实例化</span></span><br></pre></td></tr></table></figure>

<p><strong>using 语法用作类型别名(C++11)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="comment">// template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">// typedef MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变长参数模板(C++11)</strong><br>参数是可变的，但是如何解包（把类型拿下来）有以下处理：</p>
<ul>
<li>递归模板函数(C++11)，缺点在需要定义一个终止递归的函数</li>
<li>变参模板展开(C++17)</li>
<li>初始化列表展开</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printf1(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变参模板展开(C++17)，在一个函数中完成printf的编写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表展开</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-6-面向对象"><a href="#1-6-面向对象" class="headerlink" title="1.6 面向对象"></a>1.6 面向对象</h3><p><strong>委托构造（C++11）</strong><br>构造函数可以调用另一个构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> value1;</span><br><span class="line">	<span class="keyword">int</span> value2;</span><br><span class="line">	Base() &#123;</span><br><span class="line">		value1 = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Base(<span class="keyword">int</span> value) : Base() &#123;</span><br><span class="line">		value2 = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承构造（C++11）</strong><br>使用using 引入继承构造的概念</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>显式虚函数重载（C++11</strong></p>
<ul>
<li>override 通知编译器进行重载</li>
<li>final <ul>
<li>函数 final 表示</li>
<li>类 final 表示拒绝重载</li>
</ul>
</li>
<li>default </li>
<li>delete  </li>
</ul>
<p><strong>枚举类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">	value1, value2, value3 = <span class="number">100</span>, value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-运行时强化"><a href="#2-运行时强化" class="headerlink" title="2. 运行时强化"></a>2. 运行时强化</h2><h3 id="2-1-Lambda-表达式"><a href="#2-1-Lambda-表达式" class="headerlink" title="2.1 Lambda 表达式"></a>2.1 Lambda 表达式</h3><p>捕获方式：</p>
<ul>
<li>值捕获 <code>[value]</code></li>
<li>引用捕获 <code>[&amp;value]</code></li>
<li>隐式捕获 <ul>
<li><code>[&amp;]</code></li>
<li><code>[=]</code></li>
</ul>
</li>
<li>表达式捕获 C++ 14<ul>
<li>右值传递</li>
</ul>
</li>
<li>Lambda 泛型<ul>
<li>auto 用在参数表中</li>
</ul>
</li>
</ul>
<h3 id="2-2-函数包装器"><a href="#2-2-函数包装器" class="headerlink" title="2.2 函数包装器"></a>2.2 函数包装器</h3><ul>
<li>各种可调用对象</li>
<li>方便的函数容器</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value)-&gt;<span class="keyword">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-移动和右值"><a href="#2-3-移动和右值" class="headerlink" title="2.3 移动和右值"></a>2.3 移动和右值</h3><h4 id="2-3-1-值类别"><a href="#2-3-1-值类别" class="headerlink" title="2.3.1 值类别"></a>2.3.1 值类别</h4><p>值类别和值类型的差别：</p>
<ul>
<li><p><strong>值类别  value category</strong>：左右值 </p>
</li>
<li><p><strong>值类型/引用类型 value type</strong>：C++中，只有引用和指针是引用类型，Java中原生类型是值类型，类属于引用类型，Python中都是引用类型</p>
</li>
<li><p><strong>lvalue</strong>： 有标识符，可取地址的表达式，函数变量名，返回左值引用的表达式，字符串字面量</p>
</li>
<li><p><strong>rvalue</strong> ：包括prvalue 纯右值和xvalue将亡值</p>
</li>
<li><p><strong>prvalue</strong>: 纯右值，传统右值：没有标识符，不可以取地址的表达式，例如++x，除了字符串字面量之外的字面量，prvalue如果绑定到一个引用上，可以延长生命周期</p>
</li>
<li><p><strong>xvalue</strong>：将亡值，可以看成有名字的右值（有标识符）</p>
</li>
<li><p><strong>glvalue</strong> ：现在的左值范围，lvalue和xvalue</p>
</li>
</ul>
<h4 id="2-3-2-移动"><a href="#2-3-2-移动" class="headerlink" title="2.3.2 移动"></a>2.3.2 移动</h4><p><code>std::move</code> : 无条件地将实参强制类型转换为右值，产生一个xvalue</p>
<p><strong>原理：</strong> static_cast 到type &amp;&amp;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment">*  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment">*  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">move(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span>&#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>移动的意义：</strong><br><code>string res = string(&quot;hello&quot;) + name + &quot;.&quot;;</code>在C++之前是完全不推荐的，但是有了移动之后过程：</p>
<ol>
<li>调用<code>string(const *)</code>,生成Hello临时对象，复制一次</li>
<li>调用<code>operator+(string&amp;&amp;, const string&amp;)</code> 直接在1临时对象上操作，name复制一次</li>
<li>调用<code>operator+(string&amp;&amp;, const string&amp;)</code> 在后面追加操作</li>
<li>临时对象2析构</li>
<li>临时对象1析构</li>
</ol>
<p>对于实际内存布局而言， 例如A类中有B，C类，在Java或者Python这样的语言中存储的实际是指针（类似）。保证了<strong>内存访问的局部性</strong>，这在现代处理器架构中是有性能优势的。缺点是复制对象的开销大大增加，故有移动语义这样的东西存在。</p>
<h4 id="2-3-3-完美转发"><a href="#2-3-3-完美转发" class="headerlink" title="2.3.3 完美转发"></a>2.3.3 完美转发</h4><p><code>std::forward</code></p>
<p><strong>万能引用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temmplate &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// T&amp;&amp;称为万能引用</span></span><br><span class="line"><span class="comment">// auto&amp;&amp;也是万能引用</span></span><br></pre></td></tr></table></figure>

<p>如果是左值引用，则重载到&amp;&amp;，引用折叠，还是左值。如果是右值引用，重载到&amp;&amp;，引用折叠，是右值。这里的重载是为了检查右值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment">*  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span> &#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment">*  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">		<span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引用坍缩和完美转发</strong></p>
<p>引用坍缩主要是由于模板的推导结果可能是引用。即，对于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; foo(T&amp;&amp;);</span><br></pre></td></tr></table></figure>
<p>如果传递左值，则T推导为左值引用，如果传递是右值，则T推导为类型本身。T&amp;&amp;保持值类别进转发，即做到了完美转发。</p>
<h2 id="3-智能指针"><a href="#3-智能指针" class="headerlink" title="3.  智能指针"></a>3.  智能指针</h2><p>实现一个智能指针:</p>
<ul>
<li>unique_ptr <ul>
<li>需要考虑赋值运算符函数的问题</li>
<li>实现*, -&gt; 等运算符函数即可</li>
<li>在C++11之前auto_ptr实现有问题<ul>
<li>当一不小心传递给另外一个ptr，你就不再拥有这个对象了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto_ptr </span></span><br><span class="line"><span class="comment">//smart_ptr&amp; operator=(smart_ptr&amp; rhs) &#123;</span></span><br><span class="line"><span class="comment">//  smart_ptr(rhs).swap(*this);</span></span><br><span class="line"><span class="comment">//  return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr rhs) &#123;</span><br><span class="line">  rhs.swap(*<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(smart_ptr&amp; rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(m_ptr, rhs.m_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>shared_ptr实现（不考虑多线程）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">my_shared_ptr</span>;</span></span><br><span class="line">  <span class="comment">// default constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">my_shared_ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : <span class="title">m_ptr</span><span class="params">(ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">      m_shared_count = <span class="keyword">new</span> shared_count();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy constructor func</span></span><br><span class="line">  my_shared_ptr(<span class="keyword">const</span> my_shared_ptr&amp; other) &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">      other.m_shared_count-&gt;add_count();</span><br><span class="line">      m_shared_count = other.m_shared_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy constructor func for pointer cast</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  my_shared_ptr(<span class="keyword">const</span> my_shared_ptr&lt;U&gt;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">      other.m_shared_count-&gt;add_count();</span><br><span class="line">      m_shared_count = other.m_shared_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dynamic cast copy constructor</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  my_shared_ptr(<span class="keyword">const</span> my_shared_ptr&lt;U&gt;&amp; other, T* ptr) &#123;</span><br><span class="line">    m_ptr = ptr;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123; <span class="comment">// if m_ptr is empty, do not add the count</span></span><br><span class="line">      other.m_shared_count-&gt;add_count();</span><br><span class="line">      m_shared_count = other.m_shared_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// move constructor func</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  my_shared_ptr(my_shared_ptr&lt;U&gt;&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    m_ptr = other.m_ptr;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">      m_shared_count = other.m_shared_count;</span><br><span class="line">      <span class="comment">// move from other</span></span><br><span class="line">      other.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// operator =</span></span><br><span class="line">  my_shared_ptr&amp; <span class="keyword">operator</span>=(my_shared_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    rhs.swap(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deconstructor func</span></span><br><span class="line">  ~my_shared_ptr() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr &amp;&amp; !m_shared_count-&gt;reduce_count()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_ptr;</span><br><span class="line">      <span class="keyword">delete</span> m_shared_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_shared_count-&gt;get_count();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *m_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// swap function to swap two shared_pointers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(my_shared_ptr&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(m_ptr, rhs.m_ptr);</span><br><span class="line">    swap(m_shared_count, rhs.m_shared_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* m_ptr;</span><br><span class="line">  shared_count* m_shared_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-STL"><a href="#4-STL" class="headerlink" title="4.  STL"></a>4.  STL</h2><p><strong>Array</strong><br>优点：</p>
<ul>
<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>
<li>C 数组没有良好的复制行为，无法作为键类型</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/10/%E5%A4%A7%E8%AF%9D%E5%AD%98%E5%82%A81/" rel="prev" title="存储读书笔记 01">
      <i class="fa fa-chevron-left"></i> 存储读书笔记 01
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/20/FUSE/" rel="next" title="FUSE访问流程图">
      FUSE访问流程图 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">1.  语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 变量及其初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 面向对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%BA%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">2. 运行时强化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Lambda 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%87%BD%E6%95%B0%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 函数包装器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%8F%B3%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 移动和右值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%80%BC%E7%B1%BB%E5%88%AB"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 值类别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%A7%BB%E5%8A%A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 移动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 完美转发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">3.  智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-STL"><span class="nav-number">4.</span> <span class="nav-text">4.  STL</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="木慕的博客"
      src="/images/favicon.jpg">
  <p class="site-author-name" itemprop="name">木慕的博客</p>
  <div class="site-description" itemprop="description">木慕的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/tigerroarm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tigerroarm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:difanmu@gmail.com" title="E-Mail → mailto:difanmu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



    <div class="links-of-blogroll motion-element links-of-blogroll-block">
      <div class="links-of-blogroll-title">
        <!-- modify icon to fire by szw -->
        <i class="fa fa-history fa-" aria-hidden="true"></i>
        近期文章
      </div>
      <ul class="links-of-blogroll-list">
        
        
        
          <li>
            <a href="/2023/06/20/C++%E5%B9%B6%E5%8F%91/" title="C++并发" target="_blank">C++并发</a>
          </li>
        
          <li>
            <a href="/2023/03/20/APUE/" title="APUE" target="_blank">APUE</a>
          </li>
        
          <li>
            <a href="/2023/01/20/FUSE/" title="FUSE访问流程图" target="_blank">FUSE访问流程图</a>
          </li>
        
          <li>
            <a href="/2022/06/20/%E7%8E%B0%E4%BB%A3C++/" title="现代C++" target="_blank">现代C++</a>
          </li>
        
          <li>
            <a href="/2022/04/10/%E5%A4%A7%E8%AF%9D%E5%AD%98%E5%82%A81/" title="存储读书笔记 01" target="_blank">存储读书笔记 01</a>
          </li>
        
      </ul>
    </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木慕的博客</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '9eFpMRHKYdm4ucton4CTUrAd-gzGzoHsz',
      appKey     : 'EbiAV4uFtmudGKkNbsCTpGCA',
      placeholder: "输入您的评论",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
