{"meta":{"title":"Tigerroarm's Blog","subtitle":"Stay naive, stay simple. <br> Love math, love coding.","description":"Tigerroarm的博客","author":"Tigerroarm","url":"https://blog.difan.tech","root":"/"},"pages":[{"title":"关于我","date":"2021-09-05T16:33:28.473Z","updated":"2021-04-29T13:52:13.332Z","comments":false,"path":"about/index.html","permalink":"https://blog.difan.tech/about/index.html","excerpt":"","text":"我是谁？ 我是 Tigerroarm 本科毕业于华中科技大学，现为本校电信学院在读硕士 Huster &amp; Developer 这里主要记录自己的笔记和想做的一些东西 我的兴趣 Linux C/C++ 数学（统计、信息论） 课余爱好 口琴爱好者 巴洛克音乐爱好者，喜欢巴赫 另：我写了一些读书笔记在这里 https://notes.difan.tech，欢迎您联系我提出建议~"},{"title":"guestbook","date":"2021-01-23T10:50:22.000Z","updated":"2021-01-23T10:50:22.670Z","comments":true,"path":"guestbook/index.html","permalink":"https://blog.difan.tech/guestbook/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-21T15:28:38.000Z","updated":"2020-01-21T17:48:08.376Z","comments":false,"path":"categories/index.html","permalink":"https://blog.difan.tech/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-21T16:29:30.000Z","updated":"2020-01-21T17:48:29.174Z","comments":false,"path":"tags/index.html","permalink":"https://blog.difan.tech/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-09-05T16:20:10.705Z","updated":"2020-01-21T15:33:54.268Z","comments":true,"path":"/404.html","permalink":"https://blog.difan.tech/404.html","excerpt":"","text":"404Page not found! :("}],"posts":[{"title":"我的笔记记录汇总","slug":"我的笔记（目录）","date":"2021-09-05T15:43:30.921Z","updated":"2021-04-11T07:54:04.116Z","comments":true,"path":"2021/09/05/我的笔记（目录）/","link":"","permalink":"https://blog.difan.tech/2021/09/05/%E6%88%91%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%88%E7%9B%AE%E5%BD%95%EF%BC%89/","excerpt":"","text":"Category Name Link Computer Science CSAPP CSAPP Notes CSAPP Lab Coding Notes Leetcode LeetCode Solution Math &amp; Signal Processing Digital Signal Processing DSP Code Notes Electronic Engineering Wireless Communications Communication Code Notes(Part 1)","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.difan.tech/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"Inband Full-duplex Wireless Communication System","slug":"fullduplex","date":"2021-09-05T15:43:30.746Z","updated":"2021-03-29T07:22:49.754Z","comments":true,"path":"2021/09/05/fullduplex/","link":"","permalink":"https://blog.difan.tech/2021/09/05/fullduplex/","excerpt":"动机全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-BandFull-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。","text":"动机全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-BandFull-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。 主要想法要实现全双工，主要就是减少自干扰（self-interference），即同一设备发射的信号对于接收信号的干扰。WiFi信号的平均功率为20dBm（100mW），接收机的噪声基底（noisefloor）大致为-90dBm，所以要将自干扰降低到-90dBm，需要降低110dB的线性抵消能力。 对于非线性自干扰（Harmonics），其为-10dBm（比基底高80dB），即需要80dB的非线性抵消能力。 图 1 抵消目标[1] 图1中，我们看到，SIC中线性分量是主要分量，发射机噪声为-40dBm，由于OFDM的PAPR特性所以我们需要预留10dB，即模拟域需要提供60dB的消除能力。 自干扰分析在WiFi场景下，自干扰主要有以下三种（如图1所示） 天线与环行器阻抗不匹配导致的反射分量 RA 环行器1端口到3端口的泄露分量 I 环境散射分量RC 图 2 自干扰分析图 具体实现方法4.1 天线隔离 环行器 Circulator（大部分的方法） 电平衡 EBD (×) 4.2 RF域（模拟域）干扰抵消4.2.1 IMT 方法（RF front）[2]I和RA因为没有路径损耗，具有主要的能量，是我们在模拟域/RF域主要需要抵消的信号。RC由于其环境反射特性可以在数字域建模消除。 使用IMT网络控制RA的振幅和相位，直接抵消I。 根据计算得到反射系数结果： S为端之间的回波损耗。 上图具有并联和串联变容二极管的可重配置IMT电路的示意图，可以通过调整Vs，Vp来调整Zin。 ZL是天线输入阻抗，根据反射系数定义，可以得到： Z0是环行器器2端口的特性阻抗。 实验部分： 用了RFCI CR5853环行器，15.5dB固有隔离度。Skyworks Inc的可变容二极管SMV 2019 结果： 图3 IMT结果 4.2.2 信号重建方法 SR-SIC（第一阶段）以[1]为代表的抽头延迟线横向滤波器，通过对射频信号采样，用sinc函数插值重建原始信号。是我们第一阶段采用的方法。 图 4 时域信号重建方法 图4为时域的方法，基于时域的抵消架构对发射信号进行采样，并将其分成不同的分支，称为抽头。这些抽头中的每一个都有不同的时间延迟，并且可以在组合成单个输出之前独立调整信号的幅度和相位。正是这种延迟和抽头的复杂加权使得抵消器能够匹配自干扰信号，并产生与接收机内的自干扰相消的信号。 由于使用原始信号进行信号重建，故其发射机噪声可以被消除（也只能在模拟域进行消除）。其线性消除能力为62dB，非线性能力为30dB 当然也有频域相关的方法，可以参考哥伦比亚大学JinZhou团队，优点是可以芯片小型化，缺点是目前为止其指标并不高。 4.2.3 信道响应方法 CR-SIC[8]中的方法 4.2.4 数字域辅助模拟域方法[5]的方法，可以作为参考 4.3 数字域干扰抵消参考[3]和专著[12] 4.3.1 功放模型在理想情况下，对于均值为0的射频信号，我们期望功率放大器的输出信号总是其输入信号的线性放大 其中表示某一常数。然而在实际情况中功率放大器的增益是一个随着输入信号大小而变化的函数 图 4 幅度-幅度（AM-AM）特性 幅度-相位（AM-PM）特性 AM-AM特性和AM-PM特性指的是输入幅度变化造成的输出幅度和输出相移的非线性改变。早期通信系统带宽比较窄，远小于功放的工作带宽，所以使用无记忆模型，在频域上的体现就是功率放大器的行为特性不依赖于信号频率。当通信的带宽越来越大，其记忆效应更加明显，简单的无记忆模型不再适用。其记忆效应在频域体现在频率依赖行为，在时域体现在不仅与当前信号有关，还与过去一段时间信号有关。 记忆效应分为长记忆效应（线性记忆效应）和短记忆效应（非线性记忆效应），前者与匹配网络有关，后者主要由于功放的低频散射，具体模型如表1所示。 功放非线性指标 1dB压缩点:相对线性增益降低1dB的输出功率点 三阶截断点:IP3 表1 常用功放模型分类 无记忆模型 多项式模型 结构简单，参数辨识度高 记忆模型 两盒模型 Wiener 线性滤波+静态非线性模块（无记忆） Hammerstein 静态非线性模块（无记忆）+线性滤波 Volterra级数及其改进形式 记忆多项式模型(Memory Polynomial)的性能具有稳健性，多种情况下优于Wiener, Hammerstein等模型的线性化性能，结构简单，复杂度低。 PA的Volterra级数模型一般形式的Volterra模型为： (4.3.1-1) 称为Volterra的kernels，一般只考虑奇数项，那么Volterra在功放中的表示形式如下 (4.3.1-2) 为对角项，其它求和项为交叉项。如果我们忽略交叉项，只保留对角项，则简化为如下多项式模型： (4.3.1-3) 4.3.2 线性消除闭环方法同模拟域类似，可以使用具有数字可控时间延迟单元和复杂抽头加权的抽头延迟线结构，如下图所示，可以通过LMS等等方法调整权重，好处是在数字域处理更加灵活，抽头数可以更多，自适应性强，可以实时调整权重。 图 4 数字域闭环方法 开环方法主要是[1]中的方法，使用WiFi Preamble进行LS信道估计后恢复信号。 我们同样使用PH模型进行PA建模： 其中2K-1是该模型的阶数，L是该模型的抽头数。其矩阵形式可表示为： 其中 其中的Y是带有噪声的向量，通过LS算法求出B后再进行模型重建。 4.3.2 非线性消除Parallelizable-Hammerstein 模型功放的模型可以参考[4]。 参考文献[1] Bharadia, D., McMilin, E., &amp; Katti, S. (2013). Full duplex radios. ACMSIGCOMM. https://doi.org/10.1145/2534169.2486033 [2] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). InherentSelf-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.https://doi.org/10.1109/TMTT.2018.2818124 [3] Kolodziej, K. E., Perry, B. T., &amp; Herd, J. S. (2019). In-Band Full-DuplexTechnology: Techniques and Systems Survey. IEEE Transactions on Microwave Theoryand Techniques, 67(7), 3025–3041. https://doi.org/10.1109/TMTT.2019.2896561 [4] Isaksson, M., Wisell, D., &amp; Rönnow, D. (2006). A comparative analysis ofbehavioral models for RF power amplifiers. IEEE Transactions on Microwave Theoryand Techniques, 54(1), 348–359. https://doi.org/10.1109/TMTT.2005.860500 [5] Liu, Y., Quan, X., Pan, W., &amp; Tang, Y. (2017). Digitally Assisted AnalogInterference Cancellation for In-Band Full-Duplex Radios. IEEE CommunicationsLetters, 21(5), 1079–1082. https://doi.org/10.1109/LCOMM.2017.2652444 [6] Kolodziej, K. E., McMichael, J. G., &amp; Perry, B. T. (2016). Multitap RFCanceller for In-Band Full-Duplex Wireless Communications. IEEE Transactions onWireless Communications, 15(6), 4321–4334.https://doi.org/10.1109/TWC.2016.2539169 [7] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.IEEE Communications Magazine, 54(9), 80–87.https://doi.org/10.1109/MCOM.2016.7565192 [8] Choi, Y. S., &amp; Shirani-Mehr, H. (2013). Simultaneous transmission andreception: Algorithm, design and system level performance. IEEE Transactions onWireless Communications, 12(12), 5992–6010.https://doi.org/10.1109/TWC.2013.101713.121152 [9] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.IEEE Communications Magazine, 54(9), 80–87.https://doi.org/10.1109/MCOM.2016.7565192 [10] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). InherentSelf-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.https://doi.org/10.1109/TMTT.2018.2818124 [11] Wu, X., Shen, Y., &amp; Tang, Y. (2014). The Power Delay Pro fi le of theSingle-Antenna. 13, 1561–1564. [12] Full-Duplex Wireless Communications Systems.(2017).","categories":[{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/categories/EE/"}],"tags":[{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/tags/EE/"}]},{"title":"POSIX thread","slug":"C 多线程","date":"2021-05-09T16:00:00.000Z","updated":"2021-05-13T08:57:46.729Z","comments":true,"path":"2021/05/10/C 多线程/","link":"","permalink":"https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"POSIX thread Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。 POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。 多处理器用多线程：效果最好 单处理器使用多线程： 也有增益（一个线程等IO，另外的执行） 适用场景 多任务同时进行 阻止潜在的长时间IO等待 一些地方很多CPU周期 必须响应异步 优先级中断","text":"POSIX thread Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。 POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。 多处理器用多线程：效果最好 单处理器使用多线程： 也有增益（一个线程等IO，另外的执行） 适用场景 多任务同时进行 阻止潜在的长时间IO等待 一些地方很多CPU周期 必须响应异步 优先级中断 线程基础线程共享模型所有线程都可以访问相同的全局共享内存,但是也有自己的私有数据。 线程安全由多个线程共享资源引起的，如果例程没有使用某种类型的同步结构来防止数据损坏，那么它就不是线程安全的。 线程限制依赖于具体实现（我的WSLunlimit -Hu）： 1234567891011121314151617tigerroarm@Mudifan:~$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 50633max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 50633virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 线程共享如下资源 进程指令（ Process instructions） 大部分数据 文件描述符 signals 和 signal handlers 当前目录 User 和 group id 每个线程独立有： Tread ID registers, stack pointer集合 local variables, return addresses 栈 signal mask priority Return value: errno pthread 如果OK会return 0 编译程序需要用： gcc -pthread thread_program.c 创建线程1234int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void *arg); thread : 返回的thread ID attr: 使用默认thread 就NULL start_routine: 需要线程运行的函数 arg: 函数参数 进程同步thread 库提供了三种同步机制 互斥（mutexes）:互斥锁（mutual exclusion lock） joins: 等待其他进程完成 条件变量: pthread_cond_t mutex:用pthread_mutex_lock和pthread_mutex_unlock加锁解锁 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *functionC();pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;int counter = 0;main()&#123; int rc1, rc2; pthread_t thread1, thread2; /* Create independent threads each of which will execute functionC */ if( (rc1=pthread_create( &amp;thread1, NULL, &amp;functionC, NULL)) ) &#123; printf(&quot;Thread creation failed: %d\\n&quot;, rc1); &#125; if( (rc2=pthread_create( &amp;thread2, NULL, &amp;functionC, NULL)) ) &#123; printf(&quot;Thread creation failed: %d\\n&quot;, rc2); &#125; /* Wait till threads are complete before main continues. Unless we */ /* wait we run the risk of executing an exit which will terminate */ /* the process and all threads before the threads have completed. */ pthread_join( thread1, NULL); pthread_join( thread2, NULL); exit(0);&#125;void *functionC()&#123; pthread_mutex_lock( &amp;mutex1 ); counter++; printf(&quot;Counter value: %d\\n&quot;,counter); pthread_mutex_unlock( &amp;mutex1 );&#125; Joins等待线程完成。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define NTHREADS 10void *thread_function(void *);pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;int counter = 0;main()&#123; pthread_t thread_id[NTHREADS]; int i, j; for(i=0; i &lt; NTHREADS; i++) &#123; pthread_create( &amp;thread_id[i], NULL, thread_function, NULL ); &#125; for(j=0; j &lt; NTHREADS; j++) &#123; pthread_join( thread_id[j], NULL); &#125; /* Now that all threads are complete I can print the final result. */ /* Without the join I could be printing a value before all the threads */ /* have been completed. */ printf(&quot;Final counter value: %d\\n&quot;, counter);&#125;void *thread_function(void *dummyPtr)&#123; printf(&quot;Thread number %ld\\n&quot;, pthread_self()); pthread_mutex_lock( &amp;mutex1 ); counter++; pthread_mutex_unlock( &amp;mutex1 );&#125; Condition Variables为什么需要条件变量使用互斥锁的时候，如果有一个下面的情况 线程1: 如果有变化，就把本地buff save 到cloud上 线程2：改本地buff，标记变化 123456789//thread 1while(1) &#123; pthread_mutex_lock(lock); if(is_change) &#123; save_to_cloud(buff); is_change = false; &#125; pthread_mutex_unlock(lock);&#125; 12345678910//thread 2while(1) &#123; char = tmp[50]; read(tmp, 50); pthread_mutex_lock(lock); strcpy(buff, tmp); is_change = true; pthead_mutex_unlock(lock);&#125; 如果这时候is_change 一直是false， 那么thread1一直在执行循环。 想达到的目的是：直到某个状态改变，才开始执行 需要的是lock+condition 就需要有条件变量 互斥锁通过控制线程对数据的访问来实现同步，而条件变量允许线程根据数据的实际值进行同步。如果没有条件变量，程序员将需要线程持续轮询(可能在关键部分) ，以检查条件是否满足。这可能会非常消耗资源，因为线程在此活动中将持续忙碌。条件变量是一种不用轮询就可以实现相同目标的方法。 使用 主线程： 声明和初始化需要同步的全局数据/变量(例如“ count”) 声明和初始化条件变量对象 声明并初始化一个的互斥锁 创建线程 a 和 b 来做工作 线程A 一直工作到某个条件必须发生的点(例如“ count”必须达到指定的值) 锁住互斥锁，然后检查值 pthread_cond_wait() ，阻塞等待来自B线程信号（自动解锁相关的互斥锁） 当收到信号时就唤醒进程 线程B 锁住互斥锁 更改线程A正在等待的全局变量的值 检查全局变量的值，如果满足条件，给A发信号 解锁互斥锁 具体方法 pthread_cond_wait() 阻塞线程直到条件达到 pthread_cond_init pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_cond_signal()：唤醒另一个等待条件变量的信号 参考 Linux Tutorial: POSIX Threads (cmu.edu) Multi-Threaded Programming With POSIX Threads (kent.edu)","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/categories/C-C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.difan.tech/tags/Unix/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"}]},{"title":"C 网络编程","slug":"C 网络编程","date":"2021-05-04T16:00:00.000Z","updated":"2021-05-10T06:28:41.000Z","comments":true,"path":"2021/05/05/C 网络编程/","link":"","permalink":"https://blog.difan.tech/2021/05/05/C%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/categories/C-C/"}],"tags":[{"name":"Unix","slug":"Unix","permalink":"https://blog.difan.tech/tags/Unix/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://blog.difan.tech/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"HTTP 协议","slug":"HTTP协议","date":"2021-02-28T16:00:00.000Z","updated":"2021-09-05T16:51:51.442Z","comments":true,"path":"2021/03/01/HTTP协议/","link":"","permalink":"https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"超文本传输协议（HTTP协议） 特点： 简单 易解析 可读性好 RFC 2616 Link (HTTP 1.1)","text":"超文本传输协议（HTTP协议） 特点： 简单 易解析 可读性好 RFC 2616 Link (HTTP 1.1) HTTP 版本 HTTP/1.1 : 1999年 RFC 2616，还有RFC7230。目前少于三分之一的网站使用（包括其和其早期版本）。 1.1相比于1.0：使用一个TCP连接可以传多个HTTP request/response（引入keep-alive-mechanism，HTTP长连接）， client不需要在发送第一个请求后重新协商 TCP 3-Way-Handshake 连接。 1.1相比于1.0：带宽优化：使用了分块传输编码（Chunked transfer encoding）的流式传输机制，即把内容分块（Chunk）进行流式传输 HTTP/2.0 : 2015年，超过一半的网站使用，以谷歌的SPDY为基础开始指定的新版本HTTP协议，RFC 7540. HTTP/3.0 : HTTP over QUIC，18%网站使用，使用UDP作为底层传输协议 HTTP RequestHTTP Request 是client端向server端做的一个请求。 包括： 一个请求行： GET /images/logo.png HTTP/1.1 请求头：Accept-Language: en Link Accept-Language: en Accept-Ranges: type：指定bytes可以作为一个单位去定义一个range，如果是none则表示不支持partial request。 空行 HTTP 消息正文( message body) : 可选 请求行和其他头字段必须以 &lt;CR&gt;&lt;LF&gt;结尾，空行只包括 &lt;CR&gt;&lt;LF&gt;且无空格 HTTP 方法 GET （1.0） HEAD（1.0） ：除了没有响应体外（Response body）与 GET 请求相同，可以用于检索 POST （1.0） ：请求服务器接收包括的entity OPTIONS（1.1） ： 返回某个URL支持的HTTP 方法 PUT （1.1）： 请求服务器将entity的保存在URI下（如果存在则修改，不存在则新建） DELETE（1.1） ：删除 TRACE （1.1） ： 回复收到的请求，client知道server做了什么改动，由于XST攻击建议关闭 CONNECT （1.1）: 用于proxy较多 HTTP method RFC Request has Body Response has Body Safe Idempotent Cacheable GET RFC 7231 No Yes Yes Yes Yes HEAD RFC 7231 Optional No Yes Yes Yes POST RFC 7231 Yes Yes No No Yes PUT RFC 7231 Yes Yes No Yes No DELETE RFC 7231 Optional Yes No Yes No CONNECT RFC 7231 Optional Yes No No No OPTIONS RFC 7231 Optional Yes Yes Yes No TRACE RFC 7231 No Yes Yes Yes No PATCH RFC 5789 Yes Yes No No No 表格来自[1] HTTP Response 状态行 ：HTTP/1.1 200 OK 响应头： Content-Type: text/html 空行 消息体 状态码（status code） 信息 1XX 成功 2XX 200 OK 重定向Redirection 3XX Client Error 4XX Server Error 5XX 几个常见的状态码： 206 : Partial Content 200: OK 404: Not Found 500: Internal Server error 例子12GET / HTTP/1.1Host: www.example.com 123456789101112131415161718HTTP/1.1 200 OKDate: Mon, 23 May 2005 22:38:34 GMTContent-Type: text/html; charset=UTF-8Content-Length: 155Last-Modified: Wed, 08 Jan 2003 23:11:55 GMTServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)ETag: &quot;3f80f-1b6-3e1cb03b&quot;Accept-Ranges: bytesConnection: close&lt;html&gt; &lt;head&gt; &lt;title&gt;An Example Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Reference[1] https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol [2] https://en.wikipedia.org/wiki/List_of_HTTP_header_fields [3] https://www.w3.org/Protocols/rfc2616/rfc2616.html","categories":[{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/categories/Network/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.difan.tech/tags/http/"}]},{"title":"MATLAB编程指北","slug":"MATLAB编程指北","date":"2021-01-15T16:00:00.000Z","updated":"2021-01-23T12:46:24.372Z","comments":true,"path":"2021/01/16/MATLAB编程指北/","link":"","permalink":"https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/","excerpt":"常用技巧 折叠 ctrl = 折叠代码 shift ctrl =展开代码 缩进整理 ctrl i（==全选+ctrl i==） 跳转到第几行 ctrl g F5运行，F10 debug，shift+F5 退出Debug模式 doc 取代help，直接跳出文档（由于外网，网络可能不稳定）","text":"常用技巧 折叠 ctrl = 折叠代码 shift ctrl =展开代码 缩进整理 ctrl i（==全选+ctrl i==） 跳转到第几行 ctrl g F5运行，F10 debug，shift+F5 退出Debug模式 doc 取代help，直接跳出文档（由于外网，网络可能不稳定） 提醒 注意，MATLAB所有序号都是==从1开始== MATLAB中 ==Class Array== 的思想随处不在 例如对于a = 54，使用whos命令可以看到，MATLAB认为这是一个Size 1×1 8 Bytes的double array，==而非一个简单的double变量==。 再例如，str1 =&quot;string&quot;，是一个Size 1×1的，150 Bytes的Class为String的Array变量。也就是说，你完全可以直接str1(2) = “string2”，这种操作被理解为在str1这个string array变量中增加了一个元素。 同样的，char = &#39;char&#39;是定义了一个Size 1×4的，Bytes为8的 Class 为 char的Array变量。 使用%% %来区分不同Block的代码是一种好方法 数据类型 double single（单精度） logical int8(1B 8bit) int16 int32 int64 uint8 char(‘’) string(“”) NaN(Not a Number) Inf(无穷)：有正负之分 cell struct function_handle 常用矩阵操作 flipud(M): 翻转矩阵，从下面往上反转 fliplr：左右翻转 flip([])： 翻转向量，矩阵的话和ud一样 repmat(A, 2, 3)：横向重复两次，纵向3次 repelem(A, 2, 3)：repeat element 原来矩阵每个元素都2×3，重新组成新的 max(A):每列中最大的元素 diff(): 每次相邻两个元素之间做差 prod() :返回数组乘积 cumsum()：返回前n个元素的和 cumprod() cummin() cummax() linspace(x1,x2,n) ：产生n个x1到x2的数据，间隔(x2-x1)/(n-1) logspace(x1,x2,n)： 产生n个$$10^{x1}$$到x2的数据 增删改查 find(logical_vector, k, &#39;first&#39;) ：首k个true值 any(logical_vector) all(logical_vector) 绘图 线颜色 b : blue g : green r : red c : cyan 青蓝色 m : magenta 品红色 y : yellow k ：black w ：white 线样式 -- 段虚线 : 点虚线 -. 段点虚线 marker *-. *为marker o . x s square 方块 d 菱形 v ^ &lt; &gt; p 五角形 h 六角形 close all 关闭所有的figure clf 清空当前画布 clear current figure 还有cla，清空坐标区 subplot(row, col, n_th) grid on 网格 legend() 图例 xlabel(&#39;&#39;) ylabel(&#39;&#39;) title(&#39;&#39;) 如果要LaTeX显示，需要在后面的&#39;Interpreter&#39;设置为&#39;latex&#39; 例如 1title([&#x27;Predictive signal $\\hat&#123;d&#125;(n)$ and orignal signal $d(n)$ with p=&#x27;,num2str(p)],&#x27;Interpreter&#x27;,&#x27;latex&#x27;); plot修饰 color+marker+line_shape, e.g. &#39;ro-.&#39; LineWidth 默认为1 MarkerEdgeColor Marker边缘的颜色 MakerFaceColor Marker里面的颜色 axis([x1 x2 y1 y2]) 设置坐标轴范围 字符和字符串 strlength(&quot;string&quot;)： 字符串长度 string 类型可以通过&#123;&#125;的方式提取出char类型结果，例如可以通过string&#123;1&#125;(2)提取出第一个string中的第二个char input(&#39;Some suggestion string:&#39;,&#39;s&#39;) 输入的是char类型 Upper，全部大写 strcmp(str1, str2, num)，前num位的字符是否相同 strfind(text, pattern) 找text中pattern 的位置 strsplit(text, pattern) split 字符串 元胞数组 &#123;48, &quot;uui&quot;, 1:4:9&#125; 访问使用{index} {1,2} 结构体 S = struct(&#39;field1&#39;,VALUES1,&#39;field2&#39;,VALUES2,...) 保存加载 save testfile.dat mydata -ascii save 文件名 变量名 load file_name.dat 可变长输入输出 varargin{1}： variable argument input, cell 类型，存储输入参数 nargin 输入参数个数 varargout 输出参数 nargout 输出个数 本地函数和嵌套函数 本地函数，单个m文件中定义的函数，作用域为整个m文件 嵌套函数（可以使用所有外层函数定义的量） 函数句柄 function_handle，为一个单独的数据类型 使用 func_han = @(argm1, argm2) argm1*argm2; 即可定义手柄 func2str(func_hndl);得到函数名字 相关函数 fplot(@sin(), [0, 2*pi]) feval(@sin(), 0:0.1:1) 返回每个值对应的函数输出 timeit(func_handle)，算函数计算的时间通信相关 qammod12ModDataTX = qammod(BinData, MOD, &#x27;InputType&#x27;, &#x27;bit&#x27;, &#x27;PlotConstellation&#x27;,true);% 对于输入bit 流进行 QAM调制，MOD是调制阶数，InputType指定输入类型 注意 matlab中 vector’ 如果是vector复数向量，就算的直接是共轭转置，这个被坑过，如果想只转置可以用 vector.’ berfading估计fading时的性能，参数是SNR，调制方式，调制模，复用参数 12345678910111213EbNo = 8:2:20; % Eb/N0ber = zeros(length(EbNo),20);for L = 1:20 ber(:,L) = berfading(EbNo,&#x27;qam&#x27;,16,L); % 16 QAMendsemilogy(EbNo,ber,&#x27;b&#x27;)text(18.5, 0.02, sprintf(&#x27;L=%d&#x27;,1))text(18.5, 1e-11, sprintf(&#x27;L=%d&#x27;,20))title(&#x27;QAM over fading channel with diversity order 1 to 20&#x27;)xlabel(&#x27;E_b/N_0 (dB)&#x27;)ylabel(&#x27;BER&#x27;)grid on 随机数rng(&#39;shuffle&#39;)来使用当前时间作为随机数种子 rand0-1 随机数 randi伪随机整数 X = randi([imin,imax],size_1,size_2) X = randi(imax,sz1,…,szN) 123randi([min max], row_number, col_number);% e.g.randi([0 10], 1000, 1); % Generate 1000✖1 random vector with range from 0 to 10 randnrandn生成正态分布随机数 X = randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。 X = randn(sz1,…,szN) 返回由随机数组成的 sz1×…×szN 数组，其中 sz1,…,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。 X = randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/categories/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/tags/MATLAB/"}]},{"title":"数字信号处理 -- 基于计算机方法","slug":"DSP","date":"2020-12-26T16:00:00.000Z","updated":"2020-12-28T16:00:00.000Z","comments":true,"path":"2020/12/27/DSP/","link":"","permalink":"https://blog.difan.tech/2020/12/27/DSP/","excerpt":"目录： 本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记","text":"目录： 本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记 信号与信号处理信号信号分类 振幅 时间 连续时间信号 振幅也连续：模拟信号 离散时间信号 振幅离散：数字信号 复数信号和解析信号复数信号 Why? 信号表示更加复杂（相位，幅度） -&gt; 信息量很大 -&gt; 信号处理更加简单，易于处理 希尔伯特变换 HT $h_{HT} = \\frac{1}{\\pi t}$ $H_{HT}(j\\Omega) = \\begin{cases} -j &amp; \\Omega &gt; 0 \\\\ j &amp; \\Omega &lt; 0 \\end{cases} $ 实数信号 实数信号 FT性质 =&gt; 幅度偶对称，相位奇对称 正频率 + 负频率 $X(j\\Omega) = X_p(j\\Omega)+X_n(j\\Omega)$ 经过HT =&gt; $\\hat{X}(j\\Omega) = -j X_p(j\\Omega)+jX_n(j\\Omega)$ =&gt; $\\hat{x}(t)$也是实数信号 解析信号=&gt; 解析信号 $y(t) = x(t) + j\\hat{x}(t)$ $x(t), \\hat{x}(t)$ 为同相分量和正交分量 $Y(j\\Omega) = X(j\\Omega)+j\\hat{X}(j\\Omega) = 2 X_p(j\\Omega)$ 我们可以看出解析信号只包含正频率的部分 信号运算 简单运算 衰减 延迟 $y(t) = x(t-t_0)$ 相加，相乘 积分 $y(t) = \\int_{-\\infty}^{t}x(\\tau) d\\tau$ 微分 $y(t) = \\frac{dx(t)}{dt}$ 傅里叶变换Fourier Transform(FT) $X(j\\Omega) = \\int_{-\\infty}^{+\\infty}x(t) e^{-j\\Omega t} dt$ 滤波 $y(t) = \\int_{-\\infty}^{+\\infty} h(t-\\tau)x(\\tau)d\\tau$ 低通，高通，带通 带阻（陷波器3） 多频带滤波器：多个通带阻带 梳状滤波器：阻断某个低频的整数倍 调制 Why? 低频信号无法直接用于传输 调制到高频进行传输- 原理：利用信号的振幅、相位、频率表示信号 时域离散时间信号离散时间信号， Why？ 现代计算机、微处理器、嵌入式设备都是处理数字信号的，但是我们的物理世界充斥着连续信号（模拟信号），如声音信号等。而直接处理模拟信号是比较困难的（1G通信），设备器件做的很大（大哥大），而且不便于加密（你树根天线就能窃听到隔壁老王在电话里说什么）。这就涉及到模拟信号数字化（采样，或者抽样），转换为数字信号进行处理。 时域表示采样： $x[n] = x_a{(t)}|_{t = nT} = x_a(nT)$ 采样频率（抽样频率）： $F_t = \\frac{1}{T}$ 采样得到的值由于ADC（数模转换器）的精度问题（例如12 Bit ADC）有舍入的问题。 频域表示归一化角频率：$\\omega_c$ 为归一化角频率，因为样本$n$是无量纲的，所以应该是弧度/样本，且$$\\omega = 2\\pi f$$$f$ 是归一化角频率， 单位是周期/样本，即一个样本多少周期 运算例子2.1：集合平均 $s[n]=2[n(0.9)^n]$ 和噪声$d(n)$，受干扰后的集合平均可以减少干扰影响 123456789101112131415161718192021222324252627282930313233343536373839% Program_2_1% Generation of the ensemble averageN = 50; % total numbern = 0 : N-1;s = 2*(n.*0.9.^n); % generate the original signal s[n]rng();d = rand(N, 1) - 0.5; % generate the noise signal d[n]x1 = s+d&#x27;; % the corrupted signal% Plot the corrupted signalsubplot(2,1,1)stem(n, x1);xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Corrupted Signal&#x27;)% Plot the Noise Signalsubplot(2,1,2)stem(n, d)xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Noise Signal&#x27;)% Ensemble averagefor m = 1:50 rng(); noise = rand(N,1) - 0.5; x = s + noise&#x27;; x1 = x1 + x;endx1 = x1 / N;% Plot the ensemble average signalfigure;stem(n, x1);xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Ensemble Average Signal&#x27;) 卷积使用函数conv即可作为卷积运算 抽样率转换抽样率转换比: $\\frac{F_T^{‘}}{F_T} = R$, $F_T$ 是原本的抽样率, 再拿$F_T^{‘}$ 去抽样 序列分类 周期、非周期 能量信号、功率信号","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DSP","slug":"DSP","permalink":"https://blog.difan.tech/tags/DSP/"},{"name":"Math","slug":"Math","permalink":"https://blog.difan.tech/tags/Math/"},{"name":"SignalProcessing","slug":"SignalProcessing","permalink":"https://blog.difan.tech/tags/SignalProcessing/"}]},{"title":"无线网络物理层","slug":"Wireless Physical Layer","date":"2020-12-19T16:00:00.000Z","updated":"2020-12-28T05:36:29.098Z","comments":true,"path":"2020/12/20/Wireless Physical Layer/","link":"","permalink":"https://blog.difan.tech/2020/12/20/Wireless%20Physical%20Layer/","excerpt":"本笔记来源于书籍《MIMO OFDM Wireless Communications with MATLAB》 无线信道衰落：衰落：信号在时间和频率上的上下浮动","text":"本笔记来源于书籍《MIMO OFDM Wireless Communications with MATLAB》 无线信道衰落：衰落：信号在时间和频率上的上下浮动 产生原因： 多径（接收端的经多条路径收到发射端发射的信号） 噪声 障碍物（阴影衰落） 分类 大尺度衰落 SISO 模型MIMO模型","categories":[{"name":"Communications","slug":"Communications","permalink":"https://blog.difan.tech/categories/Communications/"}],"tags":[{"name":"Wireless Communications","slug":"Wireless-Communications","permalink":"https://blog.difan.tech/tags/Wireless-Communications/"}]},{"title":"TMUX","slug":"TMUX","date":"2020-10-08T16:00:00.000Z","updated":"2021-04-13T09:20:38.867Z","comments":true,"path":"2020/10/09/TMUX/","link":"","permalink":"https://blog.difan.tech/2020/10/09/TMUX/","excerpt":"常用 tmux new -s window_name ctrl + b + d : detach 当前的window tmux a -t window_name ctrl + b + w : 看一下window， panne 使用场景 维护管理终端正在运行的程序 执行多个任务 远程使用时尤其方便，断开连接也不会挂掉正在跑的东西","text":"常用 tmux new -s window_name ctrl + b + d : detach 当前的window tmux a -t window_name ctrl + b + w : 看一下window， panne 使用场景 维护管理终端正在运行的程序 执行多个任务 远程使用时尤其方便，断开连接也不会挂掉正在跑的东西 结构 Sessions 包含多个windows，表示一个工作区 Windows 相当于浏览器的tabs Panes 一个window分割成几个视觉上分开的Panes 快捷键 session tmux 开启新session tmux new -s NAME tmux ls 列出现存的session d 分离当前的session tmux a 继续上一个session tmux a -t 0 指定session 0 window c 创建window + number 去 第几 window p 上一个window n 下一个window w 列出现有的windows pane “ （我这里是 | ）水平方向分割 % （我这里是 - ）竖直方向分割 z 全屏，然后再按一次恢复 ← →来改变pane大小","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"tmux","slug":"tmux","permalink":"https://blog.difan.tech/tags/tmux/"}]},{"title":"Vim 随手记","slug":"Vim 随手记","date":"2020-05-03T16:00:00.000Z","updated":"2020-05-08T16:00:00.000Z","comments":true,"path":"2020/05/04/Vim 随手记/","link":"","permalink":"https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/","excerpt":"基本操作","text":"基本操作 i : insert 光标字符之前 a : append 光标字符之后加入 o : open a line below 当前行下面开一行 A : 在本行最后append O : 本行上面插入一行，开头插入 I : 在本行开头插入 模式 normal 使用 gi 快速恢复到原始插入位置 w 下个单词开头，e下个单词结尾 b 上个单词开头 大写跳动到以空白符为间隔的地方 f+字符，搜索字符, ; 下一个 ,上一个 F+ 字符反过来搜 0 行首，$ 行尾 g 移动到开头，G移动到结尾 H/M/L跳转到屏幕的开头，结尾 ctrl u ctrl d翻页 cltr F/B dw 删除一个单词 delete a world x删除字符 r replalce一个字符 s 删除当前字符进入插入模式 R 不断地替换 S 整行删除，进入插入模式 c(change) aw 删掉一个词进入插入 C 删除整行进入插入模式 ct” 删除整个“”中的内容 ? / 进行反向前向搜索，n/N下一个上一个 # * 当前单词向上搜索/向下搜索 insert ctrl + w 删除word ctrl + u 删除行 ctrl + h 删除上一个字符 用ctrl + [ 代替esc command :vs(vertical split) 竖分屏（左右） :sp(split) 上下分屏 set nu 行号 % s/word1/word2/g 全局替换 1,6 s/word1/word2/g 1-6行之间替换 1,6 self//n 统计1-6行几个匹配self n指number，报告匹配到的次数 % s/&lt;quack&gt;/word2/g visual normal 模式 v V选行 ctrl v选方块","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://blog.difan.tech/tags/vim/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/tags/Linux/"},{"name":"随手记","slug":"随手记","permalink":"https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"如何在CentOS 7上使用FirewallD设置防火墙","slug":"如何在CentOS 7上使用FirewallD设置防火墙","date":"2020-01-10T11:40:44.000Z","updated":"2020-05-04T08:33:06.038Z","comments":true,"path":"2020/01/10/如何在CentOS 7上使用FirewallD设置防火墙/","link":"","permalink":"https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"本文翻译自 How To Set Up a Firewall Using FirewallD on CentOS 7","text":"本文翻译自 How To Set Up a Firewall Using FirewallD on CentOS 7 引言Firewalld是可用于许多Linux发行版的防火墙管理解决方案，它充当Linux内核提供的iptables数据包过滤系统的前端。 在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用firewall-cmd管理工具管理防火墙的基本知识（如果您希望在CentOS中使用iptables，请遵循 这个指南。 Firewalld 的基本概念在开始讨论如何实际使用firewall-cmd实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。 Zones(区域)Firewalld守护程序使用称为“区域”的实体管理规则组。 区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。 为网络接口分配一个Zone来指示防火墙应允许和拒绝哪些行为。 对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。 在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。 对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改。 无论您的网络环境动态性有多强，熟悉防火墙的每个预定义区域背后的概念仍然很有用。 按从最不信任到最受信任的顺序，firewalld中的预定义区域为： drop：最低级别的信任度。 所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。 block：与上述类似，但不仅仅是丢弃连接，而是使用icmp-host-prohibited或icmp6-adm-prohibited消息拒绝传入的请求。 public：代表公共的，不受信任的网络。 您不信任其他计算机，但可能会视情况允许选择的传入连接。 external：external network用于这种情形：您将firewalld当成网关使用。 将其配置为伪NAT，以便您的内部网络保持私有但可访问。 internal：外部区域的另一侧，用于网关的内部。 这些计算机相当值得信赖，并且可以使用一些其他服务。 dmz：用于DMZ（无法访问网络其余部分的隔离计算机）。 仅允许某些传入连接。 work：用于工作机。 信任网络中的大多数计算机。 可能还允许其他一些服务。 home：家庭环境。 通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。 trusted：信任网络中的所有计算机。 可用选项中最开放的，应谨慎使用。 要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口（network interface）分配给最合适的区域（zones）。 规则永久性在firewalld中，可以将规则指定为永久规则或立即规则。 如果添加或修改规则，则默认情况下，将修改当前运行的防火墙规则。 下次启动时，旧规则将恢复。 大多数firewall-cmd操作都可以使用--permanent标志来指示应永久防火墙规则作为目标。 这将影响在引导时重新加载的规则。 这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。 您还可以使用--permanent标志随着时间的推移建立一套完整的规则，这些规则将在发出reload命令时立即应用。 安装并启动防火墙firewalld默认安装在一些Linux发行版上，包括许多CentOS 7的映像。但是，您可能需要自己安装firewalld: 1sudo yum install firewalld 安装firewalld之后，可以启用服务并重新启动服务器。请记住，启用firewalld将导致服务在引导时启动。最好的做法是先创建防火墙规则，并在配置此行为之前对其进行测试，以避免潜在的问题。 12sudo systemctl enable firewalld sudo reboot 当服务器重新启动时，你的防火墙应该会打开，你的网络接口应该放入已配置的区域(或退回到已配置的默认区域)，与区域相关的任何规则都将应用于相关的接口。 我们可以通过键入以下内容来验证该服务正在运行： 1sudo firewall-cmd --state 这表明我们的防火墙已经启动并使用默认配置运行。 熟悉当前的防火墙规则在开始进行修改之前，我们应该熟悉守护进程提供的默认环境和规则。 默认值我们可以通过输入以下内容来查看当前选择的默认区域： 1firewall-cmd --get-active-zones 123outputpublic interfaces: eth0 eth1 在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（eth0和eth1）。 目前，它们都根据为public zone定义的规则进行管理。 我们如何知道与public zone相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置： 1sudo firewall-cmd --list-all 1234567891011121314outputpublic (default, active) target: default icmp-block-inversion: no interfaces: eth0 eth1 sources: services: ssh dhcpv6-client ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 从输出中可以看出，该区域既是默认区域又是活动区域，并且eth0和eth1接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。 但是，我们还可以看到，该区域允许与DHCP客户端（用于IP地址分配）和SSH（用于远程管理）相关的正常操作。 可替代区现在，我们对缺省和活动区域的配置有了很好的了解。我们也可以找到其他区域的信息。要获得可用区域的列表，请输入： 1firewall-cmd --get-zones 12outputblock dmz drop external home internal public trusted work 我们可以通过在—list-all命令中包含—zone=参数来查看与区域关联的特定配置 1sudo firewall-cmd --zone&#x3D;home --list-all 12345678910outputhome interfaces: sources: services: dhcpv6-client ipp-client mdns samba-client ssh ports: masquerade: no forward-ports: icmp-blocks: rich rules: 您可以使用–list-all-zones选项输出所有区域定义。 您可能希望将输出通过管道以便于查看： 1sudo firewall-cmd --list-all-zones | less 为接口选择区域除非您已经配置了您的网络接口，否则在防火墙启动时，每个接口都将放在默认区域。 改变接口的区域您可以在会话期间使用—zone=参数和—change-interface=参数在区域之间转换接口。与修改防火墙的所有命令一样，您将需要使用sudo。 例如，我们可以通过输入以下内容将eth0接口转换到home区域: 1sudo firewall-cmd --zone&#x3D;home --change-interface&#x3D;eth0 每当将接口转换到新区域时，请注意，您可能正在修改将可操作的服务。例如，在这里，我们将移动到”home”区域，其中有 SSH 可用。这意味着我们的连接不应该断开。默认情况下，某些其他区域未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。 我们可以通过再次请求活动区域来验证这是否成功： 1firewall-cmd --get-active-zones 12345outputhome interfaces: eth0public interfaces: eth1 调整默认区域如果所有接口都可以最好地由单个区域处理，那么只需选择最佳默认区域，然后将其用于配置可能更容易。 您可以使用 参数更改默认区域。这将立即将默认的接口更改回新区域：--set-default-zone= 1sudo firewall-cmd --set-default-zone&#x3D;home 12outputsuccess 为应用程序设置规则为您希望提供的服务定义防火墙的基本方法非常简单。我们将在这里了解基本思想。 向区域添加服务最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用以下选项获取可用服务的列表：--get-services 1firewall-cmd --get-services 12outputRH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server 您可以使用命令行参数为区域启用服务。该操作将针对默认区域或参数指定的任何区域。默认情况下，这将仅调整当前防火墙会话。您可以通过包含permanent标志来调整永久防火墙配置。--add-service=--zone=--permanent 例如，如果我们正在运行一个为传统HTTP流量提供服务的web服务器，我们可以通过输入以下命令来允许该会话的公共区域中的接口的流量: 1sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;http 我们可以用这个验证操作是否成功：--zone=--list-all--list-services 1sudo firewall-cmd --zone&#x3D;public --list-services 12outputdhcpv6-client http ssh 测试完所有功能后，可能需要修改永久防火墙规则，以便在重新启动后服务仍然可用。通过： 1sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;http 现在，您的“公共”区域将允许端口80上的HTTP Web通信。如果您的Web服务器配置为使用SSL / TLS，则还需要添加服务。 我们可以通过以下内容将其添加到当前session和永久规则集合中： 12sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;https 如果没有合适的服务可用呢?firewalld安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见需求。但是，可能会出现这些服务不适合您的需求的情况。 在这种情况下，你有两种选择： 为你的区域开一个端口支持你特定服务最简单的方法就是在合适的区域(zone)内开放一个端口， 这很容易指定端口或端口范围，以及需要打开的端口相关的协议。 比如，如果你的应用在5000端口中使用TCP，你可以在public区域内使用这个参数进行增加，协议可以为tcp，udp： 1sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;5000&#x2F;tcp 我们可以通过--list-ports进行确认 1sudo firewall-cmd --zone&#x3D;public --list-ports 使用横杠进行连续端口的指定也是可能的，例如，下面的例子就开放了4990到4999的UDP端口，当然同样是在Public zone中： 1sudo firewall-cmd --zone&#x3D;public ---add-port&#x3D;4990-4999&#x2F;udp 在测试后，我们想把它们增加为永久的防火墙规则，你可以输入： 123sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;5000&#x2F;tcpsudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;4990-4999&#x2F;udpsudo firewall-cmd --zone&#x3D;public --permanent --list-ports 定义一个服务为您的区域打开端口很容易，但是很难跟踪每个端口的用途。如果您曾经在您的服务器上停止过一个服务，那么您可能很难记住哪些过去被打开了的端口仍然是必需的。为了避免这种情况，可以定义一个服务。 服务只是具有相关名称和描述的端口的集合。使用服务比端口更容易管理，但是需要一些前期工作。最简单的启动方式是将现有的脚本复制到防火墙查找非标准定义的目录中。/usr/lib/firewalld/services/etc/firewalld/services 例如，我们可以复制SSH服务定义来使用我们的’example’服务定义，如下所示。文件名减去后缀将指示防火墙服务列表中的服务名称:.xml 1sudo cp &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;services&#x2F;ssh.xml &#x2F;etc&#x2F;firewalld&#x2F;services&#x2F;example.xml 首先，该文件将包含您复制的SSH定义 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt; &lt;short&gt;SSH&lt;/short&gt; &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;/description&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;22&quot;/&gt;&lt;/service&gt; 该定义的大部分实际上是元数据。 您将要在标签内更改服务的简称。 这是您的服务的易读名称。 您还应该添加描述，以便在需要审核服务时获得更多信息。 您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。 可以多次指定。 对于我们的示例服务，假设我们需要为TCP打开7777端口，为UDP打开8888端口。通过按下按钮进入插入模式，我们可以这样修改现有的定义 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt; &lt;short&gt;Example Service&lt;/short&gt; &lt;description&gt;This is just an example service. It probably shouldn&#x27;t be used on a real system.&lt;/description&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;7777&quot;/&gt; &lt;port protocol=&quot;udp&quot; port=&quot;8888&quot;/&gt;&lt;/service&gt; 重新加载防火墙以访问新服务: 1firewall-cmd --get-services 12output:RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server 我们可以看到example服务已经被成功定义。 创造属于你自己的区域（zones）尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。 例如，您可能要为Web服务器创建一个名为“ publicweb”的zone。 但是，您可能希望为您在专用网络上提供的DNS服务而去配置另一个zone。 您可能需要一个名为“ privateDNS”的zone。 添加区域时，必须将其添加到永久防火墙配置中。 然后，您可以重新加载以将配置带入正在运行的会话。 例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域： 12sudo firewall-cmd --permanent --new-zone&#x3D;publicwebsudo firewall-cmd --permanent --new-zone&#x3D;privateDNS 您可以通过键入来验证它们是否存在于您的永久配置中: 1sudo firewall-cmd --permanent --get-zones 如前所述，这些在防火墙的当前实例中还不可用,重新加载防火墙，将这些新区域引入活动配置2 12sudo firewall-cmd --reloadfirewall-cmd --get-zones 1block dmz drop external home internal privateDNS public publicweb trusted work 现在，您可以开始为您的区域分配适当的服务和端口。先调整active instance，然后在测试之后将这些更改转移到永久配置，这通常是一个好主意。例如，对于publicweb专区，您可能希望添加SSH、HTTP和HTTPS服务 1234sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;sshsudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;httpsudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;publicweb --list-all 1234567891011121314outputpublicweb target: default icmp-block-inversion: no interfaces: sources: services: ssh http https ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 同样，我们可以将DNS服务添加到我们的privateDNS zone 12sudo firewall-cmd --zone&#x3D;privateDNS --add-service&#x3D;dnssudo firewall-cmd --zone&#x3D;privateDNS --list-all 123456789privateDNS interfaces: sources: services: dns ports: masquerade: no forward-ports: icmp-blocks: rich rules: 然后，我们可以更改对应zone的网络接口以对其进行测试： 12sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1 12sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1 此时，您就有机会测试您的配置了。如果这些值对您有效，您将希望向永久配置添加相同的规则。您可以通过重新应用带有标志的规则来做到这一点:--permanent 1234sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;sshsudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;httpsudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;privateDNS --permanent --add-service&#x3D;dns 在永久地应用这些规则之后，您可以重新启动网络并重新加载防火墙服务 12sudo systemctl restart networksudo systemctl reload firewalld 确认已经成功分配了zones： 1firewall-cmd --get-active-zones 1234privateDNS interfaces: eth1publicweb interfaces: eth0 确认合适的服务已经在每个zones里面可用： 1sudo firewall-cmd --zone&#x3D;publicweb --list-services 12outputhttp https ssh 1sudo firewall-cmd --zone&#x3D;privateDNS --list-services 1dns 现在您已经成功地建立了属于您的区域！如果您想要把其中一个区域设置为其他网络接口的默认区域，记得使用参数--set-defalut-zone= 1sudo firewall-cmd --set-default-zone&#x3D;publicweb 总结您现在应该对如何在CentOS系统上日常使用的防火墙服务进行充分的了解。 Firewalld服务允许您配置依据网络环境的可维护规则和规则集。 它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。 掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。 By Justin Ellingwood","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://blog.difan.tech/tags/CentOS/"},{"name":"FirewallD","slug":"FirewallD","permalink":"https://blog.difan.tech/tags/FirewallD/"}]},{"title":"微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验","slug":"微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验","date":"2019-12-16T02:52:37.000Z","updated":"2020-05-04T08:32:54.737Z","comments":true,"path":"2019/12/16/微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验/","link":"","permalink":"https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/","excerpt":"Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge采用了 Chromium 内核，当然也兼容以前 IE 的功能。","text":"Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge采用了 Chromium 内核，当然也兼容以前 IE 的功能。 由于最新的Edge采用Chromium内核，对于平时使用Chrome作为使用工具的人来说不会有太大学习成本，基本无缝迁移。最新版本在功耗，性能，UI上都取得了比较不错的表现。 最新的Edge版采用了Chromium的内核，当然现在没有正式版，可以用Beta版 来体验。 点击Beta版进行下载 我们看到进去后提示导入chrome收藏，一键导入很方便，UI风格很漂亮，下面看一下开发者工具： 和之前Chrome的类似，不会有学习成本。新Edge浏览器因为只是测试版，因此插件很少，不过我们可以将Chrome的插件直接打包过来或者直接访问Chrome商店进行下载。 亲测可直接添加Chrome插件，使用体验没有任何区别，在正常工作环境下（插件数量相同，打开6个TAB），新Edge占用内存较低： 目前来看，优势主要有： 账户可以直接用微软账户，同步不需要翻墙 和Chrome一致的的性能，更好的UI 平滑滚动好 要注意的是，现在的Edge Beta版和自带的Edge不是覆盖的，所以可以放心试用。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"MicroSoft","slug":"MicroSoft","permalink":"https://blog.difan.tech/tags/MicroSoft/"}]},{"title":"Git 实战","slug":"git 实战","date":"2019-07-08T16:00:00.000Z","updated":"2021-01-16T09:50:17.381Z","comments":true,"path":"2019/07/09/git 实战/","link":"","permalink":"https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/","excerpt":"版本控制系统 集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作 分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧","text":"版本控制系统 集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作 分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧 初始化12$ git config --global user.name &quot;×××&quot;$ git config --global user.email &quot;×××@gmail.com&quot; 会在~ 目录生成一个.gitconfig 如果你想不是global，则不带–global即可，会在本项目目录下创建.git/config git init 初始化一个git project git diff --cached 查看缓存区里有哪些文件被修改了。git diff会显示所有已做但是没有加到缓存区的修改 add 和commit操作不赘述，commit操作后-a将所有没有加到缓存区的修改也一起提交，不过不会提交新文件 git remote add origin https://github.com/myname/myproject.git git push origin master 分支与合并分支在多人协作开发用的多，比如你负责的一个功能需要一个月完成，就可以创建一个分支，只把功能代码提交到这个分支上，最后合并到master分支上 git branch experimental 创建分支 git branch 查看分支 结果： 12* experimental master git checkout experimental 切换到其他分支 12# 将experimental分支合并到master$ git merge -m &#39;merge experimental branch&#39; experimental 如果有冲突，比如两个分支都修改了同一个文件，就会merge失败，这是在master分支修改对应文件再commit即可。 当我们完成分支，可以用git branch -d experimental 来删除（只能删除已经合并了的分支，强行删除用-D） 如果你觉得合并错了，可以回到合并前的状态 git reset --hard HEAD^ Git 日志git log git log --stat 会显示哪些文件被修改 git log --pretty=oneline 会一行显示一条信息 git log --pretty=short 显示简短信息 git log --graph -pretty=oneline 画一个漂亮的历史 git diffgit diff不仅仅能查看两个文件的差别，也可以看两个branch的区别。 git diff anotherbranch + 表示本分支比anotherbranch分支多的，- 表示本分支少的 分布式工作流程如果要经常操作远程分支，可以定义缩写 git remote add myrepo /tmp/myrepo git pull 相当于两个操作：使用git fetch抓取最新的修改信息，然后git merge 为什么不需要指定远程仓库？ 因为Git把远程地址存到了配置文件的remote.origin.url git 也可以是服务器的地址： git clone ssh://服务器/账号/仓库名称 git push ssh://服务器仓库地址 master:master Git Tag轻量级标签git tag tagname 8c2940 git tag 标签对象git tag -a stable-2 8c315325 -m &quot;stable 2&quot; 签名标签签名标签可以让提交和标签更加完整可信 git ignore.gitignore 来忽略不需要提交的文件 123*.html!foo.html #foo.html例外*.[oa] #忽略所有.o .a 重置git reset --hard HEAD^ 回到上次提交的状态 git checkout -- hello.rb 恢复一个文件 git revert HEAD 撤销最近的一次提交 建设私有仓库ssh可以导出一个裸仓库，然后用scp命令拷贝到服务器上 12git clone --bare &#x2F;home&#x2F;user&#x2F;myrepo&#x2F;.git &#x2F;tmp&#x2F;myrepo.gitscp -r &#x2F;tmp&#x2F;myrepo.git myserver.com:&#x2F;opt&#x2F;git&#x2F;myrepo.git 对于其他人来说，直接 git clone myserver:com:/opt/git/myrepo.git","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.difan.tech/tags/Git/"}]},{"title":"ubuntu 16.04 home挂载 系统重装","slug":"ubuntu 16.04 home挂载 系统重装","date":"2019-06-09T05:39:30.000Z","updated":"2021-03-29T06:12:00.882Z","comments":true,"path":"2019/06/09/ubuntu 16.04 home挂载 系统重装/","link":"","permalink":"https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/","excerpt":"Ubuntu 系统重装并挂载昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..","text":"Ubuntu 系统重装并挂载昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢….. linux分区 SWAP分区是LINUX暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为SWAP使用的分区不用指定“Mout Point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，一般来说它的大小是内存的一至两倍。另外你也可以创建和使用一个以上的交换分区，最多16个。 分区的原因为什么要自定义多个分区 在不损失数据的情况下重装系统，比如独立设置/home挂载点,重装系统的时候直接标记回/home，数据不会有任何损失。 针对不同挂载点的特性分配合适的文件系统以合理发挥性能，比如对/var使用reiserfs，对/home使用xfs，对/使用ext4。 针对不同的挂载点开启不同的挂载选项，如是否需要即时同步，是否开启日志，是否启用压缩。 大硬盘搜索范围大，效率低 磁盘配额只能对分区做设定 /home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片) （常见的挂载目录结构） / 根目录，存放系统命令和用户数据等（如果下面挂载点没有单独的分区，它们都将在根目录的分区中） /boot boot loader 的静态链接文件，存放与Linux启动相关的程序 /home 用户目录，存放普通用户的数据 /tmp 临时文件 /usr 是Linux系统存放软件的地方,如有可能应将最大空间分给它 /usr/local 自已安装程序安装在此 /var 不断变化的数据，服务器的一些服务、日志放在下面 /opt （Option可选的）附加的应用程序软件包 /bin 基本命令执行文 /dev 设备文件 /etc 主机特定的系统配置 /lib 基本共享库以及内核模块 /media 用于移动介质的挂载点 /mnt 用于临时挂载文件系统或者别的硬件设备（如光驱、软驱） /proc 系统信息的虚拟目录(2.4 和 2.6 内核)，这些信息是在内存中，由系统自己产生的 /root root 用户的目录 /sbin 基本系统命令执行文件 /sys 系统信息的虚拟目录(2.6 内核) /srv 系统提供的用于 service 的数据 /usr/X1186 X-Windows目录，存放一些X-Windows的配置文件 /usr/include 系统头文件，存储一些C语言的头文件 /usr/src Linux内核源代码，Linux系统所安装的内核源代码都保存在此 /usr/bin 对/bin目录的一些补充 /usr/sbin 对/sbin目录的一些补充 /lost+found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下 为什么会有挂载因为linux 下一切皆文件！换句说法就是linux操作系统将系统中的一切都作为文件来管理。在windows中我们常见的硬件设备（打印机、网卡、声卡…）、磁盘分区等，在linux中统统都被视作文件，对设备、分区的访问就是读写对应的文件。 linux挂载临时挂载123$ mount &#x2F;dev&#x2F;sda11 &#x2F;data ##sda3分区挂载在data目录下$ umount &#x2F;data ##卸载data目录下分区 &#x2F;dev&#x2F;sda11 &#x2F;data ##sda3分区挂载在data目录下$ umount &#x2F;data ##卸载data目录下分区 永久挂载：开机自动挂载需要修改/etc/fstab ) )​ Device By default, Ubuntu now uses UUID to identify partitions. 默认，Ubuntu用uuid识别分区 To list your devices by UUID use blkid 1sudo blkid 使用命令 fdisk -l 可以列出系统中当前连接的硬盘,设备和分区信息.新硬盘没有分区信息,则只显示硬盘大小信息. ) 可以先mkdir一个目录，比如new_dir，然后挂载分区： 1mount &#x2F;dev&#x2F;sda11 &#x2F;mnt&#x2F;new_dir 将所有东西全部cp到new_dir中 move原有的home 123cp &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;mv &#x2F;home &#x2F;old_home &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;mv &#x2F;home &#x2F;old_home 再mkdir一个新的home,将sda11再mount到home上 1mount &#x2F;dev&#x2F;sda11 &#x2F;home df -h查看硬盘大小和挂载情况 ) 最后根据要求，修改/etc/fstab 文件，注意格式要和其他保持一致，查看UUID可以用前文中说的方法。最后 1mount -a-a 这样就设置了fstab中的参数，设置完之后一定要看看生不生效，再继续操作","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.difan.tech/tags/ubuntu/"},{"name":"挂载","slug":"挂载","permalink":"https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.difan.tech/categories/%E7%AC%94%E8%AE%B0/"},{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/categories/EE/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/categories/C-C/"},{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/categories/Network/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/categories/MATLAB/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Communications","slug":"Communications","permalink":"https://blog.difan.tech/categories/Communications/"},{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/tags/EE/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.difan.tech/tags/Unix/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"},{"name":"网络编程","slug":"网络编程","permalink":"https://blog.difan.tech/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"http","slug":"http","permalink":"https://blog.difan.tech/tags/http/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/tags/MATLAB/"},{"name":"DSP","slug":"DSP","permalink":"https://blog.difan.tech/tags/DSP/"},{"name":"Math","slug":"Math","permalink":"https://blog.difan.tech/tags/Math/"},{"name":"SignalProcessing","slug":"SignalProcessing","permalink":"https://blog.difan.tech/tags/SignalProcessing/"},{"name":"Wireless Communications","slug":"Wireless-Communications","permalink":"https://blog.difan.tech/tags/Wireless-Communications/"},{"name":"tmux","slug":"tmux","permalink":"https://blog.difan.tech/tags/tmux/"},{"name":"vim","slug":"vim","permalink":"https://blog.difan.tech/tags/vim/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/tags/Linux/"},{"name":"随手记","slug":"随手记","permalink":"https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.difan.tech/tags/CentOS/"},{"name":"FirewallD","slug":"FirewallD","permalink":"https://blog.difan.tech/tags/FirewallD/"},{"name":"MicroSoft","slug":"MicroSoft","permalink":"https://blog.difan.tech/tags/MicroSoft/"},{"name":"Git","slug":"Git","permalink":"https://blog.difan.tech/tags/Git/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.difan.tech/tags/ubuntu/"},{"name":"挂载","slug":"挂载","permalink":"https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"}]}