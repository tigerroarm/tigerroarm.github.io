{"meta":{"title":"木慕的博客","subtitle":"Stay naive, stay simple.","description":"木慕的博客","author":"木慕的博客","url":"https://blog.difan.tech","root":"/"},"pages":[{"title":"关于我","date":"2022-04-15T17:32:22.512Z","updated":"2022-04-15T17:32:10.771Z","comments":true,"path":"about/index.html","permalink":"https://blog.difan.tech/about/index.html","excerpt":"","text":"我是谁？ 我是木慕 Huster &amp; Developer 技术栈 ：C/C++ 教育背景： 华中科技大学 硕士 2020-2013 电信学院 武汉国家光电研究中心 研究方向：信息论、分布式计算编码 华中科技大学 本科 2016-2020 电信学院 提高班 课余爱好 口琴 巴洛克音乐，喜欢巴赫"},{"title":"标签","date":"2020-01-21T16:29:30.000Z","updated":"2020-01-21T17:48:29.174Z","comments":false,"path":"tags/index.html","permalink":"https://blog.difan.tech/tags/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2021-01-23T10:50:22.000Z","updated":"2021-01-23T10:50:22.670Z","comments":true,"path":"guestbook/index.html","permalink":"https://blog.difan.tech/guestbook/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-11-04T14:03:30.295Z","updated":"2020-01-21T15:33:54.268Z","comments":true,"path":"/404.html","permalink":"https://blog.difan.tech/404.html","excerpt":"","text":"404Page not found! :("},{"title":"分类","date":"2020-01-21T15:28:38.000Z","updated":"2020-01-21T17:48:08.376Z","comments":false,"path":"categories/index.html","permalink":"https://blog.difan.tech/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"现代C++","slug":"现代C++","date":"2022-06-19T16:00:00.000Z","updated":"2022-07-07T15:29:29.280Z","comments":true,"path":"2022/06/20/现代C++/","link":"","permalink":"https://blog.difan.tech/2022/06/20/%E7%8E%B0%E4%BB%A3C++/","excerpt":"1. 语言特性1.1 常量nullptr代替NULL传统C++会把NULL，0视为同一个东西，有些定义((void*)0)，有些会定义为0，但是有问题： C++不允许void * 隐式类型转换，void* 0 0会给C++重载特性带来混乱 constexpr明确声明函数或者对象在编译期会成为常量表达式， C++14开始，constexpr函数可以使用局部变量、循环、分支等简单语句。 123456constexpr int fibonacci(const int n) &#123;//c++11 编译不了 if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2);&#125;","text":"1. 语言特性1.1 常量nullptr代替NULL传统C++会把NULL，0视为同一个东西，有些定义((void*)0)，有些会定义为0，但是有问题： C++不允许void * 隐式类型转换，void* 0 0会给C++重载特性带来混乱 constexpr明确声明函数或者对象在编译期会成为常量表达式， C++14开始，constexpr函数可以使用局部变量、循环、分支等简单语句。 123456constexpr int fibonacci(const int n) &#123;//c++11 编译不了 if(n == 1) return 1; if(n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2);&#125; 字面量：C++14带来很多新的字面量: 1234567891011using namespace std::literals::complex_literals;std::cout &lt;&lt; &quot;i * i = &quot; &lt;&lt; 1i * 1i &lt;&lt; std::endl;using namespace std::literals::chrono_literals;this_thread::sleep_for(500ms);using namespace std::literals::string_literals;std::cout &lt;&lt; &quot;hello world&quot;s.substr(0, 5);#include &lt;bitset&gt;cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl; 1.2 变量及其初始化C++17 可以将变量放在语句内(C++17)： 1234if (const std::vector&lt;int&gt;::iterator itr = std::find(vec.begin(), vec.end(), 3);itr != vec.end()) &#123; *itr = 4;&#125; 初始化列表(C++11) 1234567// std::initializer_liststd::vector&lt;int&gt; vec;MagicFoo(std::initializer_list&lt;int&gt; list) &#123; for (std::initializer_list&lt;int&gt;::iterator it = list.begin(); it != list.end(); it++) &#123; vec.push_back(*it); &#125;&#125; 几乎可以在所有初始化对象的地方使用大括号而不是小括号。当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造: 1234Obj getObj()&#123; return &#123;1.0&#125;;&#125; 和Obj(1.0)唯一区别在于{1.0}拒绝窄转换，只允许调用Obj(double). 结构化绑定（C++17） 12//f() return std::&lt;int, double, std::string&gt;auto [x, y, z] = f(); 类数据成员的默认初始化（C11）： 123456789101112class Complex &#123;public: Complex() &#123;&#125; Complex(float re) : re_(re) &#123;&#125; Complex(float re, float im) : re_(re) , im_(im) &#123;&#125;private: float re_&#123;0&#125;; float im_&#123;0&#125;;&#125;; 内联变量（C++17）C++17 引入了内联（inline）变量的概念，允许在头文件中定义内联变量，然后像内联函数一样，只要所有的定义都相同，那变量的定义出现多次也没有关系。对于类的静态数据成员，const 缺省是不内联的，而 constexpr 缺省就是内联的。 1struct magic &#123; static inline const int number = 42;&#125;; 1.3 类型推导auto - 自动类型推断 - C++ 20开始可以函数传参 - C++14开始可以用于返回值（包括decltype） auto实际使用规则类似于函数模板参数推导 - auto a = expr 意味着用expr去匹配一个假想的 template &lt;typename T&gt; f(T) 函数模板，结果为值类型 - const auto&amp; a = expr 意味着expr去匹配一个 template &lt;typename T&gt; f(const T&amp;) 结果为常左值引用类型 - auto&amp;&amp; a = expr; 意味着 template &lt;typename T&gt; f(T&amp;&amp;) 函数模板 即根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。 decltype decltype(变量名) 可以获得变量名的精确类型 decltype(表达式) -&gt; 获得表达式的引用 如果是个纯右值（prvalue），结果仍然是值类型 尾返回类型（C++11） 1234template&lt;typename T, typename U&gt;auto add2(T x, U y) -&gt; decltype(x + y) &#123; return x + y;&#125; 返回值推导（C++14）： 1234template&lt;typename T, typename U&gt;auto add3(T x, U y) &#123; return x + y;&#125; decltype(auto) (C++14)写auto时要确定引用还是值类型，decltype(auto)可以根据表达式通用地决定返回的是值类型还是引用类型。 123decltype(auto) look_up_string() &#123; return lookup1();&#125; 类模板实参推导 (CTAD)(C++17 起) 12std::pair pr&#123;1, 42&#125;;std::array a&#123;1,2,3&#125;; 1.4 控制流if constexpr （C++17）允许代码中声明常量表达式的判断： 123456789#include &lt;iostream&gt;template&lt;typename T&gt;auto print_type_info(const T&amp; t) &#123; if constexpr (std::is_integral&lt;T&gt;::value) &#123; return t + 1; &#125; else &#123; return t + 0.001; &#125;&#125; 区间for（C++11） 123for (auto element : vec) &#123;&#125; 1.5 模板模板的哲学在于将问题丢到编译期去处理，大幅度优化运行时的性能，C++的黑魔法之一。 外部模板为了解决重复实例化的问题，C++11 引入外部模板： 12template class std::vector&lt;bool&gt;; // 强制实例化extern template class std::vector&lt;double&gt;; // 不在当前文件中实例化 using 语法用作类型别名(C++11) 123456789101112typedef int (*process)(void *);using NewProcess = int(*)(void *);template&lt;typename T&gt;using TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;// 不合法// template&lt;typename T&gt;// typedef MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;int main() &#123; TrueDarkMagic&lt;bool&gt; you;&#125; 变长参数模板(C++11)参数是可变的，但是如何解包（把类型拿下来）有以下处理： 递归模板函数(C++11)，缺点在需要定义一个终止递归的函数 变参模板展开(C++17) 初始化列表展开 1234567891011//递归模板函数template&lt;typename T0&gt;void printf1(T0 value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;template &lt;typename T, typename... Ts&gt;void printf1(T value, Ts... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; printf1(args...);&#125; 变参模板展开(C++17)，在一个函数中完成printf的编写 12345template&lt;typename T0, typename... T&gt;void printf2(T0 t0, T... t) &#123; std::cout &lt;&lt; t0 &lt;&lt; std::endl; if constexpr (sizeof...(t) &gt; 0) printf2(t...);&#125; 初始化列表展开 1234567template&lt;typename T, typename... Ts&gt;auto printf3(T value, Ts... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; (void) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123; std::cout &lt;&lt; args &lt;&lt; std::endl; &#125;(), value)...&#125;;&#125; 1.6 面向对象委托构造（C++11）构造函数可以调用另一个构造函数 12345678910111213141516171819#include &lt;iostream&gt;class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; value2 = value; &#125;&#125;;int main()&#123; Base b(2); std::cout &lt;&lt; b.value1 &lt;&lt; std::endl; std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;&#125; 继承构造（C++11）使用using 引入继承构造的概念 12345#include &lt;iostream&gt;class Subclass : public Base &#123;public: using Base::Base; // 继承构造&#125;; 显式虚函数重载（C++11 override 通知编译器进行重载 final 函数 final 表示 类 final 表示拒绝重载 default delete 枚举类 123enum class new_enum : unsigned int &#123; value1, value2, value3 = 100, value4 = 100&#125;; 2. 运行时强化2.1 Lambda 表达式捕获方式： 值捕获 [value] 引用捕获 [&amp;value] 隐式捕获 [&amp;] [=] 表达式捕获 C++ 14 右值传递 Lambda 泛型 auto 用在参数表中 2.2 函数包装器 各种可调用对象 方便的函数容器 123std::function&lt;int(int)&gt; func2 = [&amp;](int value)-&gt;int &#123; return 1 + value;&#125;; 2.3 移动和右值2.3.1 值类别值类别和值类型的差别： 值类别 value category：左右值 值类型/引用类型 value type：C++中，只有引用和指针是引用类型，Java中原生类型是值类型，类属于引用类型，Python中都是引用类型 lvalue： 有标识符，可取地址的表达式，函数变量名，返回左值引用的表达式，字符串字面量 rvalue ：包括prvalue 纯右值和xvalue将亡值 prvalue: 纯右值，传统右值：没有标识符，不可以取地址的表达式，例如++x，除了字符串字面量之外的字面量，prvalue如果绑定到一个引用上，可以延长生命周期 xvalue：将亡值，可以看成有名字的右值（有标识符） glvalue ：现在的左值范围，lvalue和xvalue 2.3.2 移动std::move : 无条件地将实参强制类型转换为右值，产生一个xvalue 原理： static_cast 到type &amp;&amp; 12345678910/*** @brief Convert a value to an rvalue.* @param __t A thing of arbitrary type.* @return The parameter cast to an rvalue-reference to allow moving it.*/template&lt;typename _Tp&gt;constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) noexcept&#123; return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); &#125; 移动的意义：string res = string(&quot;hello&quot;) + name + &quot;.&quot;;在C++之前是完全不推荐的，但是有了移动之后过程： 调用 string(const *),生成Hello临时对象，复制一次 调用 operator+(string&amp;&amp;, const string&amp;) 直接在1临时对象上操作，name复制一次 调用 operator+(string&amp;&amp;, const string&amp;) 在后面追加操作 临时对象2析构 临时对象1析构 对于实际内存布局而言， 例如A类中有B，C类，在Java或者Python这样的语言中存储的实际是指针（类似）。保证了内存访问的局部性，这在现代处理器架构中是有性能优势的。缺点是复制对象的开销大大增加，故有移动语义这样的东西存在。 2.3.3 完美转发std::forward 万能引用： 1234temmplate &lt;typename T&gt;void f(T&amp;&amp; arg) &#123;&#125;// T&amp;&amp;称为万能引用// auto&amp;&amp;也是万能引用 如果是左值引用，则重载到&amp;&amp;，引用折叠，还是左值。如果是右值引用，重载到&amp;&amp;，引用折叠，是右值。这里的重载是为了检查右值 1234567891011121314151617181920212223242526/*** @brief Forward an lvalue.* @return The parameter cast to the specified type.** This function is used to implement &quot;perfect forwarding&quot;.*/template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept &#123; return static_cast&lt;_Tp&amp;&amp;&gt;(__t); &#125;/*** @brief Forward an rvalue.* @return The parameter cast to the specified type.** This function is used to implement &quot;perfect forwarding&quot;.*/template&lt;typename _Tp&gt;constexpr _Tp&amp;&amp;forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept&#123; static_assert(!std::is_lvalue_reference&lt;_Tp&gt;::value, &quot;template argument&quot; &quot; substituting _Tp is an lvalue reference type&quot;); return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#125; 引用坍缩和完美转发 引用坍缩主要是由于模板的推导结果可能是引用。即，对于 1template &lt;typename T&gt; foo(T&amp;&amp;); 如果传递左值，则T推导为左值引用，如果传递是右值，则T推导为类型本身。T&amp;&amp;保持值类别进转发，即做到了完美转发。 3. 智能指针实现一个智能指针: unique_ptr 需要考虑赋值运算符函数的问题 实现*, -&gt; 等运算符函数即可 在C++11之前auto_ptr实现有问题 当一不小心传递给另外一个ptr，你就不再拥有这个对象了 1234567891011121314// auto_ptr //smart_ptr&amp; operator=(smart_ptr&amp; rhs) &#123;// smart_ptr(rhs).swap(*this);// return *this;//&#125;smart_ptr&amp; operator=(smart_ptr rhs) &#123; rhs.swap(*this); return *this;&#125;void swap(smart_ptr&amp; rhs) &#123; using std::swap; swap(m_ptr, rhs.m_ptr);&#125; shared_ptr实现（不考虑多线程） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class my_shared_ptr &#123; public: template &lt;typename U&gt; friend class my_shared_ptr; // default constructor explicit my_shared_ptr(T* ptr = nullptr) : m_ptr(ptr) &#123; if (ptr) &#123; m_shared_count = new shared_count(); &#125; &#125; // copy constructor func my_shared_ptr(const my_shared_ptr&amp; other) &#123; m_ptr = other.m_ptr; if (m_ptr) &#123; other.m_shared_count-&gt;add_count(); m_shared_count = other.m_shared_count; &#125; &#125; // copy constructor func for pointer cast template &lt;typename U&gt; my_shared_ptr(const my_shared_ptr&lt;U&gt;&amp; other) noexcept &#123; m_ptr = other.m_ptr; if (m_ptr) &#123; other.m_shared_count-&gt;add_count(); m_shared_count = other.m_shared_count; &#125; &#125; // dynamic cast copy constructor template &lt;typename U&gt; my_shared_ptr(const my_shared_ptr&lt;U&gt;&amp; other, T* ptr) &#123; m_ptr = ptr; if (m_ptr) &#123; // if m_ptr is empty, do not add the count other.m_shared_count-&gt;add_count(); m_shared_count = other.m_shared_count; &#125; &#125; // move constructor func template &lt;typename U&gt; my_shared_ptr(my_shared_ptr&lt;U&gt;&amp;&amp; other) noexcept &#123; m_ptr = other.m_ptr; if (m_ptr) &#123; m_shared_count = other.m_shared_count; // move from other other.m_ptr = nullptr; &#125; &#125; // operator = my_shared_ptr&amp; operator=(my_shared_ptr rhs) noexcept &#123; rhs.swap(*this); return *this; &#125; // deconstructor func ~my_shared_ptr() &#123; if (m_ptr &amp;&amp; !m_shared_count-&gt;reduce_count()) &#123; delete m_ptr; delete m_shared_count; &#125; &#125; public: long use_count() const &#123; if (m_ptr) &#123; return m_shared_count-&gt;get_count(); &#125; else &#123; return 0; &#125; &#125; T* get() const noexcept &#123; return m_ptr; &#125; T&amp; operator*() const noexcept &#123; return *m_ptr; &#125; T* operator-&gt;() const noexcept &#123; return m_ptr; &#125; operator bool() const noexcept &#123; return m_ptr; &#125; private: // swap function to swap two shared_pointers void swap(my_shared_ptr&amp; rhs) &#123; using std::swap; swap(m_ptr, rhs.m_ptr); swap(m_shared_count, rhs.m_shared_count); &#125; private: T* m_ptr; shared_count* m_shared_count;&#125; 4. STLArray优点： C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置 C 数组没有良好的复制行为，无法作为键类型","categories":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/tags/C/"}]},{"title":"存储读书笔记 01","slug":"大话存储1","date":"2022-04-09T16:00:00.000Z","updated":"2022-04-30T12:55:20.829Z","comments":true,"path":"2022/04/10/大话存储1/","link":"","permalink":"https://blog.difan.tech/2022/04/10/%E5%A4%A7%E8%AF%9D%E5%AD%98%E5%82%A81/","excerpt":"1. 历史 穿孔卡 穿孔纸带 磁带 硬盘存储器 IBM Model 250 Disk File 1956年 50张 24 inch盘片 软盘 IBM 在1971年引入 光盘 Flash芯片 磁盘阵列 网格化磁盘阵列 2. IO总线 高速总线 ： 北桥 PCIE 低速总线 ： 南桥","text":"1. 历史 穿孔卡 穿孔纸带 磁带 硬盘存储器 IBM Model 250 Disk File 1956年 50张 24 inch盘片 软盘 IBM 在1971年引入 光盘 Flash芯片 磁盘阵列 网格化磁盘阵列 2. IO总线 高速总线 ： 北桥 PCIE 低速总线 ： 南桥 3. 硬盘 HDD 磁盘 盘片 Platters 盘面 一个盘片有两个盘面 磁道 Track （同心圆）300-1024个磁道 柱面 Cylinder 扇区 Sector 簇（NTFS）Cluster，块（Ex4，Linux）Block，一般由2,4,8…个扇区构成 磁头 head 主轴 扫描方式： 高负载： SCAN 回旋扫描模式，从最内侧依次向外圈寻道，不在中途折返 C-SCAN 总是从内圈向外圈，到达外圈后迅速返回 C-LOOK LOOK模式：完成最两端的IO即可折返 C-LOOK是单向扫描 低负载： SSTF 跳到最近的IO去读写，会有IO饿死的问题（远的IO扫描不到） 寻址方式： CHS 柱面（10bit）+磁头（8bit）+扇区（6bit） LBA（Logical Block Addressing） 同密度片，内外磁道数量不同 三维寻址改为一维线性寻址 SSD固态硬盘分类 NAND Flash 0表示有电 NOR Flash 每个Cell引出独立的位线，然后并联到总位线上 缺点：多了很多导线，面积增大；擦除单位小，擦除效率比NAND低，不利于频繁写的场景 优点：地址线直接寻址，读取效率高，可以直接当RAM用 原理Flash芯片、EPROM、EEPROM等，原理是利用了浮动门场效应管 浮动门是（Floating Gate，FG）是一块氮氧化物，四周被二氧化硅的绝缘层包围，在字线上抬高电势的时候，电流通过，电子电荷存储在浮动门中，断开电场后仍然存储在FG中。 MLC模式的SSD，每个cell表示2bit信息 SLC 每个Cell表示1bit信息 有电子0， 无电子1 多个这样的Cell一起形成阵列，就可以同时操作多个Bit了，NAND Flash（充电的表示0）就是利用这种排列的一种Flash芯片，Page是Flash芯片IO的最小单位。 从Flash中读 从Flash中读的时候导通所有Cell的MOS，拉高位线的电平，若FG中有电子存储，那么漏电很慢（栅源电压降低），根据漏极电压大小就知道存储的是0还是1. 根据上图，当想读出一个page的时候，将其他page的字线电平升高（导通，但不至于影响浮动门的电子存储）， 然后再抬高位线电平，就可以读出page的信息了，放置于SSD的RAM Buffer中保存。 从Flash中写流程：放电（Erase）-&gt;充电（0的Cell） 在修改一个Cell中的位之前需要Erase这个Cell Erase动作： 将一大片连续的Cell一下子全部放电，每次Erase擦除一整个Block，将Cell变为1 当写入数据恰好为1，不动 为0则将电路对应的Cell字线电压提高（足以让电子穿过绝缘体），FG进行充电，充电后1变为0（有电子了） Flash缺点 Erase Before Overwrite 需要Erase整个Block，然后再写进去 写惩罚倍数：512KB Block中的4KB Page，512/4 = 128 小块随机写IO会产生大倍数写惩罚（解决：重定向写RoW，避免写时复制（CoW）） Wear Off 充放电次数增多使得二氧化硅绝缘层遭到损坏 MLC寿命较低，小于10000次 克服Flash缺点 避免一个Cell频繁写：重定向写设计 RoW 直接重定向写到一个全盘Erase后的Block/Page（Free Block）中，因为已经放电所以可以直接写（不用Copy On Write） 如果再次遇到写操作，SSD将数据重定向到Free Space，然后之前的Page标记Garbage Garbage多的Block执行Copy On Write CoW（写时复制）: 复制非Garbage 的Page到RAM Buffer，然后写入新Erase的Block 将原有Block Erase掉 定期清除Garbage TRIM指令：文件系统删除某个文件后实时通知SSD回收对应空间 延迟写 Delay Write： 相同地址的IO合并成一个 合并写： 对于HDD来说，连续的小IO合并成一个大IO，一次性写入连续地方 SSD：逻辑地址映射本身就是杂乱无章的，所以不连续的IO合并成大IO直接写到一个Free Block中即可 防止写满，SSD预留一部分备用空间用于重定向写 普通SSD大概6-7% Intel X25-E 20% 4. RAIDRedundant Array of Independent Disks 独立磁盘冗余阵列 并发IO的矛盾： 并发IO系数（并发IO的数量） IO SIZE / Stripe SIZE Stripe SIZE（条带深度）越小，越能提高同时读写的速度，但是此时会占用大量物理盘，降低并发IO的数量 随机小块IO多：条带深度加大，提高并发IO数量 连续大块IO多：适当减小条带深度，可以多磁盘同时IO IO相关的概念 读写IO 大/小IO 连续、随机IO 顺序IO，并发IO 并发IO (Burst Mode)：磁盘组同时执行多个IO命令 顺序IO：有IO队列的概念，按顺序进行IO 持续、间断IO 稳定、突发IO 实、虚IO 实IO：包含实际LBA地址的，文件偏移量等的IO 虚IO：控制性IO，如SCSI Sense Request IOPS 完成IO的时间=寻道时间+旋转延迟时间+数据传输时间，一般寻道时间要比传输时间大几个数据量级 IOPS = 并发系数/完成IO的时间 每秒IO的吞吐量 IOPS×平均IO SIZE 七种RAID模式 名词解释： Stripe 条带： 由多个磁盘组成，主要为了提高IO速度（几个磁盘同时IO） Segment 段：一个条带在一个磁盘上的单位 写惩罚：为了写入N数据，实际要写M 的数据，我们说写惩罚倍数是M/N RAID 0 优点 不同硬盘的相同偏移的块组成条带（Stripe），可以几个盘同时读 缺点 其中任何一块盘坏了就全毁了，没有校验机制 Stripe SIZE小的时候无法并发IO RAID 1 两块盘提高鲁棒性，重复数据 除了读性能可能高N倍其他跟单盘没有不同 RAID 2 写入数据计算汉明码，4块盘数据需要3块盘的校验存储 开销大，每块盘写入1b数据，只适合连续IO，大块IO；使用校验盘数量太多，已经被淘汰 每一块都是并存并取，无法并发IO RAID 3 没有以bit为单位分散数据，而是以扇区为单位，每个段N个扇区 条带长度4KB，也就是文件系统块大小 优点 效率提升，成本小，XOR校验效率更高（专用XOR电路计算），只用一块校验盘 每次IO都牵动所有磁盘并行读写 缺点 没有多IO并发，只是多磁盘并发读取，在IOSIZE/IOPS比例小的随机IO表现不佳 达到最佳性能，需要多个磁盘的主轴同步 RAID 4 增加条带深度，支持并发IO，一次只能读写一块盘，要在文件系统层做优化 为了解决IOSIZE/IOPS小的问题，例如随机小块读写 忽略了校验盘问题，每个IO都要占用校验盘，可能性能没有多少提升，面临淘汰 RAID 5 把校验盘分割开，组合于数据盘中（分布式校验盘） 把校验块打散到不同的盘中 ，这样就可以支持并发IO（同一个盘不能同时读写） 三种模式： 整条写 Full Stripe Write 重构写 Reconstruct Write 读改写 Read-Modify Write 优点： 解决了校验盘争用的问题，在底层实现了并发（盲并发），随机IO效率更高 缺点： 写性能较差：读老数据-&gt;读出校验数据-&gt;写校验数据和新数据 RAID 5E，5EE ：增加热备盘 RAID 6 RAID 6之前的任何RAID界别，最多能保障坏掉一块数据仍然可以访问，如果两块坏了那就将会丢失。 两个校验盘，放置两个等式需要的校验值 安全性增强但是写性能更差了","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://blog.difan.tech/tags/%E5%AD%98%E5%82%A8/"},{"name":"RAID","slug":"RAID","permalink":"https://blog.difan.tech/tags/RAID/"}]},{"title":"CMU-15441 关系型数据库实现-Buffer Pool","slug":"CMU-15441 关系型数据库(Buffer_Pool)","date":"2022-04-06T16:00:00.000Z","updated":"2022-04-06T17:32:15.880Z","comments":true,"path":"2022/04/07/CMU-15441 关系型数据库(Buffer_Pool)/","link":"","permalink":"https://blog.difan.tech/2022/04/07/CMU-15441%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93(Buffer_Pool)/","excerpt":"assignment 0 C++ primter目的是熟悉一下C++，这里的提交需要注意一下格式，比如statement必须在{}之间的要求等等，否则gradescope通过不了。我的第一次提交就有这样的问题，这个评测系统对于格式的要求很高。 GDB： Debugging Under Unix: gdb Tutorial GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers Give me 15 minutes &amp; I’ll change your view of GDB [VIDEO] 顺便复习了一下智能指针： 某一时刻只能有一个 unique_ptr&lt;T&gt;指向对象，不支持拷贝赋值 shared_ptr&lt;T&gt;可以拷贝赋值，内有自己的计数器","text":"assignment 0 C++ primter目的是熟悉一下C++，这里的提交需要注意一下格式，比如statement必须在{}之间的要求等等，否则gradescope通过不了。我的第一次提交就有这样的问题，这个评测系统对于格式的要求很高。 GDB： Debugging Under Unix: gdb Tutorial GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers Give me 15 minutes &amp; I’ll change your view of GDB [VIDEO] 顺便复习了一下智能指针： 某一时刻只能有一个 unique_ptr&lt;T&gt;指向对象，不支持拷贝赋值 shared_ptr&lt;T&gt;可以拷贝赋值，内有自己的计数器 本地测试结果： 12345678910[ OK ] StarterTest.ElementAccessTest (0 ms)[ RUN ] StarterTest.AdditionTest[ OK ] StarterTest.AdditionTest (0 ms)[ RUN ] StarterTest.MultiplicationTest[ OK ] StarterTest.MultiplicationTest (0 ms)[----------] 5 tests from StarterTest (0 ms total)[----------] Global test environment tear-down[==========] 5 tests from 1 test suite ran. (0 ms total)[ PASSED ] 5 tests. gradescope提交结果 Assignment 1 Buffer Poolass1主要需要实现数据库的存储管理部分，分为三部分： LRU Buffer Pool Parallel Buffer Pool 首先第一个是实现一个LRU，这里主要使用hash list（一个unordered_map 和一个list）就可以： 1234size_t cap_; // the capacitystd::list&lt;frame_id_t&gt; q_list_; // linked list of frame_idstd::unordered_map&lt;frame_id_t, std::list&lt;frame_id_t&gt;::iterator&gt; cache_map_; // cache mapstd::mutex latch; // mutex for thread safety 实现过程不复杂但是我这里看了好久，主要是任务说明刚开始没太看懂。它的意思是LRU模块是给上层缓存池用的，缓存池对于一个page进行pin，pin之后相当于DBMS要拿来用这个Page，所以这时候是不能淘汰的（即需要从LRU中删除）。当且仅当buffer unpin到pin_count=0时才丢给LRU进行管理，这时候可以淘汰。 注意写的时候要完全按照clang-format-tidy进行，否则语法检查不通过。 单元测试结果： 123456789101112➜ build git:(ghess/p2-refinement) ✗ ./test/lru_replacer_testRunning main() from gmock_main.cc[==========] Running 1 test from 1 test suite.[----------] Global test environment set-up.[----------] 1 test from LRUReplacerTest[ RUN ] LRUReplacerTest.SampleTest[ OK ] LRUReplacerTest.SampleTest (0 ms)[----------] 1 test from LRUReplacerTest (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test suite ran. (1 ms total)[ PASSED ] 1 test. 之后是缓冲池管理器的实现，BufferPoolManger从DiskManager中获取数据库页，存进内存，同样负责将脏页写回磁盘。 页表管理 在数据库原理的博客中我已经介绍了页表的管理，DBMS由于其特殊性（可知道缓存数据是否需要使用、查询临近）等原因可以自己设计缓冲池。 加锁在数据库的背景下，locks和latches概念不同：Locks： 保护索引的逻辑内容不被别的txn改 在整个txn过程中保持 需要回滚 Latches： 保护索引的内部关键数据结构不被别的线程改 在整个操作的过程中保持 不需要回滚（本身就没有事务的概念） Page： 123456789char data_[PAGE_SIZE]&#123;&#125;;/** The ID of this page. */page_id_t page_id_ = INVALID_PAGE_ID;/** The pin count of this page. */int pin_count_ = 0;/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */bool is_dirty_ = false;/** Page latch. */ReaderWriterLatch rwlatch_; PAGE_SIZE 定为4096 Bytes，即4KB，page_id_ 唯一标注了Page，当一个进程pin了页的时候pin_count_就++，然后is_dirty_标注脏页，rwlathch_是封装的读写锁。 Buffer Pool Manager： 12345678910111213Page *pages_;/** Pointer to the disk manager. */DiskManager *disk_manager_ __attribute__((__unused__));/** Pointer to the log manager. */LogManager *log_manager_ __attribute__((__unused__));/** Page table for keeping track of buffer pool pages. */std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_;/** Replacer to find unpinned pages for replacement. */Replacer *replacer_;/** List of free pages. */std::list&lt;frame_id_t&gt; free_list_;/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */std::mutex latch_; pages_是缓存池的page数组，由page id进行索引，是缓存池的核心数据 disk_manager 和log_manger 是指向磁盘管理器和日志管理器的指针 page_table_是page id和真实frame_id的映射，两者都是int32_t replacer_ 是LRUReplacer对象，主要负责unpin之后的frame的管理 free_list_是一个空闲页的list，里面是frame的id latch_是防止资源同时被多个进程读写 这里要搞明白几个概念，frame是缓存池中的缓存frame page，page_id是请求的页表编号，DBMS向缓存池请求的是page_id，磁盘中存储的也是。所以我们需要一个page_id到frame_id的映射来快速进行缓存选择，所以page_table_一定映射的是有效的页，故当淘汰页出缓存时需要将映射删除，这个我debug了好久。 下面是实现细节：FetchPgImp:本函数实现从缓存中拿page的操作，可以通过page_table_查询page_id对应的缓存frame，如果没查到就在free_list_里面找个空闲的frame_id，如果free_list_为空说明已经用完了缓存（buffer pool满了），这时候需要进行LRU，里面的replacer调用victim方法找到一个“牺牲”的frame_id，如果脏就读回disk，然后在page_table中删除（因为我们已经淘汰了这个页），并将新的page_id =&gt; frame_id映射加入page_table，最后更新frame就可以了（更新page_id，pin_count, is_dirty_）。 UnpinPageImpl本函数主要处理unpin一个页的操作，如果pin_count &gt; 0那么减一即可，之后如果==0就加入lru_replacer中。如果进程拿到的pin_count就是&lt;= 0，那么直接return false。这里注意要在pin_count = 0时从page_table_中erase掉： 1234if (pages_[frame_id].GetPinCount() == 0) &#123; page_table_.erase(page_id); replacer_-&gt;Unpin(frame_id); // give it to replacer_&#125; FlushPageImpl将page刷新到磁盘中,找到这个page然后WritePage就可以了，记得更新page信息。 FlushAllPgsImp将所有有效地页面全部写回到disk中去，这里注意要在page_table_中找，因为其保存的都是有效的页。 NewPgImp在buffer pool中创建一个新page，返回指向page的指针。这里麻烦的地方在于缓存池可能满，此时可能需要将页面写回磁盘，并删除映射和重置数据。如果不能新建page（free_list_和LRU都满了），那么return nullptr。找到一个空闲的frame_id并更新data即可。新建页完成之后别忘了让replacer_ Pin一下frame_id（frame对应的页是新建的，不应该在LRU淘汰队列中）。 DeletePgImp在buffer pool中删除某一个page。注意只能删pin_count&gt;0的，之后更新frame即可。 这里主要的思路就是通过buffer pool 和lru_replacer进行frame的管理。buffer pool的page_table_是page_id到frame_id的映射，注意这里主要管理pinned page，而unpinned page则会交给lru_replacer进行管理。 1234567891011121314➜ build git:(ghess/p2-refinement) ✗ ./test/buffer_pool_manager_instance_testRunning main() from gmock_main.cc[==========] Running 2 tests from 1 test suite.[----------] Global test environment set-up.[----------] 2 tests from BufferPoolManagerInstanceTest[ RUN ] BufferPoolManagerInstanceTest.BinaryDataTest[ OK ] BufferPoolManagerInstanceTest.BinaryDataTest (3 ms)[ RUN ] BufferPoolManagerInstanceTest.SampleTest[ OK ] BufferPoolManagerInstanceTest.SampleTest (0 ms)[----------] 2 tests from BufferPoolManagerInstanceTest (4 ms total)[----------] Global test environment tear-down[==========] 2 tests from 1 test suite ran. (4 ms total)[ PASSED ] 2 tests. Parallel Buffer Pool Manager这里的意思是如果只用一个buffer pool的话，虽然我们有互斥锁来保证线程安全，但是当交互的时候可能会产生大量争用，故我们可以设置多个buffer pool来缓解。具体思想就是根据页表编号进行分流，具体是编号page_id % buffer_pool_instance 的缓冲池负责page_id的缓存。 具体实现在ParallelBufferPoolManager，这里我的数据结构设计如下： 123456private: size_t num_instances_; // 缓冲池数量 size_t pool_size_; // 缓冲池Page大小 size_t start_index_; // 起始序号 std::mutex parallel_latch_; // 互斥锁 std::vector&lt;BufferPoolManagerInstance *&gt; buffer_pools_; // 存放缓冲池指针 初始化时new出所有的缓冲池，并由buffer_pools_进行管理。具体的page操作都只需要找到对应的缓冲池进行操作即可，这里注意NewPgImp的时候要加锁，因为涉及到start_index变量的修改问题： 1std::scoped_lock scoped_db_latch(parallel_latch_); 加完锁之后从缓冲池 12345678910111213Running main() from gmock_main.cc[==========] Running 2 tests from 1 test suite.[----------] Global test environment set-up.[----------] 2 tests from ParallelBufferPoolManagerTest[ RUN ] ParallelBufferPoolManagerTest.BinaryDataTest[ OK ] ParallelBufferPoolManagerTest.BinaryDataTest (2 ms)[ RUN ] ParallelBufferPoolManagerTest.SampleTest[ OK ] ParallelBufferPoolManagerTest.SampleTest (1 ms)[----------] 2 tests from ParallelBufferPoolManagerTest (3 ms total)[----------] Global test environment tear-down[==========] 2 tests from 1 test suite ran. (4 ms total)[ PASSED ] 2 tests. gradescope 测试：","categories":[{"name":"DB","slug":"DB","permalink":"https://blog.difan.tech/categories/DB/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/tags/C/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"C++ Coding标准和最佳实践","slug":"C++ Coding 标准和最佳实践","date":"2022-03-14T16:00:00.000Z","updated":"2022-03-30T15:29:15.518Z","comments":true,"path":"2022/03/15/C++ Coding 标准和最佳实践/","link":"","permalink":"https://blog.difan.tech/2022/03/15/C++%20Coding%20%E6%A0%87%E5%87%86%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"要点 编码风格清晰一致 合理命名，并有注释 header干净，除非绝对需要，不在header文件中添加系统头文件 class 的private成员不暴露，所有数据成员都应该是私有的，并加下划线标记 尽可能使用const 可移植性，不依赖特定大小的long或者unsigned类型 内存问题 类 遵循三/五法则 不使用全局数据 使用构造函数初始化列表 其他 nullptr而不是null 使用auto只要清晰 统一的初始化语法，使用列表初始化{} 利用STL，通常情况下没有特别理由不要自己定义已经实现了的数据结构和算法 http://web.mit.edu/6.s096/www/standards.html https://google.github.io/styleguide/cppguide.html","categories":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/tags/C/"}]},{"title":"操作系统总结","slug":"操作系统","date":"2022-01-09T16:00:00.000Z","updated":"2022-02-19T12:19:49.417Z","comments":true,"path":"2022/01/10/操作系统/","link":"","permalink":"https://blog.difan.tech/2022/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"《modern operating systems&gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。 1 进程和线程进程进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。 进程模型 多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。","text":"《modern operating systems&gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。 1 进程和线程进程进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。 进程模型 多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。 进程与程序的区别：书中类比食谱和做饭的活动，食谱就是程序（program），而做饭的过程（读食谱，拿食材，做饭）就是进程的概念 进程创建 引起创建进程的事件： 系统初始化 正在运行的进程执行了系统调用 用户请求创建进程 启动批处理作业(batch job),在大型机的批处理操作系统中 在Linux中，只有一个系统调用可以创建新进程: fork. 进程终止 正常退出 错误退出 严重错误退出 被其他进程kill 进程层次结构 一个进程只有一个父进程，但可以有0-N个子进程。 Unix是通过init进程进行初始化的 Windows在创建进程时，父进程得到子进程的句柄(handle)，但是handle可以传递，故没有进程层次结构的概念。 进程状态 运行态（正在使用CPU） 就绪态（可以运行） 阻塞态（不能运行，需要条件） 阻塞状态可能是还没有得到运行的条件，例如在进程中读文件没有可用的输入时，就blocked。当万事俱备时，就可以转入就绪态等待进程调度。从运行态到就绪态相互的过程是进程调度程序引起的，例如分时系统中时间到了就调度正在运行的程序进入就绪状态。 进程实现在具体的实现中，OS维持一张进程表：process table，每一个项成为进程控制块（process control block），包含了关于进程的重要信息：PC: program counter，栈指针，内存分配，打开文件的状态，调度信息等等。 如图所示，IO对于CPU利用率影响很大： 线程 为什么要有线程 线程实现 内存是重要资源，操作系统的存储管理主要是针对内存的管理。 直接引入内存地址带来的问题（在multiprogramming 计算机中）： 保护问题 protection 重定位问题（需要用到的地址未知） relocation 保护问题IBM 360机是通过加入保护键解决的，重定位问题如果使用加入初始地址解决，但是会比较麻烦，因为要判断每个地址需不需要更改。 地址空间： 一种存储器抽象每个进程有自己的地址空间，并且独立于其他进程。 解决重定位问题：每个CPU配置两个特殊的寄存器，base 和 limit，分别对应物理空间的初始地址和长度（单位byte）。CPU会自动把base加载到进程发出的地址上，同时做界限检查 交换技术把空闲进程存储在磁盘上，不过不够好，因为RAM和磁盘之间速度太低，swap一次时间很长，在后面的虚拟内存技术更好。 空闲内存管理 位图 空闲链表 虚拟内存问题：软件需要的内存更大 交换技术不是很好的解决方案，使用虚拟内存的方法更好（1961）： 每个程序有自己的地址空间 地址空间分成多个块，每块称为页面（page） 每一个page映射到物理地址的page中 用到的时候再装入内存 分页Paging技术：内存管理单元（MMU）把虚拟地址映射到物理内存地址。 虚拟地址空间分成以page大小的若干单元，在物理内存中对应的称为页框（page frame）。RAM和磁盘之间的交换是以页框为单位。 页号作为页表的索引，找到对应的页框号（实际物理地址）。 页表页表：每一项标记了在/不再内存中和对应的页框号（对应的物理页框号） 页框号+页内偏移 = 真实物理地址 页表项 页框号 在/不在位，不在就直接缺页中断 保护位 修改位，有时称为脏位（dirty bit） 改进 加速虚拟地址到物理地址的转换 TLB（快表） 解决巨大的虚拟地址空间的问题 多级页表 倒排页表 页面置换算法 最优页面置换算法 NRU 算法（Not Recently Used， 最近未使用） 想法：淘汰一个访问修改最少的页面 FIFO 最新进入的页面放表尾，最久进入的表头，当却也中断时淘汰表头（很少使用） second chance 算法（改进） 最老页面的R位（访问位）如果是1，那么再给它一次机会，置零后放入队尾 clock 算法 避免经常在链表里移动页面 所有页面保存在一个环形链表里，表指针指向最老的页面 R=0，淘汰页面，新页面加入此地，之后移位，R=1就置零后移位 LRU算法 最近最少使用： 缺页中断发生时，置换未使用时间最长的页面 NFU时一种近似算法，性能不是很好，老化算法更接近LRU，更有效 文件是对disk的抽象，以名称存取 文件文件命名 Case Sensitive Linux/UNIX Case Insensitive DOS Case Insensitive， Case Preserving Windows Mac 文件结构三种文件结构： a. 字节序列： UNIX，DOS，Windows采用b. 记录序列：读操作返回一个记录，写操作重写或者追加一个记录，大型机常用c. 记录树：树按照键字段进行排序，好处是可以针对特定的键进行快速查找 文件类型 普通文件 ASCII 文件 二进制文件 目录文件 字符特殊文件（Unix） 用于串行IO设备 块特殊文件（Unix） 用于磁盘类设备 文件属性 文件操作 create delete open close read write append seek get attributes set attributes rename 一个简单的复制文件的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]);// 一个4096B的缓冲区#define BUF_SIZE 4096// 输出文件的保护位#define OUTPUT_MODE 0700#define TRUE 1int main(int argc, char *argv[])&#123; int in_fd, out_fd, rd_count, wt_count; char buffer[BUF_SIZE]; if (argc != 3) exit(1); in_fd = open(argv[1], O_RDONLY); // 打开源文件 if (in_fd &lt; 0) exit(2); out_fd = creat(argv[2], OUTPUT_MODE); //创建目标文件 if (out_fd &lt; 0) exit(3); while (TRUE) &#123; rd_count = read(in_fd, buffer, BUF_SIZE); if (rd_count &lt;= 0) // 文件结束或者读时出错，则退出 break; wt_count = write(out_fd, buffer, rd_count); if (wt_count &lt;= 0) exit(4); &#125; close(in_fd); close(out_fd); if (rd_count == 0) exit(0); else exit(5);&#125;","categories":[{"name":"OS","slug":"OS","permalink":"https://blog.difan.tech/categories/OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.difan.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++基础简明总结","slug":"C++基础简明总结","date":"2021-10-19T16:00:00.000Z","updated":"2022-03-01T12:12:18.873Z","comments":true,"path":"2021/10/20/C++基础简明总结/","link":"","permalink":"https://blog.difan.tech/2021/10/20/C++%E5%9F%BA%E7%A1%80%E7%AE%80%E6%98%8E%E6%80%BB%E7%BB%93/","excerpt":"基础语法编译 预处理 Preprocessing cpp test.cpp -&gt; test.i 编译 Compilation g++ -g -S test.i 汇编 assembly as -o test.o test.s gcc -g -c test.c; 链接 linker ld -o … 表达式左值右值lvalue, rvalue","text":"基础语法编译 预处理 Preprocessing cpp test.cpp -&gt; test.i 编译 Compilation g++ -g -S test.i 汇编 assembly as -o test.o test.s gcc -g -c test.c; 链接 linker ld -o … 表达式左值右值lvalue, rvalue In C: 左值可以放在赋值语句左边，右值则不行。 左值利用的主要是对象的身份，右值则利用的是对象的值 decltype 作用左值时自动变成引用 取地址符作用于一个左值，返回一个右值（指针） 赋值运算符左侧作为左值运算对象 类型转换一般来说是占用空间小的向占用空间大的方向转换，如果相同则无符号转换。 数组转换为指针：赋值时 指针转换 转换为bool non-const 指针或引用 向const 指针或引用转换 类的类型转换 如 while (cin &gt;&gt; str) IO库中定义了istream转换规则。 显示转换： 强制类型转换 命名的强制类型转换 static_cast double db = static_cast&lt;double&gt;(j) /i; 大转小也可以（精度损失） dynamic_cast 支持运行时类型识别 const_cast 改变运算对象的底层const，去掉const，只能改变const属性，无法改动类型 异常 throw，结束程序执行，回到函数调用处，抛出一个异常,并做资源清理 try-catch 1234567891011121314class MyException : public exception &#123;public: string msg() const &#123; return &quot;my exception&quot;; &#125;&#125;try&#123; throw MyException();&#125; catch (MyException&amp; e) &#123; cout &lt;&lt; &quot;MyException\\n&quot;; cout &lt;&lt; e.msg();&#125; STLIO头文件 iostream fstream sstream 状态查看 s.bad() s.good() s.fail() 数据错误 s.bad() IO流错误 s.clear() 状态位复位 s.eof() 文件结束符 流为什么要有Stream ? Stream 是输入输出的抽象，提供了String类型和别的类型数据的相互转换Stream分类： 输入流 InputStream 输出流 OutputStream 输出流只能用 &lt;&lt; 符号接受数据，将数据转换为String并发送给Stream举例： std::cout std::ofstream ：file stream是一种type ostringstring :把String当成Stream fstream 文件的例子 12//You should include fstreamofstream myStream(&quot;File.txt&quot;); 打开文件 void open(const char *filename), ios::openmode mode); ios::app 追加到文件末尾 ios::ate 定位到文件末尾 ios::in 用于读取 ios::out 写入文件 ios::trunc 截断模式,覆盖掉原有 e.g. ofstm.open(&quot;file.dat&quot;, ios::out|ios::trunc); 关闭 void close(); ostringstream 的例子(stringstream可以读入读出)：字符串的例子 12345678910111213141516#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main(int argc, char const *argv[])&#123; ostringstream oss(&quot;Ito En Green Tea&quot;); cout &lt;&lt; oss.str() &lt;&lt; endl; oss &lt;&lt; 16.9 &lt;&lt; &quot;Oh&quot;; cout &lt;&lt; oss.str() &lt;&lt; endl; return 0;&#125; 12Ito En Green Tea16.9Oh Green Tea 输入流 std::cin ifstream fstream 的例子 1234567//You should include fstreamifstream myFileStream(&quot;file.txt&quot;);int integer;myFileStream &gt;&gt; integer;// Or:ifstream myFileStream2;myFileStream2.open(&quot;file.txt&quot;); mystream.fail()可以检测stream是否fail，例如 读文件读到结束 文件不存在 读入的类型错误 注意的问题cin 一直读到空格，换行符等，如果输入单词可能有问题 但是要用getline要注意下面的问题 12cin &gt;&gt; val;cin &gt;&gt; val2;// ok 12cin &gt;&gt; val;getline(cin, val2); // read \\n 第二次读入的就是第一次的\\n，因为cin 并不会处理后面的\\n，只将前面的 \\n 空格略去，等于说此时getline在streambuffer里读入的是第一次结尾的\\n。 string size(), 返回string::size_type empty() [] 以string::size_type为索引，注意类型是unsigned 的 字符串相关操作： str1 + str2 str1 + “字面量” os &lt;&lt; str, is &gt;&gt; s getline(cin, str)，读取一行，丢弃换行符 == 按字符序比大小，如果前面相同比长度，长者大 cctype 头文件 isupper(), toupper() 大写 islower(), tolower() 小写 isdigit(), isalpha() 数字和字幕 ispunct() 标点 isspace() 空白 顺序容器顺序容器的元素排列顺序与其值无关，而仅仅由元素添加到容器里的次序决定。 vector功能： 创建 vector&lt;int&gt; a(v2); vector&lt;int&gt; a = v2; vector&lt;int&gt; a&#123;0, 1, 2, 3, 4&#125;; vector&lt;int&gt; a = &#123;0, 1, 2, 3, 4&#125;; vector&lt;int&gt; a(n): 初始化为0 vector&lt;int&gt; a(n, val): n个以val为值的vector元素 增加 push_back(val):在最后增加 insert(index, val):在index处（或理解为index前面）增加 删除 erase(v.begin()+i)：按地址删除 pop_back(); clear()：清除所有 修改 v[i] = val:没有边界检查 v.at(i) = val 查找 v.at(i) v[i] ：没有边界检查 v.front(); v.back(); 其他 v.empty(); v.reserve(size): 预留size个地方 deque双端队列，跟vector类似，用的比较少，好处在于大量插入删除操作时速度快 有和vector一样的函数，还有front操作： push_front(val) pop_front() list插入删除开销少，但是不能根据index进行快速定位有front操作： push_front(val) pop_front() 使用技巧 可以先reserve一定大小 1234vec.reserve(1000000);for (size_t i = 0; i &lt; 1000000; ++i) &#123; vec.push_back(i);&#125; 关联容器setmultisetmapmultimap基于hash table的容器unordered_mapunordered_setiterator迭代器 begin(), end() 返回首尾迭代器，是否为const由元素决定 cbegin(),cend()返回const_iterator 算术运算+- 泛型算法参考C++Primer第10章 智能指针&lt;memory&gt; unique_ptr : move 语意， 资源只有一个指向它 shared_ptr : copy 语意， 资源可以有多个指向它，要知道最后一个用的，没有人指向我，那就delete weak_ptr 123456unique_ptr&lt;classA&gt; r1 &#123; std::make_unique&lt;classA&gt;()&#125;;shared_ptr&lt;classA&gt; r2 &#123; std::shared_unique&lt;classA&gt;()&#125;;weak_ptr&lt;classA&gt; wr(r2);if (wr.expired()) return; //过期auto resource = wr.lock(); 常用： 12345678910unique_ptr&lt;X&gt; make_X(int i) &#123;// etc. return unique_ptr&lt;X&gt;&#123;new X&#123;i&#125;&#125;;&#125;void user(const string&amp; name, ios_base::openmode mode) &#123; shared_ptr&lt;fstream&gt; fp &#123;new fstream(name, mode)&#125;; if(!*p) // 确定文件打开 throw No_file&#123;&#125;;&#125; RAIIRAII： Resource acquisition Is Initialization资源获取即初始化 lambda 表达式 匿名函数 capture list 外部变量访问方式说明符 = 只读 &amp; 可修改 空的，不用到外面的变量 [=, &amp;x, &amp;y]，x,y 可改，其余变量不能修改 [&amp;, x, y]除了x,y以外的外部变量都可以修改 -&gt;可以省略，让编译器自己推导 12345678910111213[capture list] (parameter list) -&gt; int &#123; //...&#125;//e.g.string name = &quot;lambda function&quot;;auto square = [=, &amp;name](const int&amp; value) &#123; cout &lt;&lt; name &lt;&lt; std::endl; name = &quot;inda&quot;; return value*value;&#125;; C++14 generic lambda 类型转换显式 C style: (type) expression const_cast&lt;type&gt; (expr): 修改类型的const属性 dynamic_cast&lt;type&gt; (expr): runtime 执行转换，若失败，expr被认定为nullptr，若引用失败catch std::bad_cast static_cast&lt;type&gt;: 非动态转换，没有运行时类检查来保证转换的安全性，例如int到size_t reinterpret_cast&lt;type&gt; (expr) : 最好不用 隐式类型转换 注意类的隐式类型转换 例如有函数combine(const Sale_data &amp;sd),且有构造函数可以接受string, 则combine(string(“str”))则会默认生成一个Sale_data类 拷贝形式： Sales_data item = string(“str”); 可以使用explicit 关键字避免不期望的隐式类型转换 命名空间 定义一个范围 类本身就是一个特殊的命名空间 123456789101112131415161718namespace My_code &#123; class complex &#123; //... &#125; complex sqrt(complex); //... int main();&#125;//使用干的时候加上命名空间int My_code::main() &#123; complex z&#123;1,2&#125;; //...&#125;// 全局int main() &#123; return My_code::main():&#125; 不要在头文件里使用命名空间（using namespace …) OOPC struct: 没有封装 没有操作 类Class 数据抽象 封装 private public protected (子类) 动态绑定（运行时绑定） 函数12345678910class X &#123;public: X(Sometype); // 构造函数 X();// 默认构造函数 X(const X&amp;); // 复制构造函数 X(const X&amp;&amp;); // 移动构造函数，用std::move()调用 X&amp; operator=(const X&amp;); // 复制操作符 X&amp; operator=(X&amp;&amp;); // 移动操作符 ~X(); // 析构&#125; friend 函数 定义在类外部 有权访问累的所有private 成员和protected 成员 friend 函数并不是成员函数 相同Class的各个objects互为friends const 常量成员函数 常量对象 -&gt; 只能调用 const 函数 const &amp; constexpr 修饰对象 const主要表示这是个常量，不会变动 constexpr是修饰一个常量表达式 修饰函数 const只能用于非静态成员函数，保证函数不修改任何非静态数据 constexpr适用于常量表达式，通常是简单函数，只允许return语句，参数和返回值必须是字面量。 virtualvirtual 关键字在继承时通过晚绑定和vtable来实现多态，这样就可以用基类指针来操作各种派生类。 纯虚函数 vitual double function() = 0; 声明一个function为接口，接口类不能被实例化，但是可以有成员变量，该类是纯虚类。 类的不可改性 const 成员函数 const 成员变量 class 为final： class A final {} 不能再被继承了 其他 递归 好处： 分而治之 简洁性好 迭代 好处 效率高：编译器在同一个stack里面容易优化代码，cross-stack 优化不容易做","categories":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/tags/C/"}]},{"title":"常用数据结构与算法代码","slug":"数据结构","date":"2021-10-09T16:00:00.000Z","updated":"2022-04-06T17:33:21.834Z","comments":true,"path":"2021/10/10/数据结构/","link":"","permalink":"https://blog.difan.tech/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"模板练习数组 快排 912 排序 堆 838. 堆排序 归并 912 排序 二分 789. 数的范围 790. 数的三次方根 大整数 +-* / 前缀和 二维前缀和 剑指 Offer II 013. 二维子矩阵的和 差分 797. 差分 二维差分 位运算 剑指 Offer 15. 二进制中1的个数 离散化 区间和 双指针 3. 无重复字符的最长子串 KMP 28. 实现 strStr() 区间合并 56. 合并区间 两种写法","text":"模板练习数组 快排 912 排序 堆 838. 堆排序 归并 912 排序 二分 789. 数的范围 790. 数的三次方根 大整数 +-* / 前缀和 二维前缀和 剑指 Offer II 013. 二维子矩阵的和 差分 797. 差分 二维差分 位运算 剑指 Offer 15. 二进制中1的个数 离散化 区间和 双指针 3. 无重复字符的最长子串 KMP 28. 实现 strStr() 区间合并 56. 合并区间 两种写法 表 链表合并 21. 合并两个有序链表 (迭代，递归方法) Union-find 836. 合并集合 链表 AcWing 826. 单链表 827. 双链表 LRU 146. LRU 缓存 LFU 460. LFU 缓存 栈 队列 单调栈 LC 739. 每日温度 单调队列 154. 滑动窗口 搜索与图 DFS 1145. 二叉树着色游戏 树的重心 N 皇后 207. 课程表 BFS 图中点的层次 拓扑排序 有向图的拓扑序列 Dijkstra Dijkstra求最短路 I 堆优化 850. Dijkstra求最短路 II743. 网络延迟时间 (Bellman-ford 可不看)负权边Dijkstra 853. 有边数限制的最短路 (SPFA) 堆优化 Bellman-ford 851. spfa求最短路 最小生成树 1584. 连接所有点的最小费用 721. 账户合并 684. 冗余连接685. 冗余连接 II prim kruskal 二分图判定 DFS染色 判别 886. 可能的二分法 染色 1042. 不邻接植花 匈牙利算法 二分图的最大匹配 数学 质数判别：试除法 质因数分解 筛选质数：埃式筛法 线性筛法 204. 计数质数 因数之和，因数个数（公式法，一般法） 872约数个数 1390. 四因数 最大公约数 欧几里得 最大公约数 求欧拉函数 欧拉函数 筛法求欧拉函数 筛法 快速幂 快速幂 求逆元 扩展欧几里得 线性同余方程 数组与串912 排序 练排序261. 以图判树215. 数组中的第K个最大元素560. 和为 K 的子数组56. 合并区间28. 实现 strStr() 练KMP151. 翻转字符串里的单词剑指 Offer 45. 把数组排成最小的数 自定义排序 排序快排123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 版本1void quick_sort(vector&lt;int&gt;&amp; a, int l, int r) &#123; if (l &gt;= r) return; // 这样分 &lt;=j的元素都是小于x的值 int x = a[l], i = l-1, j = r+1; while(i &lt; j) &#123; do i++; while (a[i] &lt; x); do j--; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; quick_sort(a, l, j); quick_sort(a, j+1, r);&#125;void quick_sort(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt;= r) return; int i = l - 1, j = r + 1; int x = nums[l + r &gt;&gt; 1]; while (i &lt; j) &#123; while (nums[++i] &lt; x); while (nums[--j] &gt; x); if (i &lt; j) swap(nums[i], nums[j]); &#125; quick_sort(nums, l, j); quick_sort(nums, j + 1, r);&#125;//版本2void quick_sort(vector&lt;int&gt;&amp; a, int l, int r) &#123; if (l &gt;= r) return; int i = l, pivot = a[l], j = r; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt; pivot) j--; a[i] = a[j]; while (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++; a[j] = a[i]; &#125; a[i] = pivot; quick_sort(a, l, i-1); quick_sort(a, i+1, r);&#125;//版本3void quick_sort(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if (l &gt;= r) return; swap(nums[l], nums[l + rand() % (r - l + 1)]); int pivot = nums[l], i = l, j = r; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt;= pivot) j--; nums[i] = nums[j]; while (i &lt; j &amp;&amp; nums[i] &lt;= pivot) i++; nums[j] = nums[i]; &#125; nums[i] = pivot; quick_sort(nums, l, i - 1); quick_sort(nums, i + 1, r);&#125; topK 123456789101112int topK(int a[], int k, int l, int r) &#123; if (l &gt;&#x3D; r) return a[l]; int x &#x3D; a[ l + r &gt;&gt; 1], i &#x3D; l - 1, j &#x3D; r + 1; while (i &lt; j) &#123; do i++; while (q[i] &lt; x); do j--; while (q[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; if (j &lt; k - 1) return topK(a, k, j + 1, r); else return topK(a, k, l, j);&#125; 冒泡12345678void bubble_sort(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (nums[j] &gt; nums[j + 1]) swap(nums[j], nums[j + 1]); &#125; &#125;&#125; 归并123456789101112131415161718void merge_sort(int q[], int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid+1, r); int k = 0, i = l, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j++]; for (i = l, j = 0; i &lt;= r; i++, j++) &#123; q[i] = tmp[j]; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435// merge the two orded seqvoid merge(int a[], int left, int right, int left2, int right2) &#123; int p1 = left, p2 = left2; int index = 0; // index for new array int tmp[100] = &#123;0&#125;; while (p1 &lt;= right &amp;&amp; p2 &lt;= right2) &#123; if (a[p1] &lt;= a[p2]) &#123; tmp[index++] = a[p1++]; &#125; else &#123; tmp[index++] = a[p2++]; &#125; &#125; // store the rest array while (p1 &lt;= right) &#123; tmp[index++] = a[p1++]; &#125; while (p2 &lt;= right2) &#123; tmp[index++] = a[p2++]; &#125; for (int i = 0; i &lt; index; i++) &#123; a[left + i] = tmp[i]; &#125;&#125;//[left, right]void merge_sort(int a[], int left, int right) &#123; int mid = (left + right) / 2; if (left &lt; right) &#123; merge_sort(a, left, mid); merge_sort(a, mid + 1, right); merge(a, left, mid, mid + 1, right); &#125;&#125; 选择排序12345678910void selection_sort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[j] &lt; nums[i]) &#123; std::swap(nums[j], nums[i]); &#125; &#125; &#125;&#125; 插入排序12345678910111213141516void insertion_sort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 1; i &lt; n; i++) &#123; int val = nums[i]; int j = i - 1; // for ( ; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[i]; j--) &#123; // nums[j + 1] = nums[j]; // &#125; while (nums[j] &gt; nums[i]) &#123; nums[j + 1] = nums[j]; j--; &#125; nums[j + 1] = val; &#125;&#125; 二分300. 最长递增子序列 二分简化 123456789101112131415161718192021222324252627bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： 不满足 | 满足int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; &#125; return l; //严谨点也可以 /* return (l == r &amp;&amp; nums[l] == target) ? l : -1(or N); */&#125;// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： 满足 | 不满足int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 12345678910111213141516int binary_search(int a[], int len, int x) &#123; int start = 0; int end = len; while (start &lt;= end) &#123; int mid = (start + end) / 2; if (a[mid] == x) &#123; return mid; &#125; else if (a[mid] &lt;= x) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; return -1;&#125; 找&gt;= 1234567891011121314int binary_search_greatequ(int a[], int len, int x) &#123; int start = 0; int end = len; while (start &lt; end) &#123; int mid = (start + end) / 2; if (a[mid] &gt;= x) &#123; // if greater equal than x, modify here if &gt; end = mid; &#125; else &#123; start = mid+1; &#125; &#125; return start;&#125; 大整数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123; vector&lt;int&gt; res; r = 0; for (int i = A.size(); i &gt;= 0; i--) &#123; r = r * 10 + A[i]; res.push_back(r / b); r %= b; &#125; reverse(res.begin(), res.end()); while (res.size() &gt; 1 &amp;&amp; res.back() == 0 ) &#123; res.pop_back(); &#125; return res;&#125;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size(); i++) &#123; if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if (t) C.push_back(1); return C;&#125;vector&lt;int&gt; my_minus(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i++) &#123; t = A[i] - t; if (i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t &lt; 0) t = 1; else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) &#123; C.pop_back(); &#125; return C;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b) &#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || t; i++) &#123; if (i &lt; A.size()) &#123; C.push_back( (A[i] * b + t) % 10); t = (A[i] * b + t)/ 10; &#125; else &#123; C.push_back(t % 10); t /= 10; &#125; &#125; return C;&#125; 前缀和S[i] = a[1] + a[2] + … a[i]a[l] + … + a[r] = S[r] - S[l - 1] 1234for (int i = 1; i &lt;= n; i++) &#123; s[i] = s[i-1] + a[i]; &#125; i - j: s[j+1] - s[i + 1] 二维： S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]123456for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; pref_sum[i][j] = pref_sum[i - 1][j] + pref_sum[i][j - 1] - pref_sum[i - 1][j - 1] + matrix[i - 1][j - 1]; &#125;&#125; 区间合并123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; ans; sort(intervals.begin(), intervals.end()); int left = INT_MIN; int right = INT_MIN; for (const auto &amp; in : intervals) &#123; if (right &lt; in[0]) &#123; if (left != INT_MIN) ans.push_back(vector&lt;int&gt;(&#123;left, right&#125;)); left = in[0]; right = in[1]; &#125; else &#123; right = max(right, in[1]); &#125; &#125; if (right != INT_MIN) ans.push_back(vector&lt;int&gt;(&#123;left, right&#125;)); return ans;&#125; 双指针123456789for (int i = 0, j = 0; i &lt; n; i ++ )&#123; while (j &lt; i &amp;&amp; check(i, j)) j ++ ; // 具体问题的逻辑&#125;常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 离散化12345678910111213141516vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end()); &#x2F;&#x2F; 去掉重复元素&#x2F;&#x2F; 二分求出x对应的离散化的值int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置&#123; int l &#x3D; 0, r &#x3D; alls.size() - 1; while (l &lt; r) &#123; int mid &#x3D; l + r &gt;&gt; 1; if (alls[mid] &gt;&#x3D; x) r &#x3D; mid; else l &#x3D; mid + 1; &#125; return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n&#125; KMP28. 实现 strStr() 1234567891011121314151617181920// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ )&#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;&#125;// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ )&#123; while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) &#123; j = ne[j]; // 匹配成功后的逻辑 &#125;&#125; 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int strStr(string haystack, string needle) &#123; int n = haystack.size(), m = needle.size(); if (m == 0) &#123; return 0; &#125; vector&lt;int&gt; pi(m); for (int i = 1, j = 0; i &lt; m; i++) &#123; while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (needle[i] == needle[j]) &#123; j++; &#125; pi[i] = j; &#125; for (int i = 0, j = 0; i &lt; n; i++) &#123; while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123; j = pi[j - 1]; &#125; if (haystack[i] == needle[j]) &#123; j++; &#125; if (j == m) &#123; return i - m + 1; &#125; &#125; return -1; &#125;&#125;; next[j-1]的含义是跳了之后的下一个元素 并查集 将两个集合合并 询问是否在一个集合当中 近乎O(1)复杂度 基本原理： 每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。 树根 if(p[x])==x 求x的集合编号 while(p[x] != x) x=p[x]; 合并两个集合：px 是x的集合编号，py是y的集合编号，p[x]=y 123456789101112131415161718192021int find(int x) &#123; // 返回根节点并路径压缩 if (p[x] != x) &#123; p[x] = find(p[x]); &#125; return p[x]; &#125;int find(int x) &#123; while (parent[x] != x) &#123; parent[x] = parent[parent[x]]; x = parent[x]; &#125; return x;&#125;// combinevoid combine(int a, int b, vector&lt;int&gt; &amp;size) &#123; if (find(a) == find(b)) return; size[find(a)] += size[find(b)]; p[find(a)] = find(b);&#125; Trie 树123456789101112131415161718192021222324void insert(string str) &#123; int p = 0;// store the tail for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) &#123; // if empty son[p][u] = ++idx; p = son[p][u]; &#125; cnt[p]++; &#125;&#125;int query(string str) &#123; // query the str appearance time int p = 0; for (int i = 0; i &lt; str.size(); i++) &#123; int u = str[i] - &#x27;a&#x27;; if (!son[p][u]) &#123; return 0; &#125; p = son[p][u]; &#125; return cnt[p];&#125; 表LC reverse LL146. LRU 缓存460. LFU 缓存剑指 Offer 18. 删除链表的节点剑指 Offer 52. 两个链表的第一个公共节点链表快速排序 链表实现方式指针 123456789101112//指针struct ListNode&#123; int val; ListNode *next;&#125;;//stl, list#include &lt;list&gt;std::list&lt;int&gt; lst;lst.push_back(-1);auto it = std::find(l.begin(), l.end(), 16);lst.insert(it, 42); // insert before 42 数组 head存链表头，val存数值，next存下一个node的idx，idx表示当前用到了哪个（还没用） 1234567891011121314151617181920212223242526272829303132333435363738int head = -1, val[N], next[N], idx = 0;//链表头插入一个数avoid insert(int a) &#123; val[idx] = a, next[idx] = head, head = idx++;&#125;//删除链表头void remove_head() &#123; head = next[head];&#125;//双链表int e[N], l[N], r[N], idx;// 初始化void init()&#123; //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在节点a的右边插入一个数xvoid insert(int a, int x)&#123; e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;&#125;// 删除节点avoid remove(int a)&#123; l[r[a]] = l[a]; r[l[a]] = r[a];&#125; 例题翻转链表 12345678910111213141516171819202122ListNode* reverseList(ListNode* head) &#123; if (!head) return nullptr; ListNode *prev = nullptr, *ne = head; while (head) &#123; ne = head-&gt;next; head-&gt;next = prev; prev = head; head = ne; &#125; return prev;&#125;// recursiveListNode* reverseList(ListNode* head) &#123; if (!head || !head-&gt;next) &#123; return head; &#125; ListNode* newHead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return newHead;&#125; 1234567891011121314//双指针模板ListNode* deleteNode(ListNode* head, int val) &#123; if(head-&gt;val == val) return head-&gt;next; ListNode *pre = head, *cur = head-&gt;next; while(cur != nullptr &amp;&amp; cur-&gt;val != val) &#123; pre = cur; cur = cur-&gt;next; &#125; if(cur != nullptr) pre-&gt;next = cur-&gt;next; return head; &#125; 哈希表 存储结构 开放寻址 拉链法 常见情景：$10^9$ 映射到$10^5$ 个数 LRU &amp;&amp; LFU最近最少使用：溢出时淘汰最远的。 这里可以使用 int min_freq 存最小的理由是： 如果一个item是freq最小的，且list只有它一个元素，那么freq+1就是最小的 如果新进的元素是最新的元素，那么 min_freq = 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*用双端链表+哈希表：- 双端链表存每个key，value对- 哈希表存key, 链表元素迭代器的映射make_recently函数: 删掉key对应的list节点，并加到尾部get：- 用哈希表查node，如果在就make_recently，返回value- 如果不在return -1;put:- 用哈希表查node，如果在就make_recently，修改value- 如果不在检查是否溢出，溢出就删除front()，加入最新的*/class LRUCache &#123;private: unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache_map; // key to list node list&lt;pair&lt;int, int&gt;&gt; q_list; // key list int cap = 0;public: LRUCache(int capacity) &#123; cap = capacity; &#125; int get(int key) &#123; if (cache_map.find(key) != cache_map.end()) &#123; // if find int the map auto lp = *cache_map[key]; make_recently(lp.first); return lp.second; &#125; else &#123; return -1; &#125; &#125; void put(int key, int value) &#123; // if in the map if (cache_map.find(key) != cache_map.end()) &#123; auto lp = cache_map[key]; lp-&gt;second = value; make_recently(key); return; &#125; // if not in the map if (cache_map.size() &gt;= cap) &#123; delete_key(q_list.front().first); &#125; q_list.push_back(make_pair(key, value)); cache_map[key] = prev(q_list.end()); &#125; void make_recently(int key) &#123; int val = delete_key(key); q_list.push_back(make_pair(key, val)); cache_map[key] = prev(q_list.end()); &#125; int delete_key(int key) &#123; auto itr = cache_map[key]; int val = (*itr).second; q_list.erase(itr); cache_map.erase(key); return val; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 最不经常使用：溢出时淘汰频率最低的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class Node &#123;public: int value; int key; int freq; Node(int _key = 0, int _val = 0, int _freq = 0) &#123; value = _val; key = _key; freq = _freq; &#125;&#125;;class LFUCache &#123;private: int cap; unordered_map&lt;int, list&lt;Node&gt;::iterator&gt; key_node_map; unordered_map&lt;int, list&lt;Node&gt;&gt; freq_node_map; int min_freq;public: LFUCache(int capacity) &#123; cap = capacity; min_freq = 0; key_node_map.clear(); freq_node_map.clear(); &#125; int get(int key) &#123; // find in the key node if (key_node_map.find(key) != key_node_map.end()) &#123; auto l_itr = key_node_map[key]; int res_val = l_itr-&gt;value; int cur_freq = l_itr-&gt;freq; // update freq_node_map[cur_freq].erase(l_itr); if (freq_node_map[cur_freq].empty()) &#123; freq_node_map.erase(cur_freq); if (cur_freq == min_freq) &#123; min_freq++; &#125; &#125; freq_node_map[cur_freq + 1].push_front(Node(key, res_val, cur_freq + 1)); key_node_map[key] = freq_node_map[cur_freq + 1].begin(); return res_val; &#125; else &#123; return -1; &#125; &#125; void put(int key, int value) &#123; if (key_node_map.find(key) != key_node_map.end()) &#123; // if find the key auto l_itr = key_node_map[key]; int freq_put = l_itr-&gt;freq; freq_node_map[freq_put].erase(l_itr); if (freq_node_map[freq_put].size() == 0) &#123; freq_node_map.erase(freq_put); if (min_freq == freq_put) &#123; min_freq++; &#125; &#125; freq_node_map[freq_put + 1].push_front(Node(key, value, freq_put + 1)); key_node_map[key] = freq_node_map[freq_put + 1].begin(); return; &#125; // not find if (key_node_map.size() &gt;= cap) &#123; if (freq_node_map.find(min_freq) != freq_node_map.end()) &#123; // remove the least frequently used int min_key = freq_node_map[min_freq].back().key; freq_node_map[min_freq].pop_back(); key_node_map.erase(min_key); if (freq_node_map[min_key].size() == 0) &#123; freq_node_map.erase(min_key); &#125; &#125; else &#123; // min_freq no found cerr &lt;&lt; &quot;Min Frequency No Found.&quot;; return; &#125; &#125; //add it min_freq = 1; freq_node_map[min_freq].push_front(Node(key, value, 1)); key_node_map[key] = freq_node_map[1].begin(); &#125;&#125;;/** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */ 栈与队列LC 739. 每日温度496. 下一个更大元素 I - 力扣（LeetCode） (leetcode-cn.com)503. 下一个更大元素 II316. 去除重复字母AcWing 154. 滑动窗口2104. 子数组范围和 实现方式stack 1234567891011121314151617181920//STL#include &lt;stack&gt;stack&lt;int&gt; stk;stk.push(10);stk.top();//数组实现int stk[N], tt = -1;// pushstk[ ++ tt] = x;// poptt -- ;// topstk[tt];// emptyif (tt &gt; 0) queue 12345678910111213int q[N], hh = 0, tt = -1;// insert to tailq[ ++ tt] = x;// pophh ++ ;// frontq[hh];// emptyif (hh &lt;= tt) 单调栈本质上是可以暂存左边或者右边最近，符合要求的序列（一个递增序列），而对于离得比较远的还比最近还差的那就丢弃。例如： 1 3 2 1 6 9 4 5 3 4 13 例题： 输出左边第一个比它小的：那么在栈中存一个递增序列，从小到大，栈顶元素小于当前元素 栈： 先进1，然后进3， 2的时候比3小 3出栈，2进栈（对于后面2离得比3近并且比3小） 1：全部出栈，1进 6，9进栈 4：6，9出，4进栈 5：5进栈 3：5，4出栈 4：4进栈 13：13进栈 此时：1，4，13，栈中始终都是按序排的，栈顶是最近最不满足的。 Q 为什么要用栈？队列可以不可以 A ：栈FILO的特点能保留元素离得最近的一些值，也就是说pop出来的都是离$n[i]$ 最近的值，对于”第一个比它小的“，”第一个比它大的“这种问题非常合适。 N 数列，输出每个数字左边第一个比它小的数字，不存在则-1。 123456789101112131415161718192021//常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ )&#123; while (tt &amp;&amp; check(stk[tt], i)) tt -- ; //输出结果，栈顶就是极值 ... stk[ ++ tt] = i; // 保存i&#125;// C++ STL写法stack&lt;int&gt; sta;for (int i = 0; i &lt;= vec.size(); i++) &#123; while (!vec.empty() &amp;&amp; check(vec, sta, i)) &#123; sta.pop(); &#125; sta.push(vec[i]);&#125; 单调队列12345678910常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ )&#123; while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;&#125; 树124. 二叉树中的最大路径和112. 路径总和113. 路径总和 II129. 求根节点到叶节点数字之和543. 二叉树的直径366. 寻找二叉树的叶子节点1448. 统计二叉树中好节点的数目 树的实现方式 数组 12345vector&lt;int&gt;tree(n + 1);//0不用，2i + 1右子树，2i左子树int sz = n;if (2*i &lt;= sz &amp;&amp; check(2 * i)) ...//左子树if (2*i &lt;= sz &amp;&amp; check(2 * i)) ...//右子树 结构体 12345struct TreeNode &#123; struct TreeNode* next; int val; TreeNode(int _val = 0) : val(_val)&#123;&#125;&#125;; 二叉搜索树 BST98. 验证二叉搜索树450. 删除二叉搜索树中的节点99. 恢复二叉搜索树109. 有序链表转换二叉搜索树 红黑树实现堆是完全二叉树 插入一个数 :heap[++size] = x; up(size) 放到最后一个，然后上移 求最小值: heap[1] 删除最小值: 覆盖top， 然后down一遍 heap[1] = heap[size]; size--; down(1) 删除任意一个元素 k : heap[k] = heap[size]; size--; down(k); up(k) 修改任意一个元素: heap[k] = x; down(k), up(k); 123456789101112131415161718192021222324252627282930int h[N];int size;//如何手写一个堆？完全二叉树 5个操作//1. 插入一个数 heap[ ++ size] = x; up(size);//2. 求集合中的最小值 heap[1]//3. 删除最小值 heap[1] = heap[size]; size -- ;down(1);//4. 删除任意一个元素 heap[k] = heap[size]; size -- ;up(k); down(k);//5. 修改任意一个元素 heap[k] = x; up(k); down(k);void down(int u) &#123; int min = u; if (2 * u &lt;= size &amp;&amp; h[2 * u &lt; h[min]]) min = 2 * u; if (2 * u + 1 &lt;= size &amp;&amp; h[2 * u + 1 &lt; h[min]]) min = 2 * u + 1; if (min != u) &#123; swap(h[u], h[min]); down(min); &#125;&#125;void up(int u) &#123; // if father &gt; self, swap while (u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; // father node &gt; node u swap(h[u / 2], h[u]); u /= 2; &#125;&#125;//建堆for (int i = N / 2; i; i--) &#123; down(i);&#125; 搜索与图论全排列N 皇后130. 被围绕的区域剑指 Offer 12. 矩阵中的路径 207. 课程表210. 课程表 II 743. 网络延迟时间1514. 概率最大的路径1631. 最小体力消耗路径 DijkstraDijkstra2SPFA 有边数限制的最短路815. 公交路线 二分图：886. 可能的二分法1042. 不邻接植花 实现方式 邻接矩阵 邻接表 12345678910111213141516//matrix_g = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n)); // no weight_g = vector&lt;vector&lt;pair&lt;int, int&gt;&gt;(n, vector&lt;pair&lt;int, int&gt;&gt;(n)) // neigbor idx and weight// table_g = vector&lt;vector&lt;int&gt;&gt;;// no weight// 数组表示邻接表int head[N], val[M], next[M], idx = 0;void add (int a, int b) &#123; val[idx] = b, next[idx] = head[a], h[a] = idx++;&#125; DFS思路 12345678910111213//标记visiteddfs (node) &#123; visited[node] = true; // 标记访问 for (neighbor of node) &#123; do something; if (!visited[neighbor]) &#123; dfs(neighbor); &#125; &#125;&#125; 深度优先搜索，一直走到头，边回去边看 数据结构：stack 空间：O(h) 优点：使用空间少 顺序 全排列 123456789101112131415161718void dfs(int idx) &#123; if (idx == n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!visited[i]) &#123; path[idx] = i + 1; visited[i] = true; dfs(idx + 1); visited[i] = false; &#125; &#125; &#125; n 皇后问题 用dg，udg记录对角线 尝试在每一行放，然后递增，回溯即可。 12345678910111213141516void dfs(int idx, int n) &#123; if (idx == n) &#123; res.push_back(cur_state); return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!col[i] &amp;&amp; !dg[idx + i] &amp;&amp; !udg[n - idx + i]) &#123; cur_state[idx][i] = &#x27;Q&#x27;; col[i] = dg[idx + i] = udg[n - idx + i] = true; dfs(idx + 1, n); col[i] = dg[idx + i] = udg[n - idx + i] = false; cur_state[idx][i] = &#x27;.&#x27;; &#125; &#125;&#125; BFS广度优先搜索 数据结构：queue 空间 O(2^h) 优点：最短路的概念 123456789101112131415161718192021222324252627282930queue &lt;- initialize // 初始化queuewhile (!queue.empty()) &#123; t&lt;-front(); 拓展 t 能到的所有邻居x if (x 未被遍历) queue&lt;-x; //do sth 例如更新距离etc&#125;//即：queue&lt;int&gt; q;st[1] = true; q.push(1);while (q.size())&#123; int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; q.push(j); &#125; &#125;&#125; 拓扑序列： BFS的一种变体 思路： 找其中度为0的点存队列，遍历邻居并删除边，过程中再找度为0的点即可。 无环肯定有拓扑序列，有环肯定没有（后面的指向前面的）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768bool topsort()&#123; int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) &#123; int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; &#125; &#125; // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1;&#125;bool topsort()&#123; for (int i = 1; i &lt;= n; i++) &#123; if (!indegree[i]) q.push(i); &#125; while (!q.empty()) &#123; int tt = q.front(); res.push_back(tt); q.pop(); for (int nr : g[tt]) &#123; indegree[nr]--; if (indegree[nr] == 0) q.push(nr); &#125; &#125; return (res.size() == n);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; indegree = vector&lt;int&gt;(n + 1); g = vector&lt;list&lt;int&gt;&gt;(n + 1, list&lt;int&gt;()); for (int i = 0; i &lt; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; g[x].push_back(y); indegree[y]++; &#125; if (topsort()) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;; &#125; &#125; else &#123; cout &lt;&lt; -1; &#125; return 0;&#125; 最短路 单源 边权正数 朴素Dijkstra算法 O(n^2) 适用稠密图 堆优化Dijkstra算法 O(mlogn) 适用稀疏图 有负权边 Bellman-Ford O(nm) SPFA 一般 O(m)，最坏O(nm) 多源 Floyd O(n^3) 朴素Dijkstra算法 123451. dist[1] &#x3D; 0, dist[0] &#x3D; +infinity2. for v : 0-n: t &lt;- 不在s中的距离最近的点 n*n t加到s里面去 用t更新其他点的距离 m次 123456789101112131415dist[1] = 0;for (int i = 0; i &lt; n - 1; i++) &#123; // 选中了一个点，故只需要n-1 int t = -1; //find min dist idx for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) &#123; t = j; &#125; &#125; st[t] = true; // add t to the S set for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], dist[t] + g[t][j]); &#125;&#125; 堆优化Dijkstra算法 1234567891011121314151617181920212223242526int dijkstra()&#123; dist[1] = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; heap; heap.push(&#123;0, 1&#125;); while (heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; // update for (auto &amp; p : g[ver]) &#123; int j = p.first; if (dist[j] &gt; distance + p.second) &#123; dist[j] = distance + p.second; heap.push(&#123;dist[j], j&#125;); &#125; &#125; &#125; if (dist[n] == infinity) return -1; return dist[n];&#125; Bellman Ford 算法O(nm) 123For n次 For 所有边a, b, w dist[b] &#x3D; min(dist[b], dist[a] + w); 12345678910111213141516int bellman_ford() &#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) &#123; memcpy(bakcup, dist, sizeof dist); for (int j = 0; j &lt; m; j++) &#123; int a = edges[j].a, b= edges[j].b, w=edges[j].w; dist[b] = min(dist[b], bakcup[a] + w); &#125; &#125; if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n];&#125; SPFA算法 dist[x] 最短距离 -&gt; 判断距离 cnt[x] 边数 cnt[x] &gt;= n 存在负环 -&gt; 有负环 12345queue &lt;- 1while (queue不空) t &#x3D; queue pop 更新 t 的所有出边 &#x2F;&#x2F; 我变小了，后继的点才能更新 queue &lt;- b 123456789101112131415161718192021222324int spfa() &#123; queue&lt;int&gt; q; dist[1] = 0; q.push(1); st[1] =true; while (!q.empty()) &#123; int min_idx = q.front(); q.pop(); st[min_idx] = false; for (auto &amp;p : g[min_idx]) &#123; int j = p.first; if (dist[j] &gt; dist[min_idx] + p.second) &#123; dist[j] = dist[min_idx] + p.second; if (!st[j]) &#123; q.push(j); st[j] = true; &#125; &#125; &#125; &#125; return dist[n];&#125; Floyd算法 12345678void floyd()&#123; for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125; 最小生成树 prim 朴素版 O(n^2) 堆优化 O(mlogn) Kruskal 稀疏图 O(mlogm) prim算法 1234567891011121314151617181920212223242526272829303132/* dist[i] &lt;- inf for (int i = 0; i &lt; n; i++) &#123; t&lt;- 集合外距离最近的点 用t更新其他点到集合的距离 将t加入集合 &#125;**/ int prim() &#123; int res = 0; for (int i = 0; i &lt; n; i++) &#123; int min_idx = -1; for (int j = 1; j &lt;= n; j++) &#123; if (!st[j] &amp;&amp; (min_idx == -1 || dist[min_idx] &gt; dist[j])) &#123; min_idx = j; // 找到最近的点 &#125; &#125; if (i &amp;&amp; dist[min_idx] == inf) return inf; // 图不连通 if (i) res += dist[min_idx]; st[min_idx] = true; //更新距离 for (int j = 1; j &lt;= n; j++) &#123; dist[j] = min(dist[j], g[min_idx][j]); &#125; &#125; return res;&#125; kruskal算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*1. 将所有边按从小到大排序2. 枚举每条边x, y, w 1. 如果x, y不连通 2. 加入集合*/int n, m; // n是点数，m是边数int p[N]; // 并查集的父节点数组struct Edge // 存储边&#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125;&#125;edges[M];int find(int x) // 并查集核心操作&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int kruskal()&#123; sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) //不连通 &#123; p[a] = b; // 连通a,b res += w; cnt ++ ; // 加的边数 &#125; &#125; if (cnt &lt; n - 1) return INF; //加的边数&lt;n-1，说明不连通 return res;&#125; 二分图当且仅当图中不含奇数环（分成两个集合） 判断是否二分图 DFS染色法 O(n+m) 匈牙利算法 O(nm) 实际一般远小于 染色法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103vector&lt;vector&lt;int&gt;&gt; _g;vector&lt;int&gt; _colors;//bfsfor (int i = 0; i &lt; n; i++) &#123; if (_colors[i] == -1) &#123; if (!bfs(i)) &#123; return false; &#125; &#125;&#125;return true;bool bfs(int idx) &#123; queue&lt;int&gt; q; _colors[idx] = 0; q.push(idx); while (!q.empty()) &#123; int ii = q.front(); q.pop(); for (int nei : _g[ii]) &#123; if (_colors[nei] == -1) &#123; _colors[nei] = !_colors[ii]; q.push(nei); &#125; else &#123; if (_colors[nei] == _colors[ii]) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125;// dfs bool dfs_coloring(int idx, int col) &#123; _colors[idx] = col; for (const auto nei : _g[idx]) &#123; // traverse the neighbors if (_colors[nei] == -1) &#123; // no visited if (!dfs_coloring(nei, !col)) &#123; return false; &#125; &#125; else if (_colors[nei] == col) &#123; return false; &#125; &#125; return true;&#125;for (int i = 0; i &lt; n; i++) &#123; if (_colors[i] == -1) &#123; // dfs if (!dfs_coloring(i, 0)) &#123; return false; &#125; &#125;&#125;return true;int n; // n表示点数int h[N], e[M], ne[M], idx; // 邻接表存储图int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c)&#123; color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if (color[j] == -1) &#123; if (!dfs(j, !c)) return false; &#125; else if (color[j] == c) return false; &#125; return true;&#125;bool check()&#123; memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) &#123; flag = false; break; &#125; return flag;&#125; 匈牙利算法 1234567891011121314151617181920212223242526272829303132int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过bool find(int x)&#123; for (int i = h[x]; i != -1; i = ne[i]) &#123; int j = e[i]; if (!st[j]) &#123; st[j] = true; if (match[j] == 0 || find(match[j])) &#123; match[j] = x; return true; &#125; &#125; &#125; return false;&#125;// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ )&#123; memset(st, false, sizeof st); if (find(i)) res ++ ;&#125; 数学137. 只出现一次的数字 II1390. 四因数 因数个数204. 计数质数263. 丑数264. 丑数 II279. 完全平方数剑指 Offer 16. 数值的整数次方 位运算求n的第k位数字: n &gt;&gt; k &amp; 1 返回n的最后一位1：lowbit(n) = n &amp; -n i &amp; (i - 1)把最后一位的1变成0[剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode-cn.com/problems/w3tCBm/)质数分解质因数求质数 时间复杂度$O(\\sqrt(n))$ 12345678910111213141516void divide(int n) &#123; // i是质因数，s, 是次数, n中最多只包含一个大于sqrt(n)的质因子 for (int i = 2; i &lt;= n / i; i++) &#123; // sqrt(n) if (n % i == 0) &#123; int s = 0; while (n % i == 0) &#123; n /= i; s++; &#125; cout &lt;&lt; i &lt;&lt; s; &#125; &#125; if (n &gt; 1) cout &lt;&lt; n &lt;&lt; 1;&#125; 判定质数123456789//判定质数bool is_prime(int x) &#123; if (x &lt; 2) return false; for (int i = 2; i &lt;= x/i; i++) &#123; if (x % i == 0) return false; &#125; return true;&#125; 筛选质数筛选质数(埃氏筛法) O(nloglogn)从小到大筛掉质数的倍数 缺点是会将一个合数重复筛选，比如2已经筛掉了6，3会再筛选一遍6 12345678910void get_primes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; for (int j = i+i; j &lt;= n; j += i) &#123; st[j] = true; &#125; &#125; &#125;&#125; 线性筛法改进了埃氏筛法，n只会被最小质因子筛掉 pj * i 一定不是质数，质数从小for到大一直到i的最小质因子即可。 如果i的最小质因子比pj大，那么pj* i的最小质因子是pj 如果i的最小质因子是pj， 那么pj * i 的最小质因子还是pj 任何一个合数i都会被筛掉：一定有一个最小质因子，最小质因子乘以i, i为2-n 123456789101112void get_primes(int n) &#123; for (int i = 2; i &lt;= n; i++) &#123; if (!st[i]) &#123; primes[cnt++] = i; &#125; for (int j = 0; primes[j] &lt;= n/i; j++) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; // primes[j] 一定是i的最小质因子 &#125; &#125;&#125; 约数求约数枚举到 $\\sqrt{n}$ 12345678void get_divisors(int n) &#123; for (int i = 1; i &lt;= n/i; i++) &#123; if (n % i == 0) &#123; cout &lt;&lt; i; //约数1 if (i != n / i) cout &lt;&lt; n / i; // 约数2 两个约数不一样才放进去 &#125; &#125;&#125; 约数个数和约数之和123如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 求约数个数 https://www.acwing.com/problem/content/872/ 约数之和 https://www.acwing.com/problem/content/873/ 123456789101112131415161718192021unordered_map&lt;int, int&gt; primes; while (n--) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i++) &#123; while (x % i == 0) &#123; x /= i; primes[i]++; &#125; &#125; if (x &gt; 1) primes[x]++; &#125; long long res = 1; for (auto prime : primes) &#123; res = res * (prime.second + 1) % mod; &#125; 最大公约数欧几里得算法 $$(a,b) = (b, a \\ mod \\ b)$$ 1234int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 欧拉函数$\\phi(N)$ 1-N中和N互质的个数则 $$\\phi(N) = N \\times \\frac{p_1 - 1}{p_1}\\times \\frac{p_2 - 1}{p_2} … \\frac{p_m - 1}{p_m}$$ 1234567891011121314int phi(int x)&#123; int res = x; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) &#123; res = res / i * (i - 1); while (x % i == 0) x /= i; &#125; if (x &gt; 1) res = res / x * (x - 1); return res;&#125; 筛法求欧拉函数1234567891011121314151617181920212223void get_eulers(int n)&#123; euler[1] = 1; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) &#123; primes[cnt ++ ] = i; euler[i] = i - 1; &#125; for (int j = 0; primes[j] &lt;= n / i; j ++ ) &#123; int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) &#123; euler[t] = euler[i] * primes[j]; break; &#125; euler[t] = euler[i] * (primes[j] - 1); &#125; &#125;&#125; 欧拉定理：$a^{\\phi(n)} \\ mod \\ n =1$ a, n互质 如果p是质数，则$a^{p-1} = 1(modp)$ 费马定理 快速幂求$a^k$ ，把k拆成二进制的形式就可以 12345678910int qmi(int a, int b, int p) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (LL) res * a % p; b &gt;&gt;= 1; a = (LL)a * a % p; &#125; return res;&#125; 扩展欧几里得裴蜀定理：任意正整数a, b 一定存在整数x, y使得ax+by = (a, b)那么比如让求，ax + by = (a, b), 让你求出任意一个x, y 12345678910int exgcd(int a, int b, int &amp;x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; // b = 0, a * 1 + 0 = a return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125; 应用：求解线性同余方程ax == b (mod m) 其方程有解的充要条件是 b 是 (a, m)的倍数（反证法）,故要求的是ax + my = (a,b) * b/(a,b)求出来的x别忘了%m 123int d = exgcd(a, m, x, y);if (b % d) cout &lt;&lt; &quot;impossible&quot;;else cout &lt;&lt; x * (b / d) % m; 动态规划53. 最大子数组和322. 零钱兑换 1143. 最长公共子序列516. 最长回文子序列300. 最长递增子序列 494. 目标和72. 编辑距离583. 两个字符串的删除操作 背包问题DP: 状态表示 集合 所有选法 条件 属性 ： max, min, nums 状态计算 集合划分 0 1背包N个物品 容量是V的背包每个物品容量vi, 价值wi，目标是总价值最大。 01背包 每件物品最多一次 $max(f(i - 1, j), f(i - 1, j - v(i)))$ 完全背包 每件物品无限次 $max(f(i - 1, j), f(i, j - v) + w)$ 多重背包 si 个 状态方程 $$f(i, j) = max(放vi，不放vi) = max(f(i - 1, j), f(i - 1, j - v(i)))$$ 12345for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125;&#125; 完全背包状态方程: $$f(i, j) = max(f(i - 1, j - v(i) k) + w(i) k) = max(f(i - 1, j), f(i - 1, j - v) + w …$$ 经化简得： $$f(i, j) = max(f(i - 1, j), f(i, j - v) + w)$$ nums里面是东西，一个容量为sum的背包，把东西放背包里，多少种放法 12345678910111213141516171819202122for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k * v[i] &lt;= j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k); &#125; &#125;&#125;//优化for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; dp[i][j] = dp[i - 1][j];//不拿i if (j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); &#125;&#125;//转换成一维的for (int i = 1; i &lt;= n; i++) &#123; for (int j = v[i]; j &lt;= m; j++) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125;&#125; 多重背包问题每个有个数 s[i]限制 完全背包问题： f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k)k = 0, 1, 2, ....s[i] 1234567for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= s[i] &amp;&amp; k *v[i] &lt;= j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i] * k] + w[i] * k); &#125; &#125;&#125; 优化：f[i,j] = max(f[i-1,j], f[i-1, j-v]+w,f[i-1, j-2v]+2w,...f[i-1,j-sv]+sw)f[i,j-v] = max(f[i-1,j-v], f[i-1,j-2v]+w, ..., f[i-1,j-(s+1)v] +sw) 化归成01背包问题，将1 2 4 … logsi 打包成一个物品，选择或者不选择就可以优化成nmlogsi复杂度 1234567891011121314151617181920212223242526272829int cnt = 0;for (int i = 1; i &lt;= n; i++) &#123; int a, b, s; //体积，价值，数量 cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while (k &lt;= s) &#123; cnt++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if (s &gt; 0) &#123; cnt++; v[cnt] = a * s; w[cnt] = b * s; &#125;&#125;n = cnt;vector&lt;int&gt; dp(m + 1);for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= v[i]; j--) &#123; dp[j] = max(dp[j], dp[j - v[i]] + w[i]); &#125;&#125;cout &lt;&lt; dp[m] &lt;&lt; endl; 分组背包问题123456789for (int i = 1; i &lt;= n; i++) &#123; for (int j = m; j &gt;= 0; j--) &#123; for (int k = 0; k &lt; s[i]; k++) &#123; if (v[i][k] &lt;= j) &#123; f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); &#125; &#125; &#125;&#125; Leetcode 题目 123456789101112131415161718192021222324252627282930313233343536373839int subsets(vector&lt;int&gt;&amp; nums, int sum) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt;dp(n + 1, vector&lt;int&gt;(sum + 1)); for (int i = 0; i &lt;= n; i++) &#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= sum; j++) &#123; if (j &gt;= nums[i - 1]) &#123; dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]; &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n][sum];&#125;//优化int subsets(vector&lt;int&gt;&amp; nums, int sum) &#123; int n = nums.size(); vector&lt;int&gt;dp(sum + 1); dp[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; // 第i个物品 for (int j = sum; j &gt;=0; j--) &#123; if (j &gt;= nums[i - 1]) &#123; dp[j] = dp[j] + dp[j - nums[i - 1]]; &#125; else &#123; dp[j] = dp[j]; &#125; &#125; &#125; return dp[sum];&#125; 线性DP 最长上升子序列问题（二维DP， 一维模拟stk优化） 最长公共子序列问题 子集划分 所有在a中前i个出现的，b中前j个字母出现的子序列集合 包括不包括ai, bj 四种情况 属性：Max个数 1234dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);if (a[i - 1] == b[j - 1]) &#123; dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1); &#125; 区间DP 石子合并 集合：将i到j堆石子合并成一堆石子的合并方式 属性：Mindp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]); 语法STLvector 变长数组，倍增 size() empty() 返回是否为空 clear() queue就没有清空函数 front(), back() 返回首尾的数 pop_back(), push_back() begin()/end() []取地址 支持比较运算： 按字典序比大小 123vector&lt;int&gt; a(4,3);vector&lt;int&gt; b(3, 4);cout &lt;&lt; a &lt; b; pair&lt;int, string&gt; p p.first 第一元素 p.second 第二元素 支持比较运算，第一个值为第一元素 构造： p = make_pair(10, &quot;asdf&quot;) p = &#123;20, &quot;asdf&quot;&#125; // C++11 string size() empty() substr(start_index, length), substr(start_index) c_str() 转为字符数组的起始位置 printf(“%s”, string_a.c_str()) queue push(), 队尾插入 pop(), 对头弹出 front()/back() 返回队头队尾元素 priority_queue（堆）默认大跟堆 top(), 返回堆头元素 push(), 插入一个元素 pop() 弹出堆头元素 小跟堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; stack push(), pop(), top(); deque 加强版的vector，缺点是速度比较慢，比一般数组慢好几倍 size() empty() clear() front()/back() push_back(), push_front() pop_back(), pop_front() begin()()/end() [] list 链表 size() empty() clear() push_front(), push_back() pop_back(), pop_front() insert(it, val) set , map, multiset, multimap 平衡二叉树 size() empty() clear() begin()/end() ++ – O(logn) set/multiset multiset 可以重复 insert() 插入一个数 find() 寻找一个数 count() 返回某一个数的个数 erase() (5)输入是一个数字，删除所有x ：O(logn + k) (iterator) 删除对应的元素 lower_bound()/upper_bound() lower_bound(x) 返回&gt;=x的最小的iterator upper_bound(x) 返回&gt; x 的最小的数iterator map/multimap insert(pair&lt;A, B&gt;) erase() 输入pair或者迭代器 find() [] 可以像用数组一样去用map，时间复杂度O(logn) lower_bound(x) 返回&gt;=x的最小的iterator upper_bound(x) 返回&gt; x 的最小的数iterator unordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表 和上面类似，但是绝大部分操作的复杂度是O(1), 不支持lower_bound, upper_bound(), ++–迭代器 bitset 压位 相比于bool数组省空间 bitset&lt;1000&gt; s; ~ &amp; | ^ &lt;&lt; &gt;&gt; == != [] count() 返回多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 全设为1 set(k, val), 第k位设为1 reset() 全设为0 flip() 全~ flip(k) 小技巧去除前后空格 1234567s.erase(s.begin(), find_if(s.begin(), s.end(), [](const auto &amp; ch) &#123; return !std::isspace(ch);&#125;));s.erase(find_if(s.rbegin(), s.rend(), [](const auto &amp; ch) &#123; return !std::isspace(ch);&#125;).base(), s.end()); INT溢出问题当给一个x == INT_MIN时，我们-x就会溢出，此时给一个longlong去承载就可以 1long long nn = n;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.difan.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://blog.difan.tech/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Gossip 算法","slug":"Gossip算法","date":"2021-09-09T16:00:00.000Z","updated":"2021-09-13T12:25:31.805Z","comments":true,"path":"2021/09/10/Gossip算法/","link":"","permalink":"https://blog.difan.tech/2021/09/10/Gossip%E7%AE%97%E6%B3%95/","excerpt":"","text":"Gossip 算法在一个有界网络中，每个node传播message给随机的几个节点，经过杂乱无章的通信，最终所有节点都会达成一致。每个节点有可能知道所有的节点，也可能仅仅知道几个邻居节点，最后状态都是一致的，又称为反熵。 优点 可扩展性 使用$O(\\log N)$ rounds 到达所有nodes，N为node的个数。 容错 从源头节点到目的节点路径不止一条，可以在不规则为止连接性的网络中运行。 健壮性 故障节点不会阻止其他节点发送消息，每个节点都可以随意加入和退出，不会严重啊影响服务质量 但是如果消息有关于故障节点或者恶意节点，那么系统就不健壮 收敛速度 指数收敛速度 流程两个概念 Cycle 传播一个消息的轮数 Fanout 每轮种node通信的节点数 周期性散播消息 每轮随机选择fanout个节点散播消息 每轮散播消息都选择尚未发送过的节点进行散播 收到消息的节点不再往send节点散播 Goosip 和 raftraft是强一致性的，而gossip是最终一致 例子 Riak 使用gossip协议分享并通信ring state和bucket properties CASSANDRA 分享周围nodes和自己的信息 serf：go实现的服务发现和治理的框架","categories":[{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/tags/Network/"},{"name":"分布式","slug":"分布式","permalink":"https://blog.difan.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"POSIX thread","slug":"C 多线程","date":"2021-05-09T16:00:00.000Z","updated":"2022-02-19T12:14:55.968Z","comments":true,"path":"2021/05/10/C 多线程/","link":"","permalink":"https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"POSIX thread Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。 POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。 多处理器用多线程：效果最好 单处理器使用多线程： 也有增益（一个线程等IO，另外的执行） 适用场景 多任务同时进行 阻止潜在的长时间IO等待 一些地方很多CPU周期 必须响应异步 优先级中断","text":"POSIX thread Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。 POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。 多处理器用多线程：效果最好 单处理器使用多线程： 也有增益（一个线程等IO，另外的执行） 适用场景 多任务同时进行 阻止潜在的长时间IO等待 一些地方很多CPU周期 必须响应异步 优先级中断 线程基础线程共享模型所有线程都可以访问相同的全局共享内存,但是也有自己的私有数据。 线程安全由多个线程共享资源引起的，如果例程没有使用某种类型的同步结构来防止数据损坏，那么它就不是线程安全的。 线程限制依赖于具体实现（我的WSLunlimit -Hu）： 1234567891011121314151617tigerroarm@Mudifan:~$ ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 50633max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 50633virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 线程共享如下资源 进程指令（ Process instructions） 大部分数据 文件描述符 signals 和 signal handlers 当前目录 User 和 group id 每个线程独立有： Tread ID registers, stack pointer集合 local variables, return addresses 栈 signal mask priority Return value: errno pthread 如果OK会return 0 编译程序需要用： gcc -pthread thread_program.c 创建线程1234int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void * (*start_routine)(void *), void *arg); thread : 返回的thread ID attr: 使用默认thread 就NULL start_routine: 需要线程运行的函数 arg: 函数参数 进程同步thread 库提供了三种同步机制 互斥（mutexes）:互斥锁（mutual exclusion lock） joins: 等待其他进程完成 条件变量: pthread_cond_t mutex:用pthread_mutex_lock和pthread_mutex_unlock加锁解锁 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void *functionC();pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;int counter = 0;main()&#123; int rc1, rc2; pthread_t thread1, thread2; /* Create independent threads each of which will execute functionC */ if( (rc1=pthread_create( &amp;thread1, NULL, &amp;functionC, NULL)) ) &#123; printf(&quot;Thread creation failed: %d\\n&quot;, rc1); &#125; if( (rc2=pthread_create( &amp;thread2, NULL, &amp;functionC, NULL)) ) &#123; printf(&quot;Thread creation failed: %d\\n&quot;, rc2); &#125; /* Wait till threads are complete before main continues. Unless we */ /* wait we run the risk of executing an exit which will terminate */ /* the process and all threads before the threads have completed. */ pthread_join( thread1, NULL); pthread_join( thread2, NULL); exit(0);&#125;void *functionC()&#123; pthread_mutex_lock( &amp;mutex1 ); counter++; printf(&quot;Counter value: %d\\n&quot;,counter); pthread_mutex_unlock( &amp;mutex1 );&#125; Joins等待线程完成。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define NTHREADS 10void *thread_function(void *);pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;int counter = 0;main()&#123; pthread_t thread_id[NTHREADS]; int i, j; for(i=0; i &lt; NTHREADS; i++) &#123; pthread_create( &amp;thread_id[i], NULL, thread_function, NULL ); &#125; for(j=0; j &lt; NTHREADS; j++) &#123; pthread_join( thread_id[j], NULL); &#125; /* Now that all threads are complete I can print the final result. */ /* Without the join I could be printing a value before all the threads */ /* have been completed. */ printf(&quot;Final counter value: %d\\n&quot;, counter);&#125;void *thread_function(void *dummyPtr)&#123; printf(&quot;Thread number %ld\\n&quot;, pthread_self()); pthread_mutex_lock( &amp;mutex1 ); counter++; pthread_mutex_unlock( &amp;mutex1 );&#125; Condition Variables为什么需要条件变量使用互斥锁的时候，如果有一个下面的情况 线程1: 如果有变化，就把本地buff save 到cloud上 线程2：改本地buff，标记变化 123456789//thread 1while(1) &#123; pthread_mutex_lock(lock); if(is_change) &#123; save_to_cloud(buff); is_change = false; &#125; pthread_mutex_unlock(lock);&#125; 12345678910//thread 2while(1) &#123; char = tmp[50]; read(tmp, 50); pthread_mutex_lock(lock); strcpy(buff, tmp); is_change = true; pthead_mutex_unlock(lock);&#125; 如果这时候is_change 一直是false， 那么thread1一直在执行循环。 想达到的目的是：直到某个状态改变，才开始执行 需要的是lock+condition 就需要有条件变量 互斥锁通过控制线程对数据的访问来实现同步，而条件变量允许线程根据数据的实际值进行同步。如果没有条件变量，程序员将需要线程持续轮询(可能在关键部分) ，以检查条件是否满足。这可能会非常消耗资源，因为线程在此活动中将持续忙碌。条件变量是一种不用轮询就可以实现相同目标的方法。 使用 主线程： 声明和初始化需要同步的全局数据/变量(例如“ count”) 声明和初始化条件变量对象 声明并初始化一个的互斥锁 创建线程 a 和 b 来做工作 线程A 一直工作到某个条件必须发生的点(例如“ count”必须达到指定的值) 锁住互斥锁，然后检查值 pthread_cond_wait() ，阻塞等待来自B线程信号（自动解锁相关的互斥锁） 当收到信号时就唤醒进程 线程B 锁住互斥锁 更改线程A正在等待的全局变量的值 检查全局变量的值，如果满足条件，给A发信号 解锁互斥锁 具体方法 pthread_cond_wait() 阻塞线程直到条件达到 pthread_cond_init pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_cond_signal()：唤醒另一个等待条件变量的信号 参考 Linux Tutorial: POSIX Threads (cmu.edu) Multi-Threaded Programming With POSIX Threads (kent.edu)","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/categories/C-C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.difan.tech/tags/Unix/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"}]},{"title":"HTTP 协议","slug":"HTTP协议","date":"2021-02-28T16:00:00.000Z","updated":"2021-09-05T16:51:51.442Z","comments":true,"path":"2021/03/01/HTTP协议/","link":"","permalink":"https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"超文本传输协议（HTTP协议） 特点： 简单 易解析 可读性好 RFC 2616 Link (HTTP 1.1)","text":"超文本传输协议（HTTP协议） 特点： 简单 易解析 可读性好 RFC 2616 Link (HTTP 1.1) HTTP 版本 HTTP/1.1 : 1999年 RFC 2616，还有RFC7230。目前少于三分之一的网站使用（包括其和其早期版本）。 1.1相比于1.0：使用一个TCP连接可以传多个HTTP request/response（引入keep-alive-mechanism，HTTP长连接）， client不需要在发送第一个请求后重新协商 TCP 3-Way-Handshake 连接。 1.1相比于1.0：带宽优化：使用了分块传输编码（Chunked transfer encoding）的流式传输机制，即把内容分块（Chunk）进行流式传输 HTTP/2.0 : 2015年，超过一半的网站使用，以谷歌的SPDY为基础开始指定的新版本HTTP协议，RFC 7540. HTTP/3.0 : HTTP over QUIC，18%网站使用，使用UDP作为底层传输协议 HTTP RequestHTTP Request 是client端向server端做的一个请求。 包括： 一个请求行： GET /images/logo.png HTTP/1.1 请求头：Accept-Language: en Link Accept-Language: en Accept-Ranges: type：指定bytes可以作为一个单位去定义一个range，如果是none则表示不支持partial request。 空行 HTTP 消息正文( message body) : 可选 请求行和其他头字段必须以 &lt;CR&gt;&lt;LF&gt;结尾，空行只包括 &lt;CR&gt;&lt;LF&gt;且无空格 HTTP 方法 GET （1.0） HEAD（1.0） ：除了没有响应体外（Response body）与 GET 请求相同，可以用于检索 POST （1.0） ：请求服务器接收包括的entity OPTIONS（1.1） ： 返回某个URL支持的HTTP 方法 PUT （1.1）： 请求服务器将entity的保存在URI下（如果存在则修改，不存在则新建） DELETE（1.1） ：删除 TRACE （1.1） ： 回复收到的请求，client知道server做了什么改动，由于XST攻击建议关闭 CONNECT （1.1）: 用于proxy较多 HTTP method RFC Request has Body Response has Body Safe Idempotent Cacheable GET RFC 7231 No Yes Yes Yes Yes HEAD RFC 7231 Optional No Yes Yes Yes POST RFC 7231 Yes Yes No No Yes PUT RFC 7231 Yes Yes No Yes No DELETE RFC 7231 Optional Yes No Yes No CONNECT RFC 7231 Optional Yes No No No OPTIONS RFC 7231 Optional Yes Yes Yes No TRACE RFC 7231 No Yes Yes Yes No PATCH RFC 5789 Yes Yes No No No 表格来自[1] HTTP Response 状态行 ：HTTP/1.1 200 OK 响应头： Content-Type: text/html 空行 消息体 状态码（status code） 信息 1XX 成功 2XX 200 OK 重定向Redirection 3XX Client Error 4XX Server Error 5XX 几个常见的状态码： 206 : Partial Content 200: OK 404: Not Found 500: Internal Server error 例子12GET / HTTP/1.1Host: www.example.com 123456789101112131415161718HTTP/1.1 200 OKDate: Mon, 23 May 2005 22:38:34 GMTContent-Type: text/html; charset=UTF-8Content-Length: 155Last-Modified: Wed, 08 Jan 2003 23:11:55 GMTServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)ETag: &quot;3f80f-1b6-3e1cb03b&quot;Accept-Ranges: bytesConnection: close&lt;html&gt; &lt;head&gt; &lt;title&gt;An Example Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; Reference[1] https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol [2] https://en.wikipedia.org/wiki/List_of_HTTP_header_fields [3] https://www.w3.org/Protocols/rfc2616/rfc2616.html","categories":[{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/categories/Network/"}],"tags":[{"name":"http","slug":"http","permalink":"https://blog.difan.tech/tags/http/"}]},{"title":"MATLAB编程指北","slug":"MATLAB编程指北","date":"2021-01-15T16:00:00.000Z","updated":"2021-01-23T12:46:24.372Z","comments":true,"path":"2021/01/16/MATLAB编程指北/","link":"","permalink":"https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/","excerpt":"常用技巧 折叠 ctrl = 折叠代码 shift ctrl =展开代码 缩进整理 ctrl i（==全选+ctrl i==） 跳转到第几行 ctrl g F5运行，F10 debug，shift+F5 退出Debug模式 doc 取代help，直接跳出文档（由于外网，网络可能不稳定）","text":"常用技巧 折叠 ctrl = 折叠代码 shift ctrl =展开代码 缩进整理 ctrl i（==全选+ctrl i==） 跳转到第几行 ctrl g F5运行，F10 debug，shift+F5 退出Debug模式 doc 取代help，直接跳出文档（由于外网，网络可能不稳定） 提醒 注意，MATLAB所有序号都是==从1开始== MATLAB中 ==Class Array== 的思想随处不在 例如对于a = 54，使用whos命令可以看到，MATLAB认为这是一个Size 1×1 8 Bytes的double array，==而非一个简单的double变量==。 再例如，str1 =&quot;string&quot;，是一个Size 1×1的，150 Bytes的Class为String的Array变量。也就是说，你完全可以直接str1(2) = “string2”，这种操作被理解为在str1这个string array变量中增加了一个元素。 同样的，char = &#39;char&#39;是定义了一个Size 1×4的，Bytes为8的 Class 为 char的Array变量。 使用%% %来区分不同Block的代码是一种好方法 数据类型 double single（单精度） logical int8(1B 8bit) int16 int32 int64 uint8 char(‘’) string(“”) NaN(Not a Number) Inf(无穷)：有正负之分 cell struct function_handle 常用矩阵操作 flipud(M): 翻转矩阵，从下面往上反转 fliplr：左右翻转 flip([])： 翻转向量，矩阵的话和ud一样 repmat(A, 2, 3)：横向重复两次，纵向3次 repelem(A, 2, 3)：repeat element 原来矩阵每个元素都2×3，重新组成新的 max(A):每列中最大的元素 diff(): 每次相邻两个元素之间做差 prod() :返回数组乘积 cumsum()：返回前n个元素的和 cumprod() cummin() cummax() linspace(x1,x2,n) ：产生n个x1到x2的数据，间隔(x2-x1)/(n-1) logspace(x1,x2,n)： 产生n个$$10^{x1}$$到x2的数据 增删改查 find(logical_vector, k, &#39;first&#39;) ：首k个true值 any(logical_vector) all(logical_vector) 绘图 线颜色 b : blue g : green r : red c : cyan 青蓝色 m : magenta 品红色 y : yellow k ：black w ：white 线样式 -- 段虚线 : 点虚线 -. 段点虚线 marker *-. *为marker o . x s square 方块 d 菱形 v ^ &lt; &gt; p 五角形 h 六角形 close all 关闭所有的figure clf 清空当前画布 clear current figure 还有cla，清空坐标区 subplot(row, col, n_th) grid on 网格 legend() 图例 xlabel(&#39;&#39;) ylabel(&#39;&#39;) title(&#39;&#39;) 如果要LaTeX显示，需要在后面的&#39;Interpreter&#39;设置为&#39;latex&#39; 例如 1title([&#x27;Predictive signal $\\hat&#123;d&#125;(n)$ and orignal signal $d(n)$ with p=&#x27;,num2str(p)],&#x27;Interpreter&#x27;,&#x27;latex&#x27;); plot修饰 color+marker+line_shape, e.g. &#39;ro-.&#39; LineWidth 默认为1 MarkerEdgeColor Marker边缘的颜色 MakerFaceColor Marker里面的颜色 axis([x1 x2 y1 y2]) 设置坐标轴范围 字符和字符串 strlength(&quot;string&quot;)： 字符串长度 string 类型可以通过&#123;&#125;的方式提取出char类型结果，例如可以通过string&#123;1&#125;(2)提取出第一个string中的第二个char input(&#39;Some suggestion string:&#39;,&#39;s&#39;) 输入的是char类型 Upper，全部大写 strcmp(str1, str2, num)，前num位的字符是否相同 strfind(text, pattern) 找text中pattern 的位置 strsplit(text, pattern) split 字符串 元胞数组 &#123;48, &quot;uui&quot;, 1:4:9&#125; 访问使用{index} {1,2} 结构体 S = struct(&#39;field1&#39;,VALUES1,&#39;field2&#39;,VALUES2,...) 保存加载 save testfile.dat mydata -ascii save 文件名 变量名 load file_name.dat 可变长输入输出 varargin{1}： variable argument input, cell 类型，存储输入参数 nargin 输入参数个数 varargout 输出参数 nargout 输出个数 本地函数和嵌套函数 本地函数，单个m文件中定义的函数，作用域为整个m文件 嵌套函数（可以使用所有外层函数定义的量） 函数句柄 function_handle，为一个单独的数据类型 使用 func_han = @(argm1, argm2) argm1*argm2; 即可定义手柄 func2str(func_hndl);得到函数名字 相关函数 fplot(@sin(), [0, 2*pi]) feval(@sin(), 0:0.1:1) 返回每个值对应的函数输出 timeit(func_handle)，算函数计算的时间通信相关 qammod12ModDataTX = qammod(BinData, MOD, &#x27;InputType&#x27;, &#x27;bit&#x27;, &#x27;PlotConstellation&#x27;,true);% 对于输入bit 流进行 QAM调制，MOD是调制阶数，InputType指定输入类型 注意 matlab中 vector’ 如果是vector复数向量，就算的直接是共轭转置，这个被坑过，如果想只转置可以用 vector.’ berfading估计fading时的性能，参数是SNR，调制方式，调制模，复用参数 12345678910111213EbNo = 8:2:20; % Eb/N0ber = zeros(length(EbNo),20);for L = 1:20 ber(:,L) = berfading(EbNo,&#x27;qam&#x27;,16,L); % 16 QAMendsemilogy(EbNo,ber,&#x27;b&#x27;)text(18.5, 0.02, sprintf(&#x27;L=%d&#x27;,1))text(18.5, 1e-11, sprintf(&#x27;L=%d&#x27;,20))title(&#x27;QAM over fading channel with diversity order 1 to 20&#x27;)xlabel(&#x27;E_b/N_0 (dB)&#x27;)ylabel(&#x27;BER&#x27;)grid on 随机数rng(&#39;shuffle&#39;)来使用当前时间作为随机数种子 rand0-1 随机数 randi伪随机整数 X = randi([imin,imax],size_1,size_2) X = randi(imax,sz1,…,szN) 123randi([min max], row_number, col_number);% e.g.randi([0 10], 1000, 1); % Generate 1000✖1 random vector with range from 0 to 10 randnrandn生成正态分布随机数 X = randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。 X = randn(sz1,…,szN) 返回由随机数组成的 sz1×…×szN 数组，其中 sz1,…,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。 X = randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/categories/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/tags/MATLAB/"}]},{"title":"Inband Full-duplex Wireless Communication System","slug":"fullduplex","date":"2021-01-01T16:00:00.000Z","updated":"2022-02-19T12:19:58.633Z","comments":true,"path":"2021/01/02/fullduplex/","link":"","permalink":"https://blog.difan.tech/2021/01/02/fullduplex/","excerpt":"动机全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-BandFull-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。","text":"动机全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-BandFull-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。 主要想法要实现全双工，主要就是减少自干扰（self-interference），即同一设备发射的信号对于接收信号的干扰。WiFi信号的平均功率为20dBm（100mW），接收机的噪声基底（noisefloor）大致为-90dBm，所以要将自干扰降低到-90dBm，需要降低110dB的线性抵消能力。 对于非线性自干扰（Harmonics），其为-10dBm（比基底高80dB），即需要80dB的非线性抵消能力。 图 1 抵消目标[1] 图1中，我们看到，SIC中线性分量是主要分量，发射机噪声为-40dBm，由于OFDM的PAPR特性所以我们需要预留10dB，即模拟域需要提供60dB的消除能力。 自干扰分析在WiFi场景下，自干扰主要有以下三种（如图1所示） 天线与环行器阻抗不匹配导致的反射分量 RA 环行器1端口到3端口的泄露分量 I 环境散射分量RC 图 2 自干扰分析图 具体实现方法4.1 天线隔离 环行器 Circulator（大部分的方法） 电平衡 EBD (×) 4.2 RF域（模拟域）干扰抵消4.2.1 IMT 方法（RF front）[2]I和RA因为没有路径损耗，具有主要的能量，是我们在模拟域/RF域主要需要抵消的信号。RC由于其环境反射特性可以在数字域建模消除。 使用IMT网络控制RA的振幅和相位，直接抵消I。 根据计算得到反射系数结果： S为端之间的回波损耗。 上图具有并联和串联变容二极管的可重配置IMT电路的示意图，可以通过调整Vs，Vp来调整Zin。 ZL是天线输入阻抗，根据反射系数定义，可以得到： Z0是环行器器2端口的特性阻抗。 实验部分： 用了RFCI CR5853环行器，15.5dB固有隔离度。Skyworks Inc的可变容二极管SMV 2019 结果： 图3 IMT结果 4.2.2 信号重建方法 SR-SIC（第一阶段）以[1]为代表的抽头延迟线横向滤波器，通过对射频信号采样，用sinc函数插值重建原始信号。是我们第一阶段采用的方法。 图 4 时域信号重建方法 图4为时域的方法，基于时域的抵消架构对发射信号进行采样，并将其分成不同的分支，称为抽头。这些抽头中的每一个都有不同的时间延迟，并且可以在组合成单个输出之前独立调整信号的幅度和相位。正是这种延迟和抽头的复杂加权使得抵消器能够匹配自干扰信号，并产生与接收机内的自干扰相消的信号。 由于使用原始信号进行信号重建，故其发射机噪声可以被消除（也只能在模拟域进行消除）。其线性消除能力为62dB，非线性能力为30dB 当然也有频域相关的方法，可以参考哥伦比亚大学JinZhou团队，优点是可以芯片小型化，缺点是目前为止其指标并不高。 4.2.3 信道响应方法 CR-SIC[8]中的方法 4.2.4 数字域辅助模拟域方法[5]的方法，可以作为参考 4.3 数字域干扰抵消参考[3]和专著[12] 4.3.1 功放模型在理想情况下，对于均值为0的射频信号，我们期望功率放大器的输出信号总是其输入信号的线性放大 其中表示某一常数。然而在实际情况中功率放大器的增益是一个随着输入信号大小而变化的函数 图 4 幅度-幅度（AM-AM）特性 幅度-相位（AM-PM）特性 AM-AM特性和AM-PM特性指的是输入幅度变化造成的输出幅度和输出相移的非线性改变。早期通信系统带宽比较窄，远小于功放的工作带宽，所以使用无记忆模型，在频域上的体现就是功率放大器的行为特性不依赖于信号频率。当通信的带宽越来越大，其记忆效应更加明显，简单的无记忆模型不再适用。其记忆效应在频域体现在频率依赖行为，在时域体现在不仅与当前信号有关，还与过去一段时间信号有关。 记忆效应分为长记忆效应（线性记忆效应）和短记忆效应（非线性记忆效应），前者与匹配网络有关，后者主要由于功放的低频散射，具体模型如表1所示。 功放非线性指标 1dB压缩点:相对线性增益降低1dB的输出功率点 三阶截断点:IP3 表1 常用功放模型分类 无记忆模型 多项式模型 结构简单，参数辨识度高 记忆模型 两盒模型 Wiener 线性滤波+静态非线性模块（无记忆） Hammerstein 静态非线性模块（无记忆）+线性滤波 Volterra级数及其改进形式 记忆多项式模型(Memory Polynomial)的性能具有稳健性，多种情况下优于Wiener, Hammerstein等模型的线性化性能，结构简单，复杂度低。 PA的Volterra级数模型一般形式的Volterra模型为： (4.3.1-1) 称为Volterra的kernels，一般只考虑奇数项，那么Volterra在功放中的表示形式如下 (4.3.1-2) 为对角项，其它求和项为交叉项。如果我们忽略交叉项，只保留对角项，则简化为如下多项式模型： (4.3.1-3) 4.3.2 线性消除闭环方法同模拟域类似，可以使用具有数字可控时间延迟单元和复杂抽头加权的抽头延迟线结构，如下图所示，可以通过LMS等等方法调整权重，好处是在数字域处理更加灵活，抽头数可以更多，自适应性强，可以实时调整权重。 图 4 数字域闭环方法 开环方法主要是[1]中的方法，使用WiFi Preamble进行LS信道估计后恢复信号。 我们同样使用PH模型进行PA建模： 其中2K-1是该模型的阶数，L是该模型的抽头数。其矩阵形式可表示为： 其中 其中的Y是带有噪声的向量，通过LS算法求出B后再进行模型重建。 4.3.2 非线性消除Parallelizable-Hammerstein 模型功放的模型可以参考[4]。 参考文献[1] Bharadia, D., McMilin, E., &amp; Katti, S. (2013). Full duplex radios. ACMSIGCOMM. https://doi.org/10.1145/2534169.2486033 [2] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). InherentSelf-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.https://doi.org/10.1109/TMTT.2018.2818124 [3] Kolodziej, K. E., Perry, B. T., &amp; Herd, J. S. (2019). In-Band Full-DuplexTechnology: Techniques and Systems Survey. IEEE Transactions on Microwave Theoryand Techniques, 67(7), 3025–3041. https://doi.org/10.1109/TMTT.2019.2896561 [4] Isaksson, M., Wisell, D., &amp; Rönnow, D. (2006). A comparative analysis ofbehavioral models for RF power amplifiers. IEEE Transactions on Microwave Theoryand Techniques, 54(1), 348–359. https://doi.org/10.1109/TMTT.2005.860500 [5] Liu, Y., Quan, X., Pan, W., &amp; Tang, Y. (2017). Digitally Assisted AnalogInterference Cancellation for In-Band Full-Duplex Radios. IEEE CommunicationsLetters, 21(5), 1079–1082. https://doi.org/10.1109/LCOMM.2017.2652444 [6] Kolodziej, K. E., McMichael, J. G., &amp; Perry, B. T. (2016). Multitap RFCanceller for In-Band Full-Duplex Wireless Communications. IEEE Transactions onWireless Communications, 15(6), 4321–4334.https://doi.org/10.1109/TWC.2016.2539169 [7] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.IEEE Communications Magazine, 54(9), 80–87.https://doi.org/10.1109/MCOM.2016.7565192 [8] Choi, Y. S., &amp; Shirani-Mehr, H. (2013). Simultaneous transmission andreception: Algorithm, design and system level performance. IEEE Transactions onWireless Communications, 12(12), 5992–6010.https://doi.org/10.1109/TWC.2013.101713.121152 [9] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.IEEE Communications Magazine, 54(9), 80–87.https://doi.org/10.1109/MCOM.2016.7565192 [10] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). InherentSelf-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.https://doi.org/10.1109/TMTT.2018.2818124 [11] Wu, X., Shen, Y., &amp; Tang, Y. (2014). The Power Delay Pro fi le of theSingle-Antenna. 13, 1561–1564. [12] Full-Duplex Wireless Communications Systems.(2017).","categories":[{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/categories/EE/"}],"tags":[{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/tags/EE/"}]},{"title":"运动营养、减脂","slug":"运动营养","date":"2021-01-01T16:00:00.000Z","updated":"2022-02-19T14:32:50.982Z","comments":true,"path":"2021/01/02/运动营养/","link":"","permalink":"https://blog.difan.tech/2021/01/02/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/","excerpt":"减脂有氧和少吃不是最好方法：原因： 热量缺口（有氧+少吃）-&gt; 代谢下降 蛋白质降低，掉肌肉 脂肪吸收效率提高: 复胖速度快 正确的减脂思路 确定摄入的热量 亏空用锻炼放上 做力量训练，提高基础代谢 控制饮食 训练之后吃碳水，均匀摄入脂肪，蛋白质 避免糖脂混合物，鲜榨果汁，避免果糖 可以少食多餐 咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶 2g速溶咖啡大概50mg咖啡因 人体咖啡因一天小于400mg，不会有影响不要一上来就是低碳水高蛋白，会给肾脏压力大","text":"减脂有氧和少吃不是最好方法：原因： 热量缺口（有氧+少吃）-&gt; 代谢下降 蛋白质降低，掉肌肉 脂肪吸收效率提高: 复胖速度快 正确的减脂思路 确定摄入的热量 亏空用锻炼放上 做力量训练，提高基础代谢 控制饮食 训练之后吃碳水，均匀摄入脂肪，蛋白质 避免糖脂混合物，鲜榨果汁，避免果糖 可以少食多餐 咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶 2g速溶咖啡大概50mg咖啡因 人体咖啡因一天小于400mg，不会有影响不要一上来就是低碳水高蛋白，会给肾脏压力大 热量计算1kg脂肪 7700大卡，一周不超过1kg最安全 目标是最大减脂效率（1kg/week），每天1000大卡的热量亏空 我的代谢：2700大卡，每天1700热量摄入，并且蛋白质增加 早餐 200大卡 午餐 800-1000大卡 晚餐 500大卡 常见食品热量 三勺燕麦：100大卡 一个汉堡 400大卡 薯条：350大卡 鸡排：200大卡 牛排：250大卡 二两米饭：100大卡 一片面包：150大卡 一条鱼：100大卡 80% 蛋白质 牛/羊肉 120大卡/100g 85%蛋白质 猪肉 330大卡/100g 脂肪高 二两米饭：","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.difan.tech/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"减脂","slug":"减脂","permalink":"https://blog.difan.tech/tags/%E5%87%8F%E8%84%82/"},{"name":"运动营养","slug":"运动营养","permalink":"https://blog.difan.tech/tags/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"}]},{"title":"数字信号处理 -- 基于计算机方法","slug":"DSP","date":"2020-12-26T16:00:00.000Z","updated":"2020-12-28T16:00:00.000Z","comments":true,"path":"2020/12/27/DSP/","link":"","permalink":"https://blog.difan.tech/2020/12/27/DSP/","excerpt":"目录： 本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记","text":"目录： 本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记 信号与信号处理信号信号分类 振幅 时间 连续时间信号 振幅也连续：模拟信号 离散时间信号 振幅离散：数字信号 复数信号和解析信号复数信号 Why? 信号表示更加复杂（相位，幅度） -&gt; 信息量很大 -&gt; 信号处理更加简单，易于处理 希尔伯特变换 HT $h_{HT} = \\frac{1}{\\pi t}$ $H_{HT}(j\\Omega) = \\begin{cases} -j &amp; \\Omega &gt; 0 \\\\ j &amp; \\Omega &lt; 0 \\end{cases} $ 实数信号 实数信号 FT性质 =&gt; 幅度偶对称，相位奇对称 正频率 + 负频率 $X(j\\Omega) = X_p(j\\Omega)+X_n(j\\Omega)$ 经过HT =&gt; $\\hat{X}(j\\Omega) = -j X_p(j\\Omega)+jX_n(j\\Omega)$ =&gt; $\\hat{x}(t)$也是实数信号 解析信号=&gt; 解析信号 $y(t) = x(t) + j\\hat{x}(t)$ $x(t), \\hat{x}(t)$ 为同相分量和正交分量 $Y(j\\Omega) = X(j\\Omega)+j\\hat{X}(j\\Omega) = 2 X_p(j\\Omega)$ 我们可以看出解析信号只包含正频率的部分 信号运算 简单运算 衰减 延迟 $y(t) = x(t-t_0)$ 相加，相乘 积分 $y(t) = \\int_{-\\infty}^{t}x(\\tau) d\\tau$ 微分 $y(t) = \\frac{dx(t)}{dt}$ 傅里叶变换Fourier Transform(FT) $X(j\\Omega) = \\int_{-\\infty}^{+\\infty}x(t) e^{-j\\Omega t} dt$ 滤波 $y(t) = \\int_{-\\infty}^{+\\infty} h(t-\\tau)x(\\tau)d\\tau$ 低通，高通，带通 带阻（陷波器3） 多频带滤波器：多个通带阻带 梳状滤波器：阻断某个低频的整数倍 调制 Why? 低频信号无法直接用于传输 调制到高频进行传输- 原理：利用信号的振幅、相位、频率表示信号 时域离散时间信号离散时间信号， Why？ 现代计算机、微处理器、嵌入式设备都是处理数字信号的，但是我们的物理世界充斥着连续信号（模拟信号），如声音信号等。而直接处理模拟信号是比较困难的（1G通信），设备器件做的很大（大哥大），而且不便于加密（你树根天线就能窃听到隔壁老王在电话里说什么）。这就涉及到模拟信号数字化（采样，或者抽样），转换为数字信号进行处理。 时域表示采样： $x[n] = x_a{(t)}|_{t = nT} = x_a(nT)$ 采样频率（抽样频率）： $F_t = \\frac{1}{T}$ 采样得到的值由于ADC（数模转换器）的精度问题（例如12 Bit ADC）有舍入的问题。 频域表示归一化角频率：$\\omega_c$ 为归一化角频率，因为样本$n$是无量纲的，所以应该是弧度/样本，且 $$\\omega = 2\\pi f$$ $f$ 是归一化角频率， 单位是周期/样本，即一个样本多少周期 运算例子2.1：集合平均 $s[n]=2[n(0.9)^n]$ 和噪声$d(n)$，受干扰后的集合平均可以减少干扰影响 123456789101112131415161718192021222324252627282930313233343536373839% Program_2_1% Generation of the ensemble averageN = 50; % total numbern = 0 : N-1;s = 2*(n.*0.9.^n); % generate the original signal s[n]rng();d = rand(N, 1) - 0.5; % generate the noise signal d[n]x1 = s+d&#x27;; % the corrupted signal% Plot the corrupted signalsubplot(2,1,1)stem(n, x1);xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Corrupted Signal&#x27;)% Plot the Noise Signalsubplot(2,1,2)stem(n, d)xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Noise Signal&#x27;)% Ensemble averagefor m = 1:50 rng(); noise = rand(N,1) - 0.5; x = s + noise&#x27;; x1 = x1 + x;endx1 = x1 / N;% Plot the ensemble average signalfigure;stem(n, x1);xlabel(&#x27;Time Index n&#x27;)ylabel(&#x27;Amplitude&#x27;)title(&#x27;The Ensemble Average Signal&#x27;) 卷积使用函数 conv即可作为卷积运算 抽样率转换抽样率转换比: $\\frac{F_T^{‘}}{F_T} = R$, $F_T$ 是原本的抽样率, 再拿$F_T^{‘}$ 去抽样 序列分类 周期、非周期 能量信号、功率信号","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"DSP","slug":"DSP","permalink":"https://blog.difan.tech/tags/DSP/"},{"name":"Math","slug":"Math","permalink":"https://blog.difan.tech/tags/Math/"},{"name":"SignalProcessing","slug":"SignalProcessing","permalink":"https://blog.difan.tech/tags/SignalProcessing/"}]},{"title":"TMUX","slug":"TMUX","date":"2020-10-08T16:00:00.000Z","updated":"2021-04-13T09:20:38.867Z","comments":true,"path":"2020/10/09/TMUX/","link":"","permalink":"https://blog.difan.tech/2020/10/09/TMUX/","excerpt":"常用 tmux new -s window_name ctrl + b + d : detach 当前的window tmux a -t window_name ctrl + b + w : 看一下window， panne 使用场景 维护管理终端正在运行的程序 执行多个任务 远程使用时尤其方便，断开连接也不会挂掉正在跑的东西","text":"常用 tmux new -s window_name ctrl + b + d : detach 当前的window tmux a -t window_name ctrl + b + w : 看一下window， panne 使用场景 维护管理终端正在运行的程序 执行多个任务 远程使用时尤其方便，断开连接也不会挂掉正在跑的东西 结构 Sessions 包含多个windows，表示一个工作区 Windows 相当于浏览器的tabs Panes 一个window分割成几个视觉上分开的Panes 快捷键 session tmux 开启新session tmux new -s NAME tmux ls 列出现存的session d 分离当前的session tmux a 继续上一个session tmux a -t 0 指定session 0 window c 创建window + number 去 第几 window p 上一个window n 下一个window w 列出现有的windows pane “ （我这里是 | ）水平方向分割 % （我这里是 - ）竖直方向分割 z 全屏，然后再按一次恢复 ← →来改变pane大小","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"tmux","slug":"tmux","permalink":"https://blog.difan.tech/tags/tmux/"}]},{"title":"Vim 随手记","slug":"Vim 随手记","date":"2020-05-03T16:00:00.000Z","updated":"2020-05-08T16:00:00.000Z","comments":true,"path":"2020/05/04/Vim 随手记/","link":"","permalink":"https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/","excerpt":"基本操作","text":"基本操作 i : insert 光标字符之前 a : append 光标字符之后加入 o : open a line below 当前行下面开一行 A : 在本行最后append O : 本行上面插入一行，开头插入 I : 在本行开头插入 模式 normal 使用 gi 快速恢复到原始插入位置 w 下个单词开头，e下个单词结尾 b 上个单词开头 大写跳动到以空白符为间隔的地方 f+字符，搜索字符, ; 下一个 ,上一个 F+ 字符反过来搜 0 行首，$ 行尾 g 移动到开头，G移动到结尾 H/M/L跳转到屏幕的开头，结尾 ctrl u ctrl d翻页 cltr F/B dw 删除一个单词 delete a world x删除字符 r replalce一个字符 s 删除当前字符进入插入模式 R 不断地替换 S 整行删除，进入插入模式 c(change) aw 删掉一个词进入插入 C 删除整行进入插入模式 ct” 删除整个“”中的内容 ? / 进行反向前向搜索，n/N下一个上一个 # * 当前单词向上搜索/向下搜索 insert ctrl + w 删除word ctrl + u 删除行 ctrl + h 删除上一个字符 用ctrl + [ 代替esc command :vs(vertical split) 竖分屏（左右） :sp(split) 上下分屏 set nu 行号 % s/word1/word2/g 全局替换 1,6 s/word1/word2/g 1-6行之间替换 1,6 self//n 统计1-6行几个匹配self n指number，报告匹配到的次数 % s/&lt;quack&gt;/word2/g visual normal 模式 v V选行 ctrl v选方块","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://blog.difan.tech/tags/vim/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/tags/Linux/"},{"name":"随手记","slug":"随手记","permalink":"https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}]},{"title":"如何在CentOS 7上使用FirewallD设置防火墙","slug":"如何在CentOS 7上使用FirewallD设置防火墙","date":"2020-01-10T11:40:44.000Z","updated":"2020-05-04T08:33:06.038Z","comments":true,"path":"2020/01/10/如何在CentOS 7上使用FirewallD设置防火墙/","link":"","permalink":"https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"本文翻译自 How To Set Up a Firewall Using FirewallD on CentOS 7","text":"本文翻译自 How To Set Up a Firewall Using FirewallD on CentOS 7 引言Firewalld是可用于许多Linux发行版的防火墙管理解决方案，它充当Linux内核提供的iptables数据包过滤系统的前端。 在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用firewall-cmd管理工具管理防火墙的基本知识（如果您希望在CentOS中使用iptables，请遵循 这个指南。 Firewalld 的基本概念在开始讨论如何实际使用firewall-cmd实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。 Zones(区域)Firewalld守护程序使用称为“区域”的实体管理规则组。 区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。 为网络接口分配一个Zone来指示防火墙应允许和拒绝哪些行为。 对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。 在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。 对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改。 无论您的网络环境动态性有多强，熟悉防火墙的每个预定义区域背后的概念仍然很有用。 按从最不信任到最受信任的顺序，firewalld中的预定义区域为： drop：最低级别的信任度。 所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。 block：与上述类似，但不仅仅是丢弃连接，而是使用icmp-host-prohibited或icmp6-adm-prohibited消息拒绝传入的请求。 public：代表公共的，不受信任的网络。 您不信任其他计算机，但可能会视情况允许选择的传入连接。 external：external network用于这种情形：您将firewalld当成网关使用。 将其配置为伪NAT，以便您的内部网络保持私有但可访问。 internal：外部区域的另一侧，用于网关的内部。 这些计算机相当值得信赖，并且可以使用一些其他服务。 dmz：用于DMZ（无法访问网络其余部分的隔离计算机）。 仅允许某些传入连接。 work：用于工作机。 信任网络中的大多数计算机。 可能还允许其他一些服务。 home：家庭环境。 通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。 trusted：信任网络中的所有计算机。 可用选项中最开放的，应谨慎使用。 要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口（network interface）分配给最合适的区域（zones）。 规则永久性在firewalld中，可以将规则指定为永久规则或立即规则。 如果添加或修改规则，则默认情况下，将修改当前运行的防火墙规则。 下次启动时，旧规则将恢复。 大多数firewall-cmd操作都可以使用--permanent标志来指示应永久防火墙规则作为目标。 这将影响在引导时重新加载的规则。 这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。 您还可以使用--permanent标志随着时间的推移建立一套完整的规则，这些规则将在发出reload命令时立即应用。 安装并启动防火墙firewalld默认安装在一些Linux发行版上，包括许多CentOS 7的映像。但是，您可能需要自己安装firewalld: 1sudo yum install firewalld 安装firewalld之后，可以启用服务并重新启动服务器。请记住，启用firewalld将导致服务在引导时启动。最好的做法是先创建防火墙规则，并在配置此行为之前对其进行测试，以避免潜在的问题。 12sudo systemctl enable firewalld sudo reboot 当服务器重新启动时，你的防火墙应该会打开，你的网络接口应该放入已配置的区域(或退回到已配置的默认区域)，与区域相关的任何规则都将应用于相关的接口。 我们可以通过键入以下内容来验证该服务正在运行： 1sudo firewall-cmd --state 这表明我们的防火墙已经启动并使用默认配置运行。 熟悉当前的防火墙规则在开始进行修改之前，我们应该熟悉守护进程提供的默认环境和规则。 默认值我们可以通过输入以下内容来查看当前选择的默认区域： 1firewall-cmd --get-active-zones 123outputpublic interfaces: eth0 eth1 在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（eth0和eth1）。 目前，它们都根据为public zone定义的规则进行管理。 我们如何知道与public zone相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置： 1sudo firewall-cmd --list-all 1234567891011121314outputpublic (default, active) target: default icmp-block-inversion: no interfaces: eth0 eth1 sources: services: ssh dhcpv6-client ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 从输出中可以看出，该区域既是默认区域又是活动区域，并且eth0和eth1接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。 但是，我们还可以看到，该区域允许与DHCP客户端（用于IP地址分配）和SSH（用于远程管理）相关的正常操作。 可替代区现在，我们对缺省和活动区域的配置有了很好的了解。我们也可以找到其他区域的信息。要获得可用区域的列表，请输入： 1firewall-cmd --get-zones 12outputblock dmz drop external home internal public trusted work 我们可以通过在—list-all命令中包含—zone=参数来查看与区域关联的特定配置 1sudo firewall-cmd --zone&#x3D;home --list-all 12345678910outputhome interfaces: sources: services: dhcpv6-client ipp-client mdns samba-client ssh ports: masquerade: no forward-ports: icmp-blocks: rich rules: 您可以使用–list-all-zones选项输出所有区域定义。 您可能希望将输出通过管道以便于查看： 1sudo firewall-cmd --list-all-zones | less 为接口选择区域除非您已经配置了您的网络接口，否则在防火墙启动时，每个接口都将放在默认区域。 改变接口的区域您可以在会话期间使用—zone=参数和—change-interface=参数在区域之间转换接口。与修改防火墙的所有命令一样，您将需要使用sudo。 例如，我们可以通过输入以下内容将eth0接口转换到home区域: 1sudo firewall-cmd --zone&#x3D;home --change-interface&#x3D;eth0 每当将接口转换到新区域时，请注意，您可能正在修改将可操作的服务。例如，在这里，我们将移动到”home”区域，其中有 SSH 可用。这意味着我们的连接不应该断开。默认情况下，某些其他区域未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。 我们可以通过再次请求活动区域来验证这是否成功： 1firewall-cmd --get-active-zones 12345outputhome interfaces: eth0public interfaces: eth1 调整默认区域如果所有接口都可以最好地由单个区域处理，那么只需选择最佳默认区域，然后将其用于配置可能更容易。 您可以使用 参数更改默认区域。这将立即将默认的接口更改回新区域：--set-default-zone= 1sudo firewall-cmd --set-default-zone&#x3D;home 12outputsuccess 为应用程序设置规则为您希望提供的服务定义防火墙的基本方法非常简单。我们将在这里了解基本思想。 向区域添加服务最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用以下选项获取可用服务的列表：--get-services 1firewall-cmd --get-services 12outputRH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server 您可以使用命令行参数为区域启用服务。该操作将针对默认区域或参数指定的任何区域。默认情况下，这将仅调整当前防火墙会话。您可以通过包含permanent标志来调整永久防火墙配置。--add-service=--zone=--permanent 例如，如果我们正在运行一个为传统HTTP流量提供服务的web服务器，我们可以通过输入以下命令来允许该会话的公共区域中的接口的流量: 1sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;http 我们可以用这个验证操作是否成功：--zone=--list-all--list-services 1sudo firewall-cmd --zone&#x3D;public --list-services 12outputdhcpv6-client http ssh 测试完所有功能后，可能需要修改永久防火墙规则，以便在重新启动后服务仍然可用。通过： 1sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;http 现在，您的“公共”区域将允许端口80上的HTTP Web通信。如果您的Web服务器配置为使用SSL / TLS，则还需要添加服务。 我们可以通过以下内容将其添加到当前session和永久规则集合中： 12sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;https 如果没有合适的服务可用呢?firewalld安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见需求。但是，可能会出现这些服务不适合您的需求的情况。 在这种情况下，你有两种选择： 为你的区域开一个端口支持你特定服务最简单的方法就是在合适的区域(zone)内开放一个端口， 这很容易指定端口或端口范围，以及需要打开的端口相关的协议。 比如，如果你的应用在5000端口中使用TCP，你可以在public区域内使用这个参数进行增加，协议可以为tcp，udp： 1sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;5000&#x2F;tcp 我们可以通过--list-ports进行确认 1sudo firewall-cmd --zone&#x3D;public --list-ports 使用横杠进行连续端口的指定也是可能的，例如，下面的例子就开放了4990到4999的UDP端口，当然同样是在Public zone中： 1sudo firewall-cmd --zone&#x3D;public ---add-port&#x3D;4990-4999&#x2F;udp 在测试后，我们想把它们增加为永久的防火墙规则，你可以输入： 123sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;5000&#x2F;tcpsudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;4990-4999&#x2F;udpsudo firewall-cmd --zone&#x3D;public --permanent --list-ports 定义一个服务为您的区域打开端口很容易，但是很难跟踪每个端口的用途。如果您曾经在您的服务器上停止过一个服务，那么您可能很难记住哪些过去被打开了的端口仍然是必需的。为了避免这种情况，可以定义一个服务。 服务只是具有相关名称和描述的端口的集合。使用服务比端口更容易管理，但是需要一些前期工作。最简单的启动方式是将现有的脚本复制到防火墙查找非标准定义的目录中。/usr/lib/firewalld/services/etc/firewalld/services 例如，我们可以复制SSH服务定义来使用我们的’example’服务定义，如下所示。文件名减去后缀将指示防火墙服务列表中的服务名称:.xml 1sudo cp &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;services&#x2F;ssh.xml &#x2F;etc&#x2F;firewalld&#x2F;services&#x2F;example.xml 首先，该文件将包含您复制的SSH定义 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt; &lt;short&gt;SSH&lt;/short&gt; &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;/description&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;22&quot;/&gt;&lt;/service&gt; 该定义的大部分实际上是元数据。 您将要在标签内更改服务的简称。 这是您的服务的易读名称。 您还应该添加描述，以便在需要审核服务时获得更多信息。 您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。 可以多次指定。 对于我们的示例服务，假设我们需要为TCP打开7777端口，为UDP打开8888端口。通过按下按钮进入插入模式，我们可以这样修改现有的定义 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;service&gt; &lt;short&gt;Example Service&lt;/short&gt; &lt;description&gt;This is just an example service. It probably shouldn&#x27;t be used on a real system.&lt;/description&gt; &lt;port protocol=&quot;tcp&quot; port=&quot;7777&quot;/&gt; &lt;port protocol=&quot;udp&quot; port=&quot;8888&quot;/&gt;&lt;/service&gt; 重新加载防火墙以访问新服务: 1firewall-cmd --get-services 12output:RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server 我们可以看到example服务已经被成功定义。 创造属于你自己的区域（zones）尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。 例如，您可能要为Web服务器创建一个名为“ publicweb”的zone。 但是，您可能希望为您在专用网络上提供的DNS服务而去配置另一个zone。 您可能需要一个名为“ privateDNS”的zone。 添加区域时，必须将其添加到永久防火墙配置中。 然后，您可以重新加载以将配置带入正在运行的会话。 例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域： 12sudo firewall-cmd --permanent --new-zone&#x3D;publicwebsudo firewall-cmd --permanent --new-zone&#x3D;privateDNS 您可以通过键入来验证它们是否存在于您的永久配置中: 1sudo firewall-cmd --permanent --get-zones 如前所述，这些在防火墙的当前实例中还不可用,重新加载防火墙，将这些新区域引入活动配置2 12sudo firewall-cmd --reloadfirewall-cmd --get-zones 1block dmz drop external home internal privateDNS public publicweb trusted work 现在，您可以开始为您的区域分配适当的服务和端口。先调整active instance，然后在测试之后将这些更改转移到永久配置，这通常是一个好主意。例如，对于publicweb专区，您可能希望添加SSH、HTTP和HTTPS服务 1234sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;sshsudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;httpsudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;publicweb --list-all 1234567891011121314outputpublicweb target: default icmp-block-inversion: no interfaces: sources: services: ssh http https ports: protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 同样，我们可以将DNS服务添加到我们的privateDNS zone 12sudo firewall-cmd --zone&#x3D;privateDNS --add-service&#x3D;dnssudo firewall-cmd --zone&#x3D;privateDNS --list-all 123456789privateDNS interfaces: sources: services: dns ports: masquerade: no forward-ports: icmp-blocks: rich rules: 然后，我们可以更改对应zone的网络接口以对其进行测试： 12sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1 12sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1 此时，您就有机会测试您的配置了。如果这些值对您有效，您将希望向永久配置添加相同的规则。您可以通过重新应用带有标志的规则来做到这一点:--permanent 1234sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;sshsudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;httpsudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;httpssudo firewall-cmd --zone&#x3D;privateDNS --permanent --add-service&#x3D;dns 在永久地应用这些规则之后，您可以重新启动网络并重新加载防火墙服务 12sudo systemctl restart networksudo systemctl reload firewalld 确认已经成功分配了zones： 1firewall-cmd --get-active-zones 1234privateDNS interfaces: eth1publicweb interfaces: eth0 确认合适的服务已经在每个zones里面可用： 1sudo firewall-cmd --zone&#x3D;publicweb --list-services 12outputhttp https ssh 1sudo firewall-cmd --zone&#x3D;privateDNS --list-services 1dns 现在您已经成功地建立了属于您的区域！如果您想要把其中一个区域设置为其他网络接口的默认区域，记得使用参数--set-defalut-zone= 1sudo firewall-cmd --set-default-zone&#x3D;publicweb 总结您现在应该对如何在CentOS系统上日常使用的防火墙服务进行充分的了解。 Firewalld服务允许您配置依据网络环境的可维护规则和规则集。 它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。 掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。 By Justin Ellingwood","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://blog.difan.tech/tags/CentOS/"},{"name":"FirewallD","slug":"FirewallD","permalink":"https://blog.difan.tech/tags/FirewallD/"}]},{"title":"微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验","slug":"微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验","date":"2019-12-16T02:52:37.000Z","updated":"2020-05-04T08:32:54.737Z","comments":true,"path":"2019/12/16/微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验/","link":"","permalink":"https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/","excerpt":"Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge采用了 Chromium 内核，当然也兼容以前 IE 的功能。","text":"Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge采用了 Chromium 内核，当然也兼容以前 IE 的功能。 由于最新的Edge采用Chromium内核，对于平时使用Chrome作为使用工具的人来说不会有太大学习成本，基本无缝迁移。最新版本在功耗，性能，UI上都取得了比较不错的表现。 最新的Edge版采用了Chromium的内核，当然现在没有正式版，可以用Beta版 来体验。 点击Beta版进行下载 我们看到进去后提示导入chrome收藏，一键导入很方便，UI风格很漂亮，下面看一下开发者工具： 和之前Chrome的类似，不会有学习成本。新Edge浏览器因为只是测试版，因此插件很少，不过我们可以将Chrome的插件直接打包过来或者直接访问Chrome商店进行下载。 亲测可直接添加Chrome插件，使用体验没有任何区别，在正常工作环境下（插件数量相同，打开6个TAB），新Edge占用内存较低： 目前来看，优势主要有： 账户可以直接用微软账户，同步不需要翻墙 和Chrome一致的的性能，更好的UI 平滑滚动好 要注意的是，现在的Edge Beta版和自带的Edge不是覆盖的，所以可以放心试用。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"MicroSoft","slug":"MicroSoft","permalink":"https://blog.difan.tech/tags/MicroSoft/"}]},{"title":"Git 实战","slug":"git 实战","date":"2019-07-08T16:00:00.000Z","updated":"2021-01-16T09:50:17.381Z","comments":true,"path":"2019/07/09/git 实战/","link":"","permalink":"https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/","excerpt":"版本控制系统 集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作 分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧","text":"版本控制系统 集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作 分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧 初始化12$ git config --global user.name &quot;×××&quot;$ git config --global user.email &quot;×××@gmail.com&quot; 会在~ 目录生成一个.gitconfig 如果你想不是global，则不带–global即可，会在本项目目录下创建.git/config git init 初始化一个git project git diff --cached 查看缓存区里有哪些文件被修改了。git diff会显示所有已做但是没有加到缓存区的修改 add 和commit操作不赘述，commit操作后-a将所有没有加到缓存区的修改也一起提交，不过不会提交新文件 git remote add origin https://github.com/myname/myproject.git git push origin master 分支与合并分支在多人协作开发用的多，比如你负责的一个功能需要一个月完成，就可以创建一个分支，只把功能代码提交到这个分支上，最后合并到master分支上 git branch experimental 创建分支 git branch 查看分支 结果： 12* experimental master git checkout experimental 切换到其他分支 12# 将experimental分支合并到master$ git merge -m &#39;merge experimental branch&#39; experimental 如果有冲突，比如两个分支都修改了同一个文件，就会merge失败，这是在master分支修改对应文件再commit即可。 当我们完成分支，可以用git branch -d experimental 来删除（只能删除已经合并了的分支，强行删除用-D） 如果你觉得合并错了，可以回到合并前的状态 git reset --hard HEAD^ Git 日志git log git log --stat 会显示哪些文件被修改 git log --pretty=oneline 会一行显示一条信息 git log --pretty=short 显示简短信息 git log --graph -pretty=oneline 画一个漂亮的历史 git diffgit diff不仅仅能查看两个文件的差别，也可以看两个branch的区别。 git diff anotherbranch + 表示本分支比anotherbranch分支多的，- 表示本分支少的 分布式工作流程如果要经常操作远程分支，可以定义缩写 git remote add myrepo /tmp/myrepo git pull 相当于两个操作：使用git fetch抓取最新的修改信息，然后git merge 为什么不需要指定远程仓库？ 因为Git把远程地址存到了配置文件的remote.origin.url git 也可以是服务器的地址： git clone ssh://服务器/账号/仓库名称 git push ssh://服务器仓库地址 master:master Git Tag轻量级标签git tag tagname 8c2940 git tag 标签对象git tag -a stable-2 8c315325 -m &quot;stable 2&quot; 签名标签签名标签可以让提交和标签更加完整可信 git ignore.gitignore 来忽略不需要提交的文件 123*.html!foo.html #foo.html例外*.[oa] #忽略所有.o .a 重置git reset --hard HEAD^ 回到上次提交的状态 git checkout -- hello.rb 恢复一个文件 git revert HEAD 撤销最近的一次提交 建设私有仓库ssh可以导出一个裸仓库，然后用scp命令拷贝到服务器上 12git clone --bare &#x2F;home&#x2F;user&#x2F;myrepo&#x2F;.git &#x2F;tmp&#x2F;myrepo.gitscp -r &#x2F;tmp&#x2F;myrepo.git myserver.com:&#x2F;opt&#x2F;git&#x2F;myrepo.git 对于其他人来说，直接 git clone myserver:com:/opt/git/myrepo.git","categories":[{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.difan.tech/tags/Git/"}]},{"title":"ubuntu 16.04 home挂载 系统重装","slug":"ubuntu 16.04 home挂载 系统重装","date":"2019-06-09T05:39:30.000Z","updated":"2021-03-29T06:12:00.882Z","comments":true,"path":"2019/06/09/ubuntu 16.04 home挂载 系统重装/","link":"","permalink":"https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/","excerpt":"Ubuntu 系统重装并挂载昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..","text":"Ubuntu 系统重装并挂载昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢….. linux分区 SWAP分区是LINUX暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为SWAP使用的分区不用指定“Mout Point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，一般来说它的大小是内存的一至两倍。另外你也可以创建和使用一个以上的交换分区，最多16个。 分区的原因为什么要自定义多个分区 在不损失数据的情况下重装系统，比如独立设置/home挂载点,重装系统的时候直接标记回/home，数据不会有任何损失。 针对不同挂载点的特性分配合适的文件系统以合理发挥性能，比如对/var使用reiserfs，对/home使用xfs，对/使用ext4。 针对不同的挂载点开启不同的挂载选项，如是否需要即时同步，是否开启日志，是否启用压缩。 大硬盘搜索范围大，效率低 磁盘配额只能对分区做设定 /home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片) （常见的挂载目录结构） / 根目录，存放系统命令和用户数据等（如果下面挂载点没有单独的分区，它们都将在根目录的分区中） /boot boot loader 的静态链接文件，存放与Linux启动相关的程序 /home 用户目录，存放普通用户的数据 /tmp 临时文件 /usr 是Linux系统存放软件的地方,如有可能应将最大空间分给它 /usr/local 自已安装程序安装在此 /var 不断变化的数据，服务器的一些服务、日志放在下面 /opt （Option可选的）附加的应用程序软件包 /bin 基本命令执行文 /dev 设备文件 /etc 主机特定的系统配置 /lib 基本共享库以及内核模块 /media 用于移动介质的挂载点 /mnt 用于临时挂载文件系统或者别的硬件设备（如光驱、软驱） /proc 系统信息的虚拟目录(2.4 和 2.6 内核)，这些信息是在内存中，由系统自己产生的 /root root 用户的目录 /sbin 基本系统命令执行文件 /sys 系统信息的虚拟目录(2.6 内核) /srv 系统提供的用于 service 的数据 /usr/X1186 X-Windows目录，存放一些X-Windows的配置文件 /usr/include 系统头文件，存储一些C语言的头文件 /usr/src Linux内核源代码，Linux系统所安装的内核源代码都保存在此 /usr/bin 对/bin目录的一些补充 /usr/sbin 对/sbin目录的一些补充 /lost+found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下 为什么会有挂载因为linux 下一切皆文件！换句说法就是linux操作系统将系统中的一切都作为文件来管理。在windows中我们常见的硬件设备（打印机、网卡、声卡…）、磁盘分区等，在linux中统统都被视作文件，对设备、分区的访问就是读写对应的文件。 linux挂载临时挂载123$ mount &#x2F;dev&#x2F;sda11 &#x2F;data ##sda3分区挂载在data目录下$ umount &#x2F;data ##卸载data目录下分区 &#x2F;dev&#x2F;sda11 &#x2F;data ##sda3分区挂载在data目录下$ umount &#x2F;data ##卸载data目录下分区 永久挂载：开机自动挂载需要修改/etc/fstab ) )​ Device By default, Ubuntu now uses UUID to identify partitions. 默认，Ubuntu用uuid识别分区 To list your devices by UUID use blkid 1sudo blkid 使用命令 fdisk -l 可以列出系统中当前连接的硬盘,设备和分区信息.新硬盘没有分区信息,则只显示硬盘大小信息. ) 可以先mkdir一个目录，比如new_dir，然后挂载分区： 1mount &#x2F;dev&#x2F;sda11 &#x2F;mnt&#x2F;new_dir 将所有东西全部cp到new_dir中 move原有的home 123cp &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;mv &#x2F;home &#x2F;old_home &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;mv &#x2F;home &#x2F;old_home 再mkdir一个新的home,将sda11再mount到home上 1mount &#x2F;dev&#x2F;sda11 &#x2F;home df -h查看硬盘大小和挂载情况 ) 最后根据要求，修改/etc/fstab 文件，注意格式要和其他保持一致，查看UUID可以用前文中说的方法。最后 1mount -a-a 这样就设置了fstab中的参数，设置完之后一定要看看生不生效，再继续操作","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.difan.tech/tags/ubuntu/"},{"name":"挂载","slug":"挂载","permalink":"https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/categories/C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DB","slug":"DB","permalink":"https://blog.difan.tech/categories/DB/"},{"name":"OS","slug":"OS","permalink":"https://blog.difan.tech/categories/OS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.difan.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/categories/Network/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/categories/C-C/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/categories/MATLAB/"},{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/categories/EE/"},{"name":"生活","slug":"生活","permalink":"https://blog.difan.tech/categories/%E7%94%9F%E6%B4%BB/"},{"name":"Tools","slug":"Tools","permalink":"https://blog.difan.tech/categories/Tools/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/categories/Linux/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.difan.tech/tags/C/"},{"name":"存储","slug":"存储","permalink":"https://blog.difan.tech/tags/%E5%AD%98%E5%82%A8/"},{"name":"RAID","slug":"RAID","permalink":"https://blog.difan.tech/tags/RAID/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.difan.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C/C++","slug":"C-C","permalink":"https://blog.difan.tech/tags/C-C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://blog.difan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"Network","slug":"Network","permalink":"https://blog.difan.tech/tags/Network/"},{"name":"分布式","slug":"分布式","permalink":"https://blog.difan.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.difan.tech/tags/Unix/"},{"name":"http","slug":"http","permalink":"https://blog.difan.tech/tags/http/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://blog.difan.tech/tags/MATLAB/"},{"name":"EE","slug":"EE","permalink":"https://blog.difan.tech/tags/EE/"},{"name":"减脂","slug":"减脂","permalink":"https://blog.difan.tech/tags/%E5%87%8F%E8%84%82/"},{"name":"运动营养","slug":"运动营养","permalink":"https://blog.difan.tech/tags/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"},{"name":"DSP","slug":"DSP","permalink":"https://blog.difan.tech/tags/DSP/"},{"name":"Math","slug":"Math","permalink":"https://blog.difan.tech/tags/Math/"},{"name":"SignalProcessing","slug":"SignalProcessing","permalink":"https://blog.difan.tech/tags/SignalProcessing/"},{"name":"tmux","slug":"tmux","permalink":"https://blog.difan.tech/tags/tmux/"},{"name":"vim","slug":"vim","permalink":"https://blog.difan.tech/tags/vim/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.difan.tech/tags/Linux/"},{"name":"随手记","slug":"随手记","permalink":"https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.difan.tech/tags/CentOS/"},{"name":"FirewallD","slug":"FirewallD","permalink":"https://blog.difan.tech/tags/FirewallD/"},{"name":"MicroSoft","slug":"MicroSoft","permalink":"https://blog.difan.tech/tags/MicroSoft/"},{"name":"Git","slug":"Git","permalink":"https://blog.difan.tech/tags/Git/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.difan.tech/tags/ubuntu/"},{"name":"挂载","slug":"挂载","permalink":"https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"}]}