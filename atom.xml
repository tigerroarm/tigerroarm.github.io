<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tigerroarm&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7880b27a93b174bc9a1cbe57a5bba5ff</icon>
  <subtitle>Stay naive, stay simple.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.difan.tech/"/>
  <updated>2022-02-19T12:19:49.417Z</updated>
  <id>https://blog.difan.tech/</id>
  
  <author>
    <name>Tigerroarm</name>
    <email>difanmu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统总结</title>
    <link href="https://blog.difan.tech/2022/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://blog.difan.tech/2022/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-02-19T12:19:49.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《modern operating systems&gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。</p></blockquote><h1 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1 进程和线程"></a>1 进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><ul><li>多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。</li></ul><span id="more"></span><p><strong>进程与程序的区别</strong>：<br>书中类比食谱和做饭的活动，食谱就是程序（program），而做饭的过程（读食谱，拿食材，做饭）就是进程的概念</p><p><strong>进程创建</strong></p><p>引起创建进程的事件：</p><ul><li>系统初始化</li><li>正在运行的进程执行了系统调用</li><li>用户请求创建进程</li><li>启动批处理作业(batch job),在大型机的批处理操作系统中</li></ul><p>在Linux中，只有一个系统调用可以创建新进程: fork.</p><p><strong>进程终止</strong></p><ul><li>正常退出</li><li>错误退出</li><li>严重错误退出</li><li>被其他进程kill</li></ul><p><strong>进程层次结构</strong></p><ul><li>一个进程只有一个父进程，但可以有0-N个子进程。</li><li>Unix是通过init进程进行初始化的</li><li>Windows在创建进程时，父进程得到子进程的句柄(handle)，但是handle可以传递，故没有进程层次结构的概念。</li></ul><p><strong>进程状态</strong></p><ul><li>运行态（正在使用CPU）</li><li>就绪态（可以运行）</li><li>阻塞态（不能运行，需要条件）</li></ul><p>阻塞状态可能是还没有得到运行的条件，例如在进程中读文件没有可用的输入时，就blocked。当万事俱备时，就可以转入就绪态等待进程调度。<br>从运行态到就绪态相互的过程是进程调度程序引起的，例如分时系统中时间到了就调度正在运行的程序进入就绪状态。</p><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>在具体的实现中，OS维持一张进程表：process table，每一个项成为进程控制块（process control block），包含了关于进程的重要信息：PC: program counter，栈指针，内存分配，打开文件的状态，调度信息等等。</p><p>如图所示，IO对于CPU利用率影响很大：<br><img src="/images/modern_os_assets/2.1.png" alt="image"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>为什么要有线程</li><li>线程实现</li></ul><p>内存是重要资源，操作系统的存储管理主要是针对内存的管理。</p><p>直接引入内存地址带来的问题（在multiprogramming 计算机中）：</p><ul><li>保护问题 protection</li><li>重定位问题（需要用到的地址未知） relocation</li></ul><p>保护问题IBM 360机是通过加入保护键解决的，重定位问题如果使用加入初始地址解决，但是会比较麻烦，因为要判断每个地址需不需要更改。</p><h2 id="地址空间：-一种存储器抽象"><a href="#地址空间：-一种存储器抽象" class="headerlink" title="地址空间： 一种存储器抽象"></a>地址空间： 一种存储器抽象</h2><p>每个进程有自己的地址空间，并且独立于其他进程。</p><ul><li>解决重定位问题：每个CPU配置两个特殊的寄存器，base 和 limit，分别对应物理空间的初始地址和长度（单位byte）。CPU会自动把base加载到进程发出的地址上，同时做界限检查</li></ul><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>把空闲进程存储在磁盘上，不过不够好，因为RAM和磁盘之间速度太低，swap一次时间很长，在后面的虚拟内存技术更好。</p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul><li>位图</li><li>空闲链表</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>问题：软件需要的内存更大</p><p>交换技术不是很好的解决方案，使用虚拟内存的方法更好（1961）：</p><ul><li>每个程序有自己的地址空间</li><li>地址空间分成多个块，每块称为页面（page）</li><li>每一个page映射到物理地址的page中</li><li>用到的时候再装入内存</li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>Paging技术：内存管理单元（MMU）把虚拟地址映射到物理内存地址。</p><p>虚拟地址空间分成以page大小的若干单元，在物理内存中对应的称为页框（page frame）。RAM和磁盘之间的交换是以页框为单位。 页号作为页表的索引，找到对应的页框号（实际物理地址）。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表：每一项标记了在/不再内存中和对应的页框号（对应的物理页框号）</p><p>页框号+页内偏移 = 真实物理地址</p><p>页表项</p><ul><li>页框号</li><li>在/不在位，不在就直接缺页中断</li><li>保护位</li><li>修改位，有时称为脏位（dirty bit）</li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul><li>加速虚拟地址到物理地址的转换<ul><li>TLB（快表）</li></ul></li><li>解决巨大的虚拟地址空间的问题<ul><li>多级页表</li><li>倒排页表</li></ul></li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>最优页面置换算法</li><li>NRU 算法（Not Recently Used， 最近未使用）<ul><li>想法：淘汰一个访问修改最少的页面</li></ul></li><li>FIFO<ul><li>最新进入的页面放表尾，最久进入的表头，当却也中断时淘汰表头（很少使用）</li></ul></li><li>second chance 算法（改进）<ul><li>最老页面的R位（访问位）如果是1，那么再给它一次机会，置零后放入队尾</li></ul></li><li>clock 算法<ul><li>避免经常在链表里移动页面</li><li>所有页面保存在一个环形链表里，表指针指向最老的页面</li><li>R=0，淘汰页面，新页面加入此地，之后移位，R=1就置零后移位</li></ul></li><li>LRU算法<ul><li>最近最少使用： 缺页中断发生时，置换未使用时间最长的页面</li><li>NFU时一种近似算法，性能不是很好，老化算法更接近LRU，更有效</li></ul></li></ul><p>文件是对disk的抽象，以名称存取</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>Case Sensitive<ul><li>Linux/UNIX</li></ul></li><li>Case Insensitive<ul><li>DOS</li></ul></li><li>Case Insensitive， Case Preserving<ul><li>Windows</li><li>Mac</li></ul></li></ul><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>三种文件结构：</p><p><img src="/images/modern_os_assets/file_structure.png" alt=""></p><p>a. 字节序列： UNIX，DOS，Windows采用<br>b. 记录序列：读操作返回一个记录，写操作重写或者追加一个记录，大型机常用<br>c.  记录树：树按照键字段进行排序，好处是可以针对特定的键进行快速查找</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件<ul><li>ASCII 文件</li><li>二进制文件</li></ul></li><li>目录文件</li><li>字符特殊文件（Unix）<ul><li>用于串行IO设备</li></ul></li><li>块特殊文件（Unix）<ul><li>用于磁盘类设备</li></ul></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p><img src="/images/modern_os_assets/file_att.png" alt=""></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>create</li><li>delete</li><li>open</li><li>close</li><li>read</li><li>write</li><li>append</li><li>seek</li><li>get attributes</li><li>set attributes</li><li>rename</li></ul><p>一个简单的复制文件的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个4096B的缓冲区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="comment">// 输出文件的保护位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_MODE 0700</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> in_fd, out_fd, rd_count, wt_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    in_fd = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 打开源文件</span></span><br><span class="line">    <span class="keyword">if</span> (in_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    out_fd = creat(argv[<span class="number">2</span>], OUTPUT_MODE); <span class="comment">//创建目标文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        rd_count = read(in_fd, buffer, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rd_count &lt;= <span class="number">0</span>) <span class="comment">// 文件结束或者读时出错，则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        wt_count = write(out_fd, buffer, rd_count);</span><br><span class="line">        <span class="keyword">if</span> (wt_count &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(in_fd);</span><br><span class="line">    close(out_fd);</span><br><span class="line">    <span class="keyword">if</span> (rd_count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《modern operating systems&amp;gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1 进程和线程&quot;&gt;&lt;/a&gt;1 进程和线程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。&lt;/p&gt;
&lt;h3 id=&quot;进程模型&quot;&gt;&lt;a href=&quot;#进程模型&quot; class=&quot;headerlink&quot; title=&quot;进程模型&quot;&gt;&lt;/a&gt;进程模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="https://blog.difan.tech/categories/OS/"/>
    
    
      <category term="操作系统" scheme="https://blog.difan.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构与算法代码</title>
    <link href="https://blog.difan.tech/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.difan.tech/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2022-02-19T12:42:07.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><p><a href="https://leetcode-cn.com/problems/sort-an-array/">lc 912</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 这样分 &lt;=j的元素都是小于x的值</span></span><br><span class="line">    <span class="keyword">int</span> x = a[l], i = l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">quick_sort(a, l, j);</span><br><span class="line">quick_sort(a, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (nums[++i] &lt; x);</span><br><span class="line"><span class="keyword">while</span> (nums[--j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) swap(nums[i], nums[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quick_sort(nums, l, j);</span><br><span class="line">quick_sort(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;<span class="comment">//版本2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l,  pivot = a[l], j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pivot) j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    a[i] = pivot;</span><br><span class="line">    quick_sort(a, l, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   swap(nums[l], nums[l + rand() % (r - l + <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pivot = nums[l], i = l, j = r;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums[i] = pivot;</span><br><span class="line">quick_sort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">quick_sort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="topK"><a href="#topK" class="headerlink" title="topK"></a>topK</h4><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">LC 215. 数组中的第K个最大元素</a></p><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int topK(int a[], int k, int l, int r) &#123;</span><br><span class="line">    if (l &gt;&#x3D; r) return a[l];</span><br><span class="line">  </span><br><span class="line">    int x &#x3D; a[ l + r &gt;&gt; 1], i &#x3D; l - 1, j &#x3D; r + 1;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        do i++; while (q[i] &lt; x);</span><br><span class="line">        do j--; while (q[j] &gt; x);</span><br><span class="line">        if (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; k - 1) return topK(a, k, j + 1, r);</span><br><span class="line">    else return topK(a, k, l, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><p><a href="https://leetcode-cn.com/problems/sort-an-array/">lc 912</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) &#123;</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge the two orded seq</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p1 = left, p2 = left2;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;  <span class="comment">// index for new array</span></span><br><span class="line">  <span class="keyword">int</span> tmp[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= right &amp;&amp; p2 &lt;= right2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[p1] &lt;= a[p2]) &#123;</span><br><span class="line">      tmp[index++] = a[p1++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[index++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store the rest array</span></span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= right) &#123;</span><br><span class="line">    tmp[index++] = a[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right2) &#123;</span><br><span class="line">    tmp[index++] = a[p2++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">    a[left + i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[left, right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    merge_sort(a, left, mid);</span><br><span class="line">    merge_sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(a, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： 不满足 | 满足</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： 满足 | 不满足</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;  </span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt;= x) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找&gt;=</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search_greatequ</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= x) &#123; <span class="comment">// if greater equal than x, modify here if &gt;</span></span><br><span class="line">      end = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) &#123;</span><br><span class="line">    vector&lt;int&gt; res;</span><br><span class="line">    r &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; A.size(); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        r &#x3D; r * 10 + A[i];</span><br><span class="line">        res.push_back(r &#x2F; b);</span><br><span class="line">        r %&#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    while (res.size() &gt; 1 &amp;&amp; res.back() &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">        res.pop_back();</span><br><span class="line">    &#125; </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.size() || i &lt; B.size(); i++) &#123;</span><br><span class="line">        if (i &lt; A.size()) t +&#x3D; A[i];</span><br><span class="line">        if (i &lt; B.size()) t +&#x3D; B[i];</span><br><span class="line">        C.push_back(t % 10);</span><br><span class="line">        t &#x2F;&#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (t) C.push_back(1);</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; my_minus(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) &#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0, t &#x3D; 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">        t &#x3D; A[i] - t;</span><br><span class="line">        if (i &lt; B.size()) t -&#x3D; B[i];</span><br><span class="line">        C.push_back((t + 10) % 10);</span><br><span class="line">        if (t &lt; 0)</span><br><span class="line">            t &#x3D; 1;</span><br><span class="line">        else</span><br><span class="line">            t &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        C.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b) &#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.size() || t; i++) &#123;</span><br><span class="line">        if (i &lt; A.size()) &#123;</span><br><span class="line">            C.push_back( (A[i] * b + t) % 10);</span><br><span class="line">            t &#x3D; (A[i] * b + t)&#x2F; 10;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            C.push_back(t % 10);</span><br><span class="line">            t &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">lc 560</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">s[i] = s[i<span class="number">-1</span>] + a[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i - j: s[j+1] - s[i + 1]</code></p><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p><a href="https://leetcode-cn.com/problems/merge-intervals/">lc 56</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">sort(intervals.begin(), intervals.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = INT_MIN; </span><br><span class="line"><span class="keyword">int</span> right = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; in : intervals) &#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt; in[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (left != INT_MIN) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line">left = in[<span class="number">0</span>];</span><br><span class="line">right = in[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = max(right, in[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right != INT_MIN) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/submissions/">LC 28</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>next[j-1]</code>的含义是跳了之后的下一个元素</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li>将两个集合合并</li><li>询问是否在一个集合当中</li></ul><p>近乎O(1)复杂度</p><p><strong>基本原理：</strong> 每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示x的父节点。</p><ul><li>树根 <code>if(p[x])==x</code></li><li>求x的集合编号 <code>while(p[x] != x) x=p[x];</code></li><li>合并两个集合：px 是x的集合编号，py是y的集合编号，<code>p[x]=y</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// 返回根节点并路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;  </span><br><span class="line">        p[x] = find(p[x]);  </span><br><span class="line"> &#125;  </span><br><span class="line">    <span class="keyword">return</span> p[x];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parent[x] != x) &#123;  </span><br><span class="line">parent[x] = parent[parent[x]]; </span><br><span class="line">x = parent[x];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// combine</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (find(a) == find(b)) <span class="keyword">return</span>;</span><br><span class="line">size[find(a)] += size[find(b)];</span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;<span class="comment">// store the tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) &#123; <span class="comment">// if empty</span></span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123; <span class="comment">// query the str appearance time</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stl, list</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">lst.push_back(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::find(l.begin(), l.end(), <span class="number">16</span>);</span><br><span class="line">lst.insert(it, <span class="number">42</span>); <span class="comment">// insert before 42</span></span><br></pre></td></tr></table></figure><p>数组</p><p>head存链表头，val存数值，next存下一个node的idx，idx表示当前用到了哪个（还没用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head = <span class="number">-1</span>, val[N], next[N], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">val[idx] = a, next[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = next[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>reverse <a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">LC reverse LL</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>, *ne = head;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ne = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = ne;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>存储结构<ul><li>开放寻址</li><li>拉链法</li></ul></li></ul><p>常见情景：$10^9$ 映射到$10^5$ 个数</p><h3 id="LRU-amp-amp-LFU"><a href="#LRU-amp-amp-LFU" class="headerlink" title="LRU &amp;&amp; LFU"></a>LRU &amp;&amp; LFU</h3><p>最近最少使用：溢出时淘汰最远的。<br><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></p><p>这里可以使用 <code>int min_freq</code> 存最小的理由是：</p><ul><li>如果一个item是freq最小的，且list只有它一个元素，那么freq+1就是最小的</li><li>如果新进的元素是最新的元素，那么 <code>min_freq = 1</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用双端链表+哈希表：</span></span><br><span class="line"><span class="comment">- 双端链表存每个key，value对</span></span><br><span class="line"><span class="comment">- 哈希表存key, 链表元素迭代器的映射</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">make_recently函数: 删掉key对应的list节点，并加到尾部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">get：</span></span><br><span class="line"><span class="comment">- 用哈希表查node，如果在就make_recently，返回value</span></span><br><span class="line"><span class="comment">- 如果不在return -1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">put:</span></span><br><span class="line"><span class="comment">- 用哈希表查node，如果在就make_recently，修改value</span></span><br><span class="line"><span class="comment">- 如果不在检查是否溢出，溢出就删除front()，加入最新的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; cache_map; <span class="comment">// key to list node</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q_list; <span class="comment">// key list</span></span><br><span class="line">    <span class="keyword">int</span> cap = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_map.find(key) != cache_map.end()) &#123; <span class="comment">// if find int the map</span></span><br><span class="line">            <span class="keyword">auto</span> lp = *cache_map[key];</span><br><span class="line">            make_recently(lp.first);</span><br><span class="line">            <span class="keyword">return</span> lp.second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if in the map</span></span><br><span class="line">        <span class="keyword">if</span> (cache_map.find(key) != cache_map.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lp = cache_map[key];</span><br><span class="line">            lp-&gt;second = value;</span><br><span class="line">            make_recently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// if not in the map</span></span><br><span class="line">        <span class="keyword">if</span> (cache_map.size() &gt;= cap) &#123;</span><br><span class="line">            delete_key(q_list.front().first);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        q_list.push_back(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        cache_map[key] = prev(q_list.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_recently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = delete_key(key);</span><br><span class="line">        q_list.push_back(<span class="built_in">make_pair</span>(key, val));</span><br><span class="line">        cache_map[key] = prev(q_list.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete_key</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itr = cache_map[key];</span><br><span class="line">        <span class="keyword">int</span> val = (*itr).second;</span><br><span class="line">        q_list.erase(itr);</span><br><span class="line">        cache_map.erase(key);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a><br>最不经常使用：溢出时淘汰频率最低的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _key = <span class="number">0</span>, <span class="keyword">int</span> _val = <span class="number">0</span>, <span class="keyword">int</span> _freq = <span class="number">0</span>) &#123;</span><br><span class="line">        value = _val;</span><br><span class="line">        key = _key;</span><br><span class="line">        freq = _freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;::iterator&gt; key_node_map;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;&gt; freq_node_map;</span><br><span class="line">    <span class="keyword">int</span> min_freq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        min_freq = <span class="number">0</span>;</span><br><span class="line">        key_node_map.clear();</span><br><span class="line">        freq_node_map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find in the key node</span></span><br><span class="line">        <span class="keyword">if</span> (key_node_map.find(key) != key_node_map.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l_itr =  key_node_map[key];</span><br><span class="line">            <span class="keyword">int</span> res_val = l_itr-&gt;value;</span><br><span class="line">            <span class="keyword">int</span> cur_freq = l_itr-&gt;freq;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update </span></span><br><span class="line">            freq_node_map[cur_freq].erase(l_itr);</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map[cur_freq].empty()) &#123;</span><br><span class="line">                freq_node_map.erase(cur_freq);</span><br><span class="line">                <span class="keyword">if</span> (cur_freq == min_freq) &#123;</span><br><span class="line">                    min_freq++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            freq_node_map[cur_freq + <span class="number">1</span>].push_front(Node(key, res_val, cur_freq + <span class="number">1</span>));</span><br><span class="line">            key_node_map[key] = freq_node_map[cur_freq + <span class="number">1</span>].begin();</span><br><span class="line">            <span class="keyword">return</span> res_val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key_node_map.find(key) != key_node_map.end()) &#123;</span><br><span class="line">            <span class="comment">// if find the key</span></span><br><span class="line">            <span class="keyword">auto</span> l_itr = key_node_map[key];</span><br><span class="line">            <span class="keyword">int</span> freq_put = l_itr-&gt;freq;</span><br><span class="line">            freq_node_map[freq_put].erase(l_itr);</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map[freq_put].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                freq_node_map.erase(freq_put);</span><br><span class="line">                <span class="keyword">if</span> (min_freq == freq_put) &#123;</span><br><span class="line">                    min_freq++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            freq_node_map[freq_put + <span class="number">1</span>].push_front(Node(key, value, freq_put + <span class="number">1</span>));</span><br><span class="line">            key_node_map[key] = freq_node_map[freq_put + <span class="number">1</span>].begin();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">         <span class="comment">// not find</span></span><br><span class="line">        <span class="keyword">if</span> (key_node_map.size() &gt;= cap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map.find(min_freq) != freq_node_map.end()) &#123;</span><br><span class="line">                <span class="comment">// remove the least frequently used  </span></span><br><span class="line">                <span class="keyword">int</span> min_key  = freq_node_map[min_freq].back().key;</span><br><span class="line">                freq_node_map[min_freq].pop_back();</span><br><span class="line">                key_node_map.erase(min_key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (freq_node_map[min_key].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq_node_map.erase(min_key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// min_freq no found</span></span><br><span class="line">                <span class="built_in">cerr</span> &lt;&lt;  <span class="string">&quot;Min Frequency No Found.&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add it</span></span><br><span class="line">        min_freq = <span class="number">1</span>;</span><br><span class="line">        freq_node_map[min_freq].push_front(Node(key, value, <span class="number">1</span>));</span><br><span class="line">        key_node_map[key] = freq_node_map[<span class="number">1</span>].begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>stack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">stk.push(<span class="number">10</span>);</span><br><span class="line">stk.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组实现</span></span><br><span class="line"><span class="keyword">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// top</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert to tail</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// front</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">LC 739. 每日温度</a><br><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode） (leetcode-cn.com)</a><br><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a><br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></p><p>本质上是可以暂存左边或者右边<strong>最近</strong>，<strong>符合要求的</strong>序列（一个递增序列），而对于离得比较远的还比最近还差的那就丢弃。<br>例如：</p><p>1 3 2 1 6 9 4 5 3 4 13</p><p>若输出左边第一个比它小的：<br>栈：</p><ul><li>先进1，然后进3，</li><li>2的时候比3小</li><li>3出栈，2进栈（对于后面2离得比3近并且比3小）</li><li>1：全部出栈，1进</li><li>6，9进栈</li><li>4：6，9出，4进栈</li><li>5：5进栈</li><li>3：5，4出栈</li><li>4：4进栈</li><li>13：13进栈</li></ul><p>此时：1，4，13，栈中始终都是按序排的，栈顶是最近最不满足的。</p><p><strong>Q  为什么要用栈？队列可以不可以</strong></p><p><strong>A</strong> ：栈FILO的特点能保留元素<em>离得最近</em>的一些值，也就是说pop出来的都是离$n[i]$ 最近的值，对于”第一个比它小的“，”第一个比它大的“这种问题非常合适。</p><p>N 数列，输出每个数字左边第一个比它小的数字，不存在则-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出每个数左边离它最近的比它大/小的数</span></span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line"><span class="comment">//输出结果，栈顶就是极值</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    stk[ ++ tt] = i; <span class="comment">// 保存i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ STL写法</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= vec.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!vec.empty() &amp;&amp; check(vec, sta, i)) &#123;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sta.push(vec[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树、图"><a href="#树、图" class="headerlink" title="树、图"></a>树、图</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>完全二叉树</p><ul><li>插入一个数 :<code>heap[++size] = x; up(size)</code> 放到最后一个，然后上移</li><li>求最小值: <code>heap[1]</code></li><li>删除最小值: 覆盖top， 然后down一遍 <code>heap[1] = heap[size]; size--; down(1)</code></li><li>删除任意一个元素 k : <code>heap[k] = heap[size]; size--; down(k); up(k)</code></li><li>修改任意一个元素: <code>heap[k] = x; down(k), up(k);</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = u;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * u &lt; size &amp;&amp; h[<span class="number">2</span> * u &lt; h[min]]) min = <span class="number">2</span> * u;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt; size &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span> &lt; h[min]]) min = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (min != u) &#123;</span><br><span class="line">swap(h[u], h[min]);</span><br><span class="line">down(min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u]) &#123; <span class="comment">// father node &gt; node u</span></span><br><span class="line">swap[h[u / <span class="number">2</span>], h[u]];</span><br><span class="line">u /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span>; i; i--) &#123;</span><br><span class="line">down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>邻接矩阵</li><li>邻接表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组表示邻接表</span></span><br><span class="line"><span class="keyword">int</span> head[N], val[M], next[M], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">val[idx] = b, next[idx] = head[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记visited</span></span><br><span class="line"></span><br><span class="line">dfs (node) &#123;</span><br><span class="line">visited[node] = <span class="literal">true</span>; <span class="comment">// 标记访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (neighbor of node) &#123;</span><br><span class="line"><span class="keyword">do</span> something;</span><br><span class="line"><span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">dfs(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/permutations/">全排列</a><br><a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a><br><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></p><p>深度优先搜索，一直走到头，边回去边看</p><ul><li>数据结构：stack</li><li>空间：<code>O(h)</code></li><li>优点：使用空间少</li><li>顺序</li></ul><p><strong>全排列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (idx == n) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;  </span><br><span class="line">            path[idx] = i + <span class="number">1</span>;  </span><br><span class="line">            visited[i] = <span class="literal">true</span>;  </span><br><span class="line">            dfs(idx + <span class="number">1</span>);  </span><br><span class="line">            visited[i] = <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>n 皇后问题</strong></p><p>用dg，udg记录对角线</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">res.push_back(cur_state);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!col[i] &amp;&amp; !dg[idx + i] &amp;&amp; !udg[n - idx + i]) &#123;</span><br><span class="line">cur_state[idx][i] = <span class="string">&#x27;Q&#x27;</span>; </span><br><span class="line">col[i] = dg[idx + i] = udg[n - idx + i] = <span class="literal">true</span>;</span><br><span class="line">dfs(idx + <span class="number">1</span>, n);</span><br><span class="line">col[i] = dg[idx + i] = udg[n - idx + i] = <span class="literal">false</span>;</span><br><span class="line">cur_state[idx][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>广度优先搜索</p><ul><li>数据结构：queue</li><li>空间 <code>O(2^h)</code></li><li>优点：最短路的概念</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;- initialize // 初始化<span class="built_in">queue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123; </span><br><span class="line">t&lt;-front();</span><br><span class="line">拓展 t 能到的所有邻居x</span><br><span class="line"><span class="keyword">if</span> (x 未被遍历)</span><br><span class="line"><span class="built_in">queue</span>&lt;-x;</span><br><span class="line">//<span class="keyword">do</span> sth 例如更新距离etc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即：</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[1] = <span class="literal">true</span>; </span><br><span class="line">q.push(1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.size())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != -1; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; </span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓扑序列：</strong></p><p>BFS的一种变体</p><p>思路：</p><pre><code>找其中度为0的点存队列，遍历邻居并删除边，过程中再找度为0的点即可。</code></pre><p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a><br><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></p><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><p><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a><br><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">1514. 概率最大的路径</a><br><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></p><ul><li>单源<ul><li>边权正数<ul><li>朴素Dijkstra算法 O(n^2) 适用稠密图</li><li>堆优化Dijkstra算法 O(mlogn) 适用稀疏图</li></ul></li><li>有负权边<ul><li>Bellman-Ford O(nm)</li><li>SPFA 一般 O(m)，最坏O(nm)</li></ul></li></ul></li><li>多源<ul><li>Floyd O(n^3)</li></ul></li></ul><p><strong>朴素Dijkstra算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. dist[1] &#x3D; 0, dist[0] &#x3D; +infinity</span><br><span class="line">2. for v : 0-n:</span><br><span class="line">t &lt;- 不在s中的距离最近的点 n*n</span><br><span class="line">t加到s里面去</span><br><span class="line">用t更新其他点的距离 m次</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 选中了一个点，故只需要n-1</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">//find min dist idx</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">t = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st[t] = <span class="literal">true</span>; <span class="comment">// add t to the S set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">dist[j] = min(dist[j], dist[t] + g[t][j]);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Dijkstra算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>]  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (heap.size()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// update </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; p : g[ver]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j  = p.first;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + p.second) &#123;</span><br><span class="line">                dist[j] = distance + p.second;</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == infinity) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bellman Ford 算法</strong><br>O(nm)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For n次</span><br><span class="line">For 所有边a, b, w</span><br><span class="line">dist[b] &#x3D; min(dist[b], dist[a] + w);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(bakcup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b= edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b] = min(dist[b], bakcup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SPFA算法</strong></p><ul><li><code>dist[x]</code> 最短距离 -&gt; 判断距离</li><li><code>cnt[x]</code> 边数<ul><li><code>cnt[x] &gt;= n</code>  存在负环 -&gt; 有负环</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;- 1</span><br><span class="line">while (queue不空)</span><br><span class="line">t &#x3D; queue pop</span><br><span class="line">更新 t 的所有出边 &#x2F;&#x2F; 我变小了，后继的点才能更新</span><br><span class="line">queue &lt;- b </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[min_idx] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : g[min_idx]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = p.first;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[min_idx] + p.second) &#123;</span><br><span class="line">                dist[j] = dist[min_idx] + p.second;</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Floyd算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><a href="https://leetcode-cn.com/problems/graph-valid-tree/">https://leetcode-cn.com/problems/graph-valid-tree/</a></p><ul><li>prim<ul><li>朴素版 O(n^2)</li><li>堆优化 O(mlogn)</li></ul></li><li>Kruskal 稀疏图<ul><li>O(mlogm)</li></ul></li></ul><p><strong>prim算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">dist[i] &lt;- inf</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">t&lt;- 集合外距离最近的点</span></span><br><span class="line"><span class="comment">用t更新其他点到集合的距离</span></span><br><span class="line"><span class="comment">将t加入集合</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (min_idx == <span class="number">-1</span> || dist[min_idx] &gt; dist[j])) &#123;</span><br><span class="line">                min_idx = j; <span class="comment">// 找到最近的点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[min_idx] == inf) <span class="keyword">return</span> inf; <span class="comment">// 图不连通  </span></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[min_idx];</span><br><span class="line">        st[min_idx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dist[j] = min(dist[j], g[min_idx][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>kruskal算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 将所有边按从小到大排序</span></span><br><span class="line"><span class="comment">2. 枚举每条边x, y, w</span></span><br><span class="line"><span class="comment">1. 如果x, y不连通</span></span><br><span class="line"><span class="comment">2. 加入集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)   <span class="comment">//不连通  </span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 连通a,b</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ; <span class="comment">// 加的边数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF; <span class="comment">//加的边数&lt;n-1，说明不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h4><p><a href="https://leetcode-cn.com/problems/possible-bipartition/">https://leetcode-cn.com/problems/possible-bipartition/</a> 判断二分图<br><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/</a></p><p>当且仅当图中不含奇数环（分成两个集合）</p><ul><li>判断是否二分图<ul><li>DFS染色法 O(n+m)</li><li>匈牙利算法 O(nm)  实际一般远小于</li></ul></li></ul><p><strong>染色法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!dfs(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>匈牙利算法</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><strong>分解质因数</strong> 求质数 时间复杂度$O(\sqrt(n))$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// i是质因数，s, 是次数, n中最多只包含一个大于sqrt(n)的质因子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) &#123; <span class="comment">// sqrt(n)</span></span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">n /= i;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>筛选质数(埃氏筛法) O(nloglogn)</strong><br>从小到大筛掉质数的倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt;= n; j += i) &#123;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性筛法</strong><br>n只会被最小质因子筛掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n/i; j++) &#123;</span><br><span class="line">st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j] 一定是i的最小质因子 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><strong>求约数</strong><br>枚举到 $\sqrt{n}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n/i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i; <span class="comment">//约数1</span></span><br><span class="line"><span class="keyword">if</span> (i != n / i) <span class="built_in">cout</span> &lt;&lt; n / i; <span class="comment">// 约数2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>约数个数</strong></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p><code>vector</code> 变长数组，倍增<br>    size()<br>    empty() 返回是否为空<br>    clear() queue就没有清空函数<br>    front(), back() 返回首尾的数<br>    pop_back(), push_back()<br>    begin()/end()<br>    []取地址<br>      支持比较运算： 按字典序比大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt; b;</span><br></pre></td></tr></table></figure><p><code>pair&lt;int, string&gt; p</code><br>    p.first 第一元素<br>    p.second 第二元素<br>    支持比较运算，第一个值为第一元素<br>    构造：<br>    <code>p = make_pair(10, &quot;asdf&quot;)</code><br>    <code>p = &#123;20, &quot;asdf&quot;&#125;</code> // C++11</p><p><code>string</code><br>    size()<br>    empty()<br>      substr(start_index, length), substr(start_index)<br>    c_str() 转为字符数组的起始位置 printf(“%s”, string_a.c_str())</p><p><code>queue</code><br>    push(), 队尾插入<br>    pop(),  对头弹出<br>    front()/back() 返回队头队尾元素</p><p><code>priority_queue</code>（堆）默认大跟堆<br>       top(), 返回堆头元素<br>    push(),  插入一个元素<br>    pop() 弹出堆头元素<br>     小跟堆 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code></p><p><code>stack</code><br>    push(),<br>    pop(),<br>    top();</p><p><code>deque</code> 加强版的vector，缺点是速度比较慢，比一般数组慢好几倍<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back(),  push_front()<br>    pop_back(), pop_front()<br>    begin()()/end()<br>    <code>[]</code></p><p><code>list</code> 链表<br>     size()<br>     empty()<br>     clear()<br>     push_front(), push_back()<br>     pop_back(), pop_front()<br>     insert(it, val)</p><p><code>set , map, multiset, multimap</code> 平衡二叉树<br>    size()<br>    empty()<br>    clear()<br>    begin()/end() ++ – O(logn)<br>    set/multiset  multiset 可以重复<br>            insert() 插入一个数<br>            find() 寻找一个数<br>            count()  返回某一个数的个数<br>            erase()<br>                    (5)输入是一个数字，删除所有x ：O(logn + k)<br>                    (iterator) 删除对应的元素<br>            lower_bound()/upper_bound()<br>                    lower_bound(x) 返回&gt;=x的最小的iterator<br>                    upper_bound(x) 返回&gt; x 的最小的数iterator<br>    map/multimap<br>            insert(pair&lt;A, B&gt;)<br>            erase() 输入pair或者迭代器<br>            find()<br>            <code>[]</code> 可以像用数组一样去用map，时间复杂度O(logn)<br>            lower_bound(x) 返回&gt;=x的最小的iterator<br>            upper_bound(x) 返回&gt; x 的最小的数iterator</p><p><code>unordered_set, unordered_map, unordered_multiset, unordered_multimap</code> 哈希表<br>    和上面类似，但是绝大部分操作的复杂度是O(1), 不支持lower_bound, upper_bound(), ++–迭代器</p><p><code>bitset</code> 压位 相比于bool数组省空间<br>    bitset&lt;1000&gt; s;<br>    ~ &amp; | ^<br>    &lt;&lt; &gt;&gt;<br>    == !=<br>    <code>[]</code><br>    count() 返回多少个1<br>    any() 判断是否至少有一个1<br>    none() 判断是否全为0<br>    set() 全设为1<br>    set(k, val), 第k位设为1<br>    reset() 全设为0<br>    flip() 全~<br>    flip(k)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;h3 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;lc 912&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 版本1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quick_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l &amp;gt;= r) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 这样分 &amp;lt;=j的元素都是小于x的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = a[l], i = l&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, j = r+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i &amp;lt; j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; i++; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (a[i] &amp;lt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; j--; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (a[j] &amp;gt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; j) swap(a[i], a[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(a, l, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(a, j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quick_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l &amp;gt;= r) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = l - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j = r + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = nums[l + r &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (nums[++i] &amp;lt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (nums[--j] &amp;gt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; j) swap(nums[i], nums[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(nums, l, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(nums, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;//版本2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quick_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l &amp;gt;= r) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = l,  pivot = a[l], j = r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; a[j] &amp;gt; pivot) j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i] = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; a[i] &amp;lt;= pivot) i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[j] = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a[i] = pivot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    quick_sort(a, l, i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    quick_sort(a, i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//版本3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quick_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;amp; nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l &amp;gt;= r) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   swap(nums[l], nums[l + rand() % (r - l + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pivot = nums[l], i = l, j = r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; nums[j] &amp;gt;= pivot) j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		nums[i] = nums[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;lt; j &amp;amp;&amp;amp; nums[i] &amp;lt;= pivot) i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		nums[j] = nums[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	nums[i] = pivot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(nums, l, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	quick_sort(nums, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;topK&quot;&gt;&lt;a href=&quot;#topK&quot; class=&quot;headerlink&quot; title=&quot;topK&quot;&gt;&lt;/a&gt;topK&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&quot;&gt;LC 215. 数组中的第K个最大元素&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.difan.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C/C++" scheme="https://blog.difan.tech/tags/C-C/"/>
    
      <category term="数据结构" scheme="https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://blog.difan.tech/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Gossip 算法</title>
    <link href="https://blog.difan.tech/2021/09/10/Gossip%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.difan.tech/2021/09/10/Gossip%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-09T16:00:00.000Z</published>
    <updated>2021-09-13T12:25:31.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gossip-算法"><a href="#Gossip-算法" class="headerlink" title="Gossip 算法"></a>Gossip 算法</h2><p>在一个有界网络中，每个node传播message给随机的几个节点，经过杂乱无章的通信，最终所有节点都会达成一致。每个节点有可能知道所有的节点，也可能仅仅知道几个邻居节点，最后状态都是一致的，又称为反熵。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可扩展性<ul><li>使用$O(\log N)$ rounds 到达所有nodes，N为node的个数。</li></ul></li><li>容错<ul><li>从源头节点到目的节点路径不止一条，可以在不规则为止连接性的网络中运行。</li></ul></li><li>健壮性<ul><li>故障节点不会阻止其他节点发送消息，每个节点都可以随意加入和退出，不会严重啊影响服务质量</li><li>但是如果消息有关于故障节点或者恶意节点，那么系统就不健壮</li></ul></li><li>收敛速度<ul><li>指数收敛速度</li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>两个概念</p><ul><li>Cycle 传播一个消息的轮数</li><li>Fanout 每轮种node通信的节点数</li></ul><ol><li>周期性散播消息</li><li>每轮随机选择fanout个节点散播消息</li><li>每轮散播消息都选择尚未发送过的节点进行散播</li><li>收到消息的节点不再往send节点散播</li></ol><blockquote><p>Goosip 和 raft<br>raft是强一致性的，而gossip是最终一致</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>Riak 使用gossip协议分享并通信ring state和bucket properties</li><li>CASSANDRA 分享周围nodes和自己的信息</li><li><a href="https://github.com/hashicorp/serf">serf</a>：go实现的服务发现和治理的框架</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Gossip-算法&quot;&gt;&lt;a href=&quot;#Gossip-算法&quot; class=&quot;headerlink&quot; title=&quot;Gossip 算法&quot;&gt;&lt;/a&gt;Gossip 算法&lt;/h2&gt;&lt;p&gt;在一个有界网络中，每个node传播message给随机的几个节点，经过杂乱无章的通信
      
    
    </summary>
    
    
      <category term="Network" scheme="https://blog.difan.tech/categories/Network/"/>
    
    
      <category term="Network" scheme="https://blog.difan.tech/tags/Network/"/>
    
      <category term="分布式" scheme="https://blog.difan.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>POSIX thread</title>
    <link href="https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2022-02-19T12:14:55.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POSIX-thread"><a href="#POSIX-thread" class="headerlink" title="POSIX thread"></a>POSIX thread</h1><blockquote><p>Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。</p></blockquote><p>POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。</p><ul><li>多处理器用多线程：效果最好</li><li>单处理器使用多线程： 也有增益（一个线程等IO，另外的执行）</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>多任务同时进行</li><li>阻止潜在的长时间IO等待</li><li>一些地方很多CPU周期</li><li>必须响应异步</li><li>优先级中断</li></ul><span id="more"></span><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程共享模型"><a href="#线程共享模型" class="headerlink" title="线程共享模型"></a>线程共享模型</h3><p>所有线程都可以访问相同的全局共享内存,但是也有自己的私有数据。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>由多个线程共享资源引起的，如果例程没有使用某种类型的同步结构来防止数据损坏，那么它就不是线程安全的。</p><h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>依赖于具体实现（我的WSLunlimit -Hu）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tigerroarm@Mudifan:~$ <span class="built_in">ulimit</span> -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 50633</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 50633</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>线程共享如下资源</p><ul><li>进程指令（ Process instructions）</li><li>大部分数据</li><li>文件描述符</li><li>signals 和 signal handlers</li><li>当前目录</li><li>User 和 group id</li></ul><p>每个线程独立有：</p><ul><li>Tread ID </li><li>registers, stack pointer集合</li><li>local variables, return addresses 栈 </li><li>signal mask</li><li>priority</li><li>Return value: <code>errno</code></li></ul><p>pthread 如果OK会return 0</p><p>编译程序需要用：</p><p><code>gcc -pthread thread_program.c</code></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> * thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>thread : 返回的thread ID</li><li>attr: 使用默认thread 就NULL</li><li>start_routine: 需要线程运行的函数</li><li>arg: 函数参数</li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>thread 库提供了三种同步机制</p><ul><li>互斥（mutexes）:互斥锁（mutual exclusion lock）</li><li>joins: 等待其他进程完成</li><li>条件变量: pthread_cond_t</li></ul><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex:"></a>mutex:</h3><p>用<code>pthread_mutex_lock</code>和<code>pthread_mutex_unlock</code>加锁解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">functionC</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span>  counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> rc1, rc2;</span><br><span class="line">   <span class="keyword">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create independent threads each of which will execute functionC */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( (rc1=pthread_create( &amp;thread1, <span class="literal">NULL</span>, &amp;functionC, <span class="literal">NULL</span>)) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed: %d\n&quot;</span>, rc1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( (rc2=pthread_create( &amp;thread2, <span class="literal">NULL</span>, &amp;functionC, <span class="literal">NULL</span>)) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed: %d\n&quot;</span>, rc2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Wait till threads are complete before main continues. Unless we  */</span></span><br><span class="line">   <span class="comment">/* wait we run the risk of executing an exit which will terminate   */</span></span><br><span class="line">   <span class="comment">/* the process and all threads before the threads have completed.   */</span></span><br><span class="line"></span><br><span class="line">   pthread_join( thread1, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_join( thread2, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">functionC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pthread_mutex_lock( &amp;mutex1 );</span><br><span class="line">   counter++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Counter value: %d\n&quot;</span>,counter);</span><br><span class="line">   pthread_mutex_unlock( &amp;mutex1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h3><p>等待线程完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span>  counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> thread_id[NTHREADS];</span><br><span class="line">   <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      pthread_create( &amp;thread_id[i], <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; NTHREADS; j++)</span><br><span class="line">   &#123;</span><br><span class="line">      pthread_join( thread_id[j], <span class="literal">NULL</span>); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Now that all threads are complete I can print the final result.     */</span></span><br><span class="line">   <span class="comment">/* Without the join I could be printing a value before all the threads */</span></span><br><span class="line">   <span class="comment">/* have been completed.                                                */</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *dummyPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Thread number %ld\n&quot;</span>, pthread_self());</span><br><span class="line">   pthread_mutex_lock( &amp;mutex1 );</span><br><span class="line">   counter++;</span><br><span class="line">   pthread_mutex_unlock( &amp;mutex1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h3><h4 id="为什么需要条件变量"><a href="#为什么需要条件变量" class="headerlink" title="为什么需要条件变量"></a>为什么需要条件变量</h4><p>使用互斥锁的时候，如果有一个下面的情况</p><ul><li>线程1: 如果有变化，就把本地buff save 到cloud上</li><li>线程2：改本地buff，标记变化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(lock); </span><br><span class="line">    <span class="keyword">if</span>(is_change) &#123;</span><br><span class="line">        save_to_cloud(buff);</span><br><span class="line">        is_change = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> = tmp[<span class="number">50</span>];</span><br><span class="line">    read(tmp, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(lock);</span><br><span class="line">    <span class="built_in">strcpy</span>(buff, tmp);</span><br><span class="line">    is_change = <span class="literal">true</span>;</span><br><span class="line">    pthead_mutex_unlock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候is_change 一直是false， 那么thread1一直在执行循环。</p><p>想达到的目的是：<strong>直到某个状态改变，才开始执行</strong></p><p>需要的是<em>lock+condition</em></p><p>就需要有条件变量</p><blockquote><p>互斥锁通过控制线程对数据的访问来实现同步，而条件变量允许线程根据数据的实际值进行同步。如果没有条件变量，程序员将需要线程持续轮询(可能在关键部分) ，以检查条件是否满足。这可能会非常消耗资源，因为线程在此活动中将持续忙碌。条件变量是一种不用轮询就可以实现相同目标的方法。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>主线程：<ul><li>声明和初始化需要同步的<strong>全局数据/变量</strong>(例如“ count”)</li><li>声明和初始化<strong>条件变量对象</strong></li><li>声明并初始化一个的<strong>互斥锁</strong> </li><li>创建线程 a 和 b 来做工作</li></ul></li><li>线程A<ul><li>一直工作到某个条件必须发生的点(例如“ count”必须达到指定的值)</li><li>锁住互斥锁，然后检查值</li><li><strong>pthread_cond_wait()</strong> ，阻塞等待来自B线程信号（自动解锁相关的互斥锁）</li><li>当收到信号时就唤醒进程</li></ul></li><li>线程B<ul><li>锁住互斥锁</li><li>更改线程A正在等待的全局变量的值</li><li>检查全局变量的值，如果满足条件，给A发信号</li><li>解锁互斥锁</li></ul></li></ul><h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><ul><li><p><code>pthread_cond_wait()</code> 阻塞线程直到条件达到</p></li><li><p><code>pthread_cond_init</code></p><ul><li><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></li></ul></li><li><p>pthread_cond_signal()：唤醒另一个等待条件变量的信号</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">Linux Tutorial: POSIX Threads (cmu.edu)</a></li><li><a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html">Multi-Threaded Programming With POSIX Threads (kent.edu)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;POSIX-thread&quot;&gt;&lt;a href=&quot;#POSIX-thread&quot; class=&quot;headerlink&quot; title=&quot;POSIX thread&quot;&gt;&lt;/a&gt;POSIX thread&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多处理器用多线程：效果最好&lt;/li&gt;
&lt;li&gt;单处理器使用多线程： 也有增益（一个线程等IO，另外的执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多任务同时进行&lt;/li&gt;
&lt;li&gt;阻止潜在的长时间IO等待&lt;/li&gt;
&lt;li&gt;一些地方很多CPU周期&lt;/li&gt;
&lt;li&gt;必须响应异步&lt;/li&gt;
&lt;li&gt;优先级中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.difan.tech/categories/C-C/"/>
    
    
      <category term="多线程" scheme="https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Unix" scheme="https://blog.difan.tech/tags/Unix/"/>
    
      <category term="C/C++" scheme="https://blog.difan.tech/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议</title>
    <link href="https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-09-05T16:51:51.442Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（HTTP协议）</p><p>特点：</p><ul><li>简单</li><li>易解析</li><li>可读性好</li></ul><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC 2616 Link (HTTP 1.1)</a></p><span id="more"></span><h2 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h2><ul><li>HTTP/1.1 : 1999年 RFC 2616，还有RFC7230。目前少于三分之一的网站使用（包括其和其早期版本）。<ul><li>1.1相比于1.0：使用一个TCP连接可以传多个HTTP request/response（引入keep-alive-mechanism，<strong>HTTP长连接</strong>）， client不需要在发送第一个请求后重新协商 TCP 3-Way-Handshake 连接。</li><li>1.1相比于1.0：带宽优化：使用了<strong>分块传输编码</strong>（Chunked transfer encoding）的流式传输机制，即把内容分块（Chunk）进行流式传输</li></ul></li><li>HTTP/2.0 : 2015年，超过一半的网站使用，以谷歌的SPDY为基础开始指定的新版本HTTP协议，RFC 7540.</li><li>HTTP/3.0 : HTTP over QUIC，18%网站使用，使用UDP作为底层传输协议</li></ul><h2 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h2><p>HTTP Request 是client端向server端做的一个请求。</p><p>包括：</p><ul><li>一个请求行： <code>GET /images/logo.png HTTP/1.1</code></li><li>请求头：<code>Accept-Language: en</code>  <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Link</a><ul><li><code>Accept-Language: en</code></li><li><code>Accept-Ranges: type</code>：指定bytes可以作为一个单位去定义一个range，如果是<code>none</code>则表示不支持partial request。</li></ul></li><li>空行</li><li>HTTP 消息正文( message body) : 可选</li></ul><p>请求行和其他头字段必须以 <code>&lt;CR&gt;&lt;LF&gt;</code>结尾，空行只包括 <code>&lt;CR&gt;&lt;LF&gt;</code>且无空格</p><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><ul><li>GET （1.0）</li><li>HEAD（1.0） ：除了没有响应体外（Response body）与 GET 请求相同，可以用于检索</li><li>POST （1.0） ：请求服务器接收包括的entity </li><li>OPTIONS（1.1） ： 返回某个URL支持的HTTP 方法</li><li>PUT （1.1）： 请求服务器将entity的保存在URI下（如果存在则修改，不存在则新建）</li><li>DELETE（1.1） ：删除</li><li>TRACE （1.1） ： 回复收到的请求，client知道server做了什么改动，由于XST攻击建议关闭</li><li>CONNECT （1.1）: 用于proxy较多</li></ul><table><thead><tr><th align="center">HTTP method</th><th align="center">RFC</th><th align="center">Request has Body</th><th align="center">Response has Body</th><th align="center">Safe</th><th align="center">Idempotent</th><th align="center">Cacheable</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">HEAD</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">POST</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">PUT</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">DELETE</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">CONNECT</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">No</td></tr><tr><td align="center">OPTIONS</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">TRACE</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">PATCH</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc5789">5789</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">No</td></tr></tbody></table><p>表格来自[1]</p><h2 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h2><ul><li>状态行 ：<code>HTTP/1.1 200 OK</code></li><li>响应头： <code>Content-Type: text/html</code></li><li>空行</li><li>消息体</li></ul><h3 id="状态码（status-code）"><a href="#状态码（status-code）" class="headerlink" title="状态码（status code）"></a>状态码（status code）</h3><ul><li>信息 1XX</li><li>成功 2XX 200 OK</li><li>重定向Redirection 3XX </li><li>Client Error 4XX</li><li>Server Error 5XX</li></ul><p>几个常见的状态码：</p><ul><li>206 : Partial Content</li><li>200: OK</li><li>404: Not Found </li><li>500: Internal Server error</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 23 May 2005 22:38:34 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>155</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 08 Jan 2003 23:11:55 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.3.7 (Unix) (Red-Hat/Linux)</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;3f80f-1b6-3e1cb03b&quot;</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;An Example Page&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p><p>[2] <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a></p><p>[3] <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">https://www.w3.org/Protocols/rfc2616/rfc2616.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（HTTP协议）&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;易解析&lt;/li&gt;
&lt;li&gt;可读性好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;RFC 2616 Link (HTTP 1.1)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Network" scheme="https://blog.difan.tech/categories/Network/"/>
    
    
      <category term="http" scheme="https://blog.difan.tech/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB编程指北</title>
    <link href="https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/"/>
    <id>https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-23T12:46:24.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><!-- toc --><ol><li>折叠<ul><li>ctrl = 折叠代码</li><li>shift ctrl  =展开代码</li></ul></li><li>缩进整理 ctrl i（==全选+ctrl i==）</li><li>跳转到第几行 ctrl g</li><li>F5运行，F10 debug，shift+F5 退出Debug模式</li><li>doc 取代help，直接跳出文档（由于外网，网络可能不稳定）</li></ol><a id="more"></a><h1 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h1><ul><li>注意，MATLAB所有序号都是==从1开始==</li><li>MATLAB中 ==Class Array== 的思想随处不在<ul><li>例如对于<code>a = 54</code>，使用<code>whos</code>命令可以看到，MATLAB认为这是一个Size 1×1 8 Bytes的double array，==而非一个简单的double变量==。</li><li>再例如，<code>str1 =&quot;string&quot;</code>，是一个Size 1×1的，150 Bytes的Class为String的Array变量。也就是说，<em>你完全可以直接str1(2) = “string2”</em>，这种操作被理解为在<code>str1</code>这个string array变量中增加了一个元素。</li><li>同样的，<code>char = &#39;char&#39;</code>是定义了一个Size 1×4的，Bytes为8的 Class 为 char的Array变量。</li></ul></li><li>使用<code>%%</code> <code>%</code>来区分不同Block的代码是一种好方法</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>double </li><li>single（单精度）</li><li>logical</li><li>int8(1B 8bit)</li><li>int16</li><li>int32</li><li>int64</li><li>uint8</li><li>char(‘’)</li><li>string(“”)</li><li>NaN(Not a Number)</li><li>Inf(无穷)：有正负之分</li><li>cell</li><li>struct</li><li>function_handle</li><li><class_name></li></ul><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><ul><li><code>flipud(M)</code>: 翻转矩阵，从下面往上反转</li><li><code>fliplr</code>：左右翻转</li><li><code>flip([])</code>： 翻转向量，矩阵的话和ud一样</li><li><code>repmat(A, 2, 3)</code>：横向重复两次，纵向3次</li><li><code>repelem(A, 2, 3)</code>：repeat element 原来矩阵每个元素都2×3，重新组成新的</li><li><code>max(A)</code>:每列中最大的元素</li><li><code>diff()</code>: 每次相邻两个元素之间做差</li><li><code>prod()</code> :返回数组乘积</li><li><code>cumsum()</code>：返回前n个元素的和<ul><li><code>cumprod()</code></li><li><code>cummin()</code></li><li><code>cummax()</code></li></ul></li><li><code>linspace(x1,x2,n)</code> ：产生n个x1到x2的数据，间隔(x2-x1)/(n-1)<ul><li><code>logspace(x1,x2,n)</code>： 产生n个$$10^{x1}$$到x2的数据</li></ul></li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li><code>find(logical_vector, k, &#39;first&#39;)</code> ：首k个true值</li><li><code>any(logical_vector)</code></li><li><code>all(logical_vector)</code></li></ul><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ul><li><p>线颜色</p><ul><li>b : blue</li><li>g : green</li><li>r : red</li><li>c : cyan 青蓝色</li><li>m : magenta 品红色</li><li>y : yellow</li><li>k ：black</li><li>w ：white</li></ul></li><li><p>线样式</p><ul><li><code>--</code> 段虚线</li><li><code>:</code> 点虚线</li><li><code>-.</code> 段点虚线</li><li>marker<ul><li><code>*-.</code> *为marker</li><li><code>o</code> </li><li><code>.</code></li><li><code>x</code> </li><li><code>s</code> square 方块</li><li><code>d</code> 菱形</li><li><code>v</code></li><li><code>^</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>p</code> 五角形</li><li><code>h</code> 六角形</li></ul></li></ul></li><li><p><code>close all</code> 关闭所有的figure</p></li><li><p><code>clf</code> 清空当前画布 clear current figure </p><ul><li>还有<code>cla</code>，清空坐标区 </li></ul></li><li><p><code>subplot(row, col, n_th)</code> </p></li><li><p><code>grid on</code> 网格</p></li><li><p><code>legend()</code> 图例</p></li><li><p><code>xlabel(&#39;&#39;)</code> <code>ylabel(&#39;&#39;)</code> <code>title(&#39;&#39;)</code></p><ul><li>如果要LaTeX显示，需要在后面的<code>&#39;Interpreter&#39;</code>设置为<code>&#39;latex&#39;</code><ul><li>例如  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title([<span class="string">&#x27;Predictive signal $\hat&#123;d&#125;(n)$ and orignal signal $d(n)$ with p=&#x27;</span>,num2str(p)],<span class="string">&#x27;Interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>plot</code>修饰</p><ul><li><code>color+marker+line_shape</code>, e.g. <code>&#39;ro-.&#39;</code></li><li><code>LineWidth</code> 默认为1</li><li><code>MarkerEdgeColor</code> Marker边缘的颜色</li><li><code>MakerFaceColor</code> Marker里面的颜色 </li></ul></li><li><p><code>axis([x1 x2 y1 y2])</code> 设置坐标轴范围</p></li></ul><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><ul><li><code>strlength(&quot;string&quot;)</code>： 字符串长度</li><li>string 类型可以通过<code>&#123;&#125;</code>的方式提取出char类型结果，例如可以通过<code>string&#123;1&#125;(2)</code>提取出第一个string中的第二个char</li><li><code>input(&#39;Some suggestion string:&#39;,&#39;s&#39;)</code> 输入的是char类型</li><li><code>Upper</code>，全部大写</li><li><code>strcmp(str1, str2, num)</code>，前num位的字符是否相同</li><li><code>strfind(text, pattern)</code> 找text中pattern 的位置</li><li><code>strsplit(text, pattern)</code> split 字符串</li></ul><h2 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h2><ul><li><code>&#123;48, &quot;uui&quot;, 1:4:9&#125;</code></li><li>访问使用{index} {1,2}</li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><code>S = struct(&#39;field1&#39;,VALUES1,&#39;field2&#39;,VALUES2,...)</code></li></ul><h2 id="保存加载"><a href="#保存加载" class="headerlink" title="保存加载"></a>保存加载</h2><ul><li><code>save testfile.dat mydata -ascii</code> save 文件名 变量名</li><li><code>load file_name.dat</code> </li></ul><h2 id="可变长输入输出"><a href="#可变长输入输出" class="headerlink" title="可变长输入输出"></a>可变长输入输出</h2><ul><li>varargin{1}： variable argument input, cell 类型，存储输入参数</li><li>nargin 输入参数个数</li><li>varargout 输出参数    </li><li>nargout 输出个数</li></ul><h2 id="本地函数和嵌套函数"><a href="#本地函数和嵌套函数" class="headerlink" title="本地函数和嵌套函数"></a>本地函数和嵌套函数</h2><ul><li>本地函数，单个m文件中定义的函数，作用域为整个m文件</li><li>嵌套函数（可以使用所有外层函数定义的量）</li></ul><h2 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h2><ul><li>function_handle，为一个单独的数据类型</li><li>使用 func_han = @(argm1, argm2) argm1*argm2; 即可定义手柄</li><li>func2str(func_hndl);得到函数名字</li><li>相关函数<ul><li><code>fplot(@sin(), [0, 2*pi])</code></li><li><code>feval(@sin(), 0:0.1:1)</code> 返回每个值对应的函数输出</li><li><code>timeit(func_handle)</code>，算函数计算的时间<h2 id="通信相关"><a href="#通信相关" class="headerlink" title="通信相关"></a>通信相关</h2></li></ul></li></ul><h3 id="qammod"><a href="#qammod" class="headerlink" title="qammod"></a>qammod</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ModDataTX = qammod(BinData, MOD, <span class="string">&#x27;InputType&#x27;</span>, <span class="string">&#x27;bit&#x27;</span>, <span class="string">&#x27;PlotConstellation&#x27;</span>,<span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 对于输入bit 流进行 QAM调制，MOD是调制阶数，InputType指定输入类型</span></span><br></pre></td></tr></table></figure><p>注意 matlab中 vector’ 如果是vector复数向量，就算的直接是共轭转置，这个被坑过，如果想只转置可以用 vector.’</p><h3 id="berfading"><a href="#berfading" class="headerlink" title="berfading"></a>berfading</h3><p>估计fading时的性能，参数是SNR，调制方式，调制模，复用参数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EbNo = <span class="number">8</span>:<span class="number">2</span>:<span class="number">20</span>; <span class="comment">% Eb/N0</span></span><br><span class="line">ber = <span class="built_in">zeros</span>(<span class="built_in">length</span>(EbNo),<span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> L = <span class="number">1</span>:<span class="number">20</span> </span><br><span class="line">    ber(:,L) = berfading(EbNo,<span class="string">&#x27;qam&#x27;</span>,<span class="number">16</span>,L); <span class="comment">% 16 QAM</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">semilogy(EbNo,ber,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">text(<span class="number">18.5</span>, <span class="number">0.02</span>, sprintf(<span class="string">&#x27;L=%d&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">text(<span class="number">18.5</span>, <span class="number">1e-11</span>, sprintf(<span class="string">&#x27;L=%d&#x27;</span>,<span class="number">20</span>))</span><br><span class="line">title(<span class="string">&#x27;QAM over fading channel with diversity order 1 to 20&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;E_b/N_0 (dB)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><p><img src="https://www.mathworks.com/help/examples/comm/win64/EstimateBERPeformanceOf16QAMInFadingExample_01.png" alt="image"></p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p><code>rng(&#39;shuffle&#39;)</code>来使用当前时间作为随机数种子</p><h3 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h3><p>0-1 随机数</p><h3 id="randi"><a href="#randi" class="headerlink" title="randi"></a>randi</h3><p>伪随机整数</p><p>X = randi([imin,imax],size_1,size_2)</p><p>X = randi(imax,sz1,…,szN)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">randi([<span class="built_in">min</span> <span class="built_in">max</span>], row_number, col_number);</span><br><span class="line"><span class="comment">% e.g.</span></span><br><span class="line">randi([<span class="number">0</span> <span class="number">10</span>], <span class="number">1000</span>, <span class="number">1</span>); <span class="comment">% Generate 1000✖1 random vector with range from 0 to 10</span></span><br></pre></td></tr></table></figure><h3 id="randn"><a href="#randn" class="headerlink" title="randn"></a>randn</h3><p>randn生成正态分布随机数</p><p>X = randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。</p><p>X = randn(sz1,…,szN) 返回由随机数组成的 sz1×…×szN 数组，其中 sz1,…,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。</p><p>X = randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用技巧&quot;&gt;&lt;a href=&quot;#常用技巧&quot; class=&quot;headerlink&quot; title=&quot;常用技巧&quot;&gt;&lt;/a&gt;常用技巧&lt;/h1&gt;&lt;!-- toc --&gt;

&lt;ol&gt;
&lt;li&gt;折叠&lt;ul&gt;
&lt;li&gt;ctrl = 折叠代码&lt;/li&gt;
&lt;li&gt;shift ctrl  =展开代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缩进整理 ctrl i（==全选+ctrl i==）&lt;/li&gt;
&lt;li&gt;跳转到第几行 ctrl g&lt;/li&gt;
&lt;li&gt;F5运行，F10 debug，shift+F5 退出Debug模式&lt;/li&gt;
&lt;li&gt;doc 取代help，直接跳出文档（由于外网，网络可能不稳定）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MATLAB" scheme="https://blog.difan.tech/categories/MATLAB/"/>
    
    
      <category term="MATLAB" scheme="https://blog.difan.tech/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>Inband Full-duplex Wireless Communication System</title>
    <link href="https://blog.difan.tech/2021/01/02/fullduplex/"/>
    <id>https://blog.difan.tech/2021/01/02/fullduplex/</id>
    <published>2021-01-01T16:00:00.000Z</published>
    <updated>2022-02-19T12:19:58.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-Band<br>Full-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。</p><span id="more"></span><h2 id="主要想法"><a href="#主要想法" class="headerlink" title="主要想法"></a>主要想法</h2><p>要实现全双工，主要就是减少自干扰（self-interference），即同一设备发射的信号对于接收信号的干扰。WiFi信号的平均功率为20dBm（100mW），接收机的噪声基底（noise<br>floor）大致为-90dBm，所以要将自干扰降低到-90dBm，需要降低110dB的线性抵消能力。</p><p>对于非线性自干扰（Harmonics），其为-10dBm（比基底高80dB），即需要80dB的非线性抵消能力。</p><p><img src="/images/media/c45cb054af14da46a727521c6b3ac8de.png" alt=""></p><p><strong>图 1</strong> 抵消目标[1]</p><p>图1中，我们看到，SIC中线性分量是主要分量，发射机噪声为-40dBm，由于OFDM的PAPR特性所以我们需要预留10dB，即模拟域需要提供60dB的消除能力。</p><h2 id="自干扰分析"><a href="#自干扰分析" class="headerlink" title="自干扰分析"></a>自干扰分析</h2><p>在WiFi场景下，自干扰主要有以下三种（如图1所示）</p><ul><li>天线与环行器阻抗不匹配导致的反射分量 RA</li><li>环行器1端口到3端口的泄露分量 I</li><li>环境散射分量RC</li></ul><p><img src="/images/media/4685cb8996f44b2128c3c41a1981c02c.png" alt=""></p><p><strong>图 2</strong> 自干扰分析图</p><h2 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h2><h3 id="4-1-天线隔离"><a href="#4-1-天线隔离" class="headerlink" title="4.1 天线隔离"></a>4.1 天线隔离</h3><ul><li>环行器 Circulator（大部分的方法）</li><li>电平衡 EBD (×)</li></ul><h3 id="4-2-RF域（模拟域）干扰抵消"><a href="#4-2-RF域（模拟域）干扰抵消" class="headerlink" title="4.2 RF域（模拟域）干扰抵消"></a>4.2 RF域（模拟域）干扰抵消</h3><h4 id="4-2-1-IMT-方法（RF-front）-2"><a href="#4-2-1-IMT-方法（RF-front）-2" class="headerlink" title="4.2.1 IMT 方法（RF front）[2]"></a>4.2.1 IMT 方法（RF front）[2]</h4><p>I和RA因为没有路径损耗，具有主要的能量，是我们在模拟域/RF域主要需要抵消的信号。RC由于其环境反射特性可以在数字域建模消除。</p><p>使用IMT网络控制RA的振幅和相位，直接抵消I。</p><p>根据计算得到反射系数结果：</p><p><img src="/images/media/99ae3ce95c644451471721ac19aabd59.png" alt=""></p><p>S为端之间的回波损耗。</p><p><img src="/images/media/d4d66762a16d084a48221bf39bbb108d.emf" alt=""></p><p>上图具有并联和串联变容二极管的可重配置IMT电路的示意图，可以通过调整Vs，Vp来调整Zin。</p><p>ZL是天线输入阻抗，根据反射系数定义，可以得到：</p><p><img src="/images/media/74e6cba8d12936066cf3668c3f988b41.png" alt=""></p><p>Z0是环行器器2端口的特性阻抗。</p><p><strong>实验部分：</strong></p><p>用了RFCI CR5853环行器，15.5dB固有隔离度。Skyworks Inc的可变容二极管SMV 2019</p><p>结果：</p><p><img src="/images/media/a8d08156add47aa647e04dbec788b785.png" alt=""></p><p><strong>图3</strong> IMT结果</p><h4 id="4-2-2-信号重建方法-SR-SIC（第一阶段）"><a href="#4-2-2-信号重建方法-SR-SIC（第一阶段）" class="headerlink" title="4.2.2 信号重建方法 SR-SIC（第一阶段）"></a>4.2.2 信号重建方法 SR-SIC（第一阶段）</h4><p>以[1]为代表的抽头延迟线横向滤波器，通过对射频信号采样，用sinc函数插值重建原始信号。<strong>是我们第一阶段采用的方法。</strong></p><p><img src="/images/media/6d826fb6bee579455ea260605c32698f.png" alt=""></p><p><strong>图 4</strong> 时域信号重建方法</p><p>图4<br>为时域的方法，基于时域的抵消架构对发射信号进行采样，并将其分成不同的分支，称为抽头。这些抽头中的每一个都有不同的时间延迟，并且可以在组合成单个输出之前独立调整信号的幅度和相位。正是这种延迟和抽头的复杂加权使得抵消器能够匹配自干扰信号，并产生与接收机内的自干扰相消的信号。</p><p>由于使用原始信号进行信号重建，故其发射机噪声可以被消除（也只能在模拟域进行消除）。其线性消除能力为62dB，非线性能力为30dB</p><p>当然也有频域相关的方法，可以参考哥伦比亚大学Jin<br>Zhou团队，优点是可以芯片小型化，缺点是目前为止其指标并不高。</p><h4 id="4-2-3-信道响应方法-CR-SIC"><a href="#4-2-3-信道响应方法-CR-SIC" class="headerlink" title="4.2.3 信道响应方法 CR-SIC"></a>4.2.3 信道响应方法 CR-SIC</h4><p>[8]中的方法</p><h4 id="4-2-4-数字域辅助模拟域方法"><a href="#4-2-4-数字域辅助模拟域方法" class="headerlink" title="4.2.4 数字域辅助模拟域方法"></a>4.2.4 数字域辅助模拟域方法</h4><p>[5]的方法，可以作为参考</p><h3 id="4-3-数字域干扰抵消"><a href="#4-3-数字域干扰抵消" class="headerlink" title="4.3 数字域干扰抵消"></a>4.3 数字域干扰抵消</h3><p>参考[3]和专著[12]</p><h4 id="4-3-1-功放模型"><a href="#4-3-1-功放模型" class="headerlink" title="4.3.1 功放模型"></a>4.3.1 功放模型</h4><p>在理想情况下，对于均值为0的射频信号，我们期望功率放大器的输出信号总是其输入信号的线性放大</p><p>其中表示某一常数。然而在实际情况中功率放大器的增益是一个随着输入信号大小而变化的函数</p><p><img src="/images/media/ca41f139d0ebf6a5d3d7f7e9cb645d96.jpg" alt=""></p><p><strong>图 4</strong> 幅度-幅度（AM-AM）特性 幅度-相位（AM-PM）特性</p><p>AM-AM特性和AM-PM特性指的是输入幅度变化造成的输出幅度和输出相移的非线性改变。早期通信系统带宽比较窄，远小于功放的工作带宽，所以使用无记忆模型，在频域上的体现就是功率放大器的行为特性不依赖于信号频率。当通信的带宽越来越大，其记忆效应更加明显，简单的无记忆模型不再适用。其记忆效应在频域体现在频率依赖行为，在时域体现在不仅与当前信号有关，还与过去一段时间信号有关。</p><p>记忆效应分为长记忆效应（线性记忆效应）和短记忆效应（非线性记忆效应），前者与匹配网络有关，后者主要由于功放的低频散射，具体模型如表1所示。</p><p>功放非线性指标</p><ul><li>1dB压缩点:相对线性增益降低1dB的输出功率点</li><li>三阶截断点:IP3</li></ul><p><strong>表1</strong> 常用功放模型分类</p><table><thead><tr><th>无记忆模型</th><th></th><th></th></tr></thead><tbody><tr><td>多项式模型</td><td>结构简单，参数辨识度高</td><td></td></tr><tr><td>记忆模型</td><td></td><td></td></tr><tr><td>两盒模型</td><td>Wiener</td><td>线性滤波+静态非线性模块（无记忆）</td></tr><tr><td></td><td>Hammerstein</td><td>静态非线性模块（无记忆）+线性滤波</td></tr><tr><td>Volterra级数及其改进形式</td><td>记忆多项式模型(Memory Polynomial)的性能具有稳健性，多种情况下优于Wiener, Hammerstein等模型的线性化性能，结构简单，复杂度低。</td><td></td></tr></tbody></table><h5 id="PA的Volterra级数模型"><a href="#PA的Volterra级数模型" class="headerlink" title="PA的Volterra级数模型"></a>PA的Volterra级数模型</h5><p>一般形式的Volterra模型为：</p><p>(4.3.1-1)</p><p>称为Volterra的kernels，一般只考虑奇数项，那么Volterra在功放中的表示形式如下</p><p>(4.3.1-2)</p><p>为对角项，其它求和项为交叉项。如果我们忽略交叉项，只保留对角项，则简化为如下多项式模型：</p><p>(4.3.1-3)</p><h4 id="4-3-2-线性消除"><a href="#4-3-2-线性消除" class="headerlink" title="4.3.2 线性消除"></a>4.3.2 线性消除</h4><h5 id="闭环方法"><a href="#闭环方法" class="headerlink" title="闭环方法"></a>闭环方法</h5><p>同模拟域类似，可以使用具有数字可控时间延迟单元和复杂抽头加权的抽头延迟线结构，如下图所示，可以通过LMS等等方法调整权重，好处是在数字域处理更加灵活，抽头数可以更多，自适应性强，可以实时调整权重。</p><p><img src="/images/media/4eb4d1f8c0c6d2ad4a4f7cfaea47ecbd.png" alt=""></p><p>图 4 数字域闭环方法</p><h5 id="开环方法"><a href="#开环方法" class="headerlink" title="开环方法"></a>开环方法</h5><p>主要是[1]中的方法，使用WiFi Preamble进行LS信道估计后恢复信号。</p><p>我们同样使用PH模型进行PA建模：</p><p>其中2K-1是该模型的阶数，L是该模型的抽头数。其矩阵形式可表示为：</p><p>其中</p><p>其中的Y是带有噪声的向量，通过LS算法求出B后再进行模型重建。</p><h4 id="4-3-2-非线性消除"><a href="#4-3-2-非线性消除" class="headerlink" title="4.3.2 非线性消除"></a>4.3.2 非线性消除</h4><h5 id="Parallelizable-Hammerstein-模型"><a href="#Parallelizable-Hammerstein-模型" class="headerlink" title="Parallelizable-Hammerstein 模型"></a>Parallelizable-Hammerstein 模型</h5><p>功放的模型可以参考[4]。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Bharadia, D., McMilin, E., &amp; Katti, S. (2013). Full duplex radios. ACM<br>SIGCOMM. <a href="https://doi.org/10.1145/2534169.2486033">https://doi.org/10.1145/2534169.2486033</a></p><p>[2] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). Inherent<br>Self-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.<br>IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.<br><a href="https://doi.org/10.1109/TMTT.2018.2818124">https://doi.org/10.1109/TMTT.2018.2818124</a></p><p>[3] Kolodziej, K. E., Perry, B. T., &amp; Herd, J. S. (2019). In-Band Full-Duplex<br>Technology: Techniques and Systems Survey. IEEE Transactions on Microwave Theory<br>and Techniques, 67(7), 3025–3041. <a href="https://doi.org/10.1109/TMTT.2019.2896561">https://doi.org/10.1109/TMTT.2019.2896561</a></p><p>[4] Isaksson, M., Wisell, D., &amp; Rönnow, D. (2006). A comparative analysis of<br>behavioral models for RF power amplifiers. IEEE Transactions on Microwave Theory<br>and Techniques, 54(1), 348–359. <a href="https://doi.org/10.1109/TMTT.2005.860500">https://doi.org/10.1109/TMTT.2005.860500</a></p><p>[5] Liu, Y., Quan, X., Pan, W., &amp; Tang, Y. (2017). Digitally Assisted Analog<br>Interference Cancellation for In-Band Full-Duplex Radios. IEEE Communications<br>Letters, 21(5), 1079–1082. <a href="https://doi.org/10.1109/LCOMM.2017.2652444">https://doi.org/10.1109/LCOMM.2017.2652444</a></p><p>[6] Kolodziej, K. E., McMichael, J. G., &amp; Perry, B. T. (2016). Multitap RF<br>Canceller for In-Band Full-Duplex Wireless Communications. IEEE Transactions on<br>Wireless Communications, 15(6), 4321–4334.<br><a href="https://doi.org/10.1109/TWC.2016.2539169">https://doi.org/10.1109/TWC.2016.2539169</a></p><p>[7] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,<br>Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.<br>IEEE Communications Magazine, 54(9), 80–87.<br><a href="https://doi.org/10.1109/MCOM.2016.7565192">https://doi.org/10.1109/MCOM.2016.7565192</a></p><p>[8] Choi, Y. S., &amp; Shirani-Mehr, H. (2013). Simultaneous transmission and<br>reception: Algorithm, design and system level performance. IEEE Transactions on<br>Wireless Communications, 12(12), 5992–6010.<br><a href="https://doi.org/10.1109/TWC.2013.101713.121152">https://doi.org/10.1109/TWC.2013.101713.121152</a></p><p>[9] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,<br>Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.<br>IEEE Communications Magazine, 54(9), 80–87.<br><a href="https://doi.org/10.1109/MCOM.2016.7565192">https://doi.org/10.1109/MCOM.2016.7565192</a></p><p>[10] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). Inherent<br>Self-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.<br>IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.<br><a href="https://doi.org/10.1109/TMTT.2018.2818124">https://doi.org/10.1109/TMTT.2018.2818124</a></p><p>[11] Wu, X., Shen, Y., &amp; Tang, Y. (2014). The Power Delay Pro fi le of the<br>Single-Antenna. 13, 1561–1564.</p><p>[12] Full-Duplex Wireless Communications Systems.(2017).</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-Band&lt;br&gt;Full-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="EE" scheme="https://blog.difan.tech/categories/EE/"/>
    
    
      <category term="EE" scheme="https://blog.difan.tech/tags/EE/"/>
    
  </entry>
  
  <entry>
    <title>运动营养、减脂</title>
    <link href="https://blog.difan.tech/2021/01/02/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"/>
    <id>https://blog.difan.tech/2021/01/02/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/</id>
    <published>2021-01-01T16:00:00.000Z</published>
    <updated>2022-02-19T14:32:50.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减脂"><a href="#减脂" class="headerlink" title="减脂"></a>减脂</h1><h2 id="有氧和少吃不是最好方法："><a href="#有氧和少吃不是最好方法：" class="headerlink" title="有氧和少吃不是最好方法："></a>有氧和少吃不是最好方法：</h2><p>原因：</p><p>热量缺口（有氧+少吃）-&gt;</p><ul><li>代谢下降</li><li>蛋白质降低，掉肌肉</li><li>脂肪吸收效率提高: 复胖速度快</li></ul><h2 id="正确的减脂思路"><a href="#正确的减脂思路" class="headerlink" title="正确的减脂思路"></a>正确的减脂思路</h2><ul><li>确定摄入的热量</li><li>亏空用锻炼放上</li><li>做力量训练，提高基础代谢</li><li>控制饮食</li><li>训练之后吃碳水，均匀摄入脂肪，蛋白质</li><li>避免糖脂混合物，鲜榨果汁，避免果糖</li><li>可以少食多餐</li><li>咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶</li><li>2g速溶咖啡大概50mg咖啡因</li><li>人体咖啡因一天小于400mg，不会有影响<br>不要一上来就是低碳水高蛋白，会给肾脏压力大</li></ul><span id="more"></span><h2 id="热量计算"><a href="#热量计算" class="headerlink" title="热量计算"></a>热量计算</h2><p>1kg脂肪 7700大卡，一周不超过1kg最安全</p><p>目标是最大减脂效率（1kg/week），每天1000大卡的热量亏空</p><p>我的代谢：2700大卡，每天1700热量摄入，并且蛋白质增加</p><ul><li>早餐 200大卡</li><li>午餐 800-1000大卡</li><li>晚餐 500大卡</li></ul><h3 id="常见食品热量"><a href="#常见食品热量" class="headerlink" title="常见食品热量"></a>常见食品热量</h3><ul><li>三勺燕麦：100大卡</li><li>一个汉堡  400大卡</li><li>薯条：350大卡</li><li>鸡排：200大卡</li><li>牛排：250大卡</li><li>二两米饭：100大卡</li><li>一片面包：150大卡</li><li>一条鱼：100大卡 80% 蛋白质</li><li>牛/羊肉 120大卡/100g 85%蛋白质</li><li>猪肉 330大卡/100g 脂肪高</li><li>二两米饭：</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;减脂&quot;&gt;&lt;a href=&quot;#减脂&quot; class=&quot;headerlink&quot; title=&quot;减脂&quot;&gt;&lt;/a&gt;减脂&lt;/h1&gt;&lt;h2 id=&quot;有氧和少吃不是最好方法：&quot;&gt;&lt;a href=&quot;#有氧和少吃不是最好方法：&quot; class=&quot;headerlink&quot; title=&quot;有氧和少吃不是最好方法：&quot;&gt;&lt;/a&gt;有氧和少吃不是最好方法：&lt;/h2&gt;&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;热量缺口（有氧+少吃）-&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代谢下降&lt;/li&gt;
&lt;li&gt;蛋白质降低，掉肌肉&lt;/li&gt;
&lt;li&gt;脂肪吸收效率提高: 复胖速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正确的减脂思路&quot;&gt;&lt;a href=&quot;#正确的减脂思路&quot; class=&quot;headerlink&quot; title=&quot;正确的减脂思路&quot;&gt;&lt;/a&gt;正确的减脂思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确定摄入的热量&lt;/li&gt;
&lt;li&gt;亏空用锻炼放上&lt;/li&gt;
&lt;li&gt;做力量训练，提高基础代谢&lt;/li&gt;
&lt;li&gt;控制饮食&lt;/li&gt;
&lt;li&gt;训练之后吃碳水，均匀摄入脂肪，蛋白质&lt;/li&gt;
&lt;li&gt;避免糖脂混合物，鲜榨果汁，避免果糖&lt;/li&gt;
&lt;li&gt;可以少食多餐&lt;/li&gt;
&lt;li&gt;咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶&lt;/li&gt;
&lt;li&gt;2g速溶咖啡大概50mg咖啡因&lt;/li&gt;
&lt;li&gt;人体咖啡因一天小于400mg，不会有影响&lt;br&gt;不要一上来就是低碳水高蛋白，会给肾脏压力大&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://blog.difan.tech/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="减脂" scheme="https://blog.difan.tech/tags/%E5%87%8F%E8%84%82/"/>
    
      <category term="运动营养" scheme="https://blog.difan.tech/tags/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>数字信号处理 -- 基于计算机方法</title>
    <link href="https://blog.difan.tech/2020/12/27/DSP/"/>
    <id>https://blog.difan.tech/2020/12/27/DSP/</id>
    <published>2020-12-26T16:00:00.000Z</published>
    <updated>2020-12-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录：</strong></p><!-- toc --><blockquote><p>本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记</p></blockquote><a id="more"></a><h1 id="信号与信号处理"><a href="#信号与信号处理" class="headerlink" title="信号与信号处理"></a>信号与信号处理</h1><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h3><ul><li>振幅</li><li>时间<ul><li>连续时间信号<ul><li>振幅也连续：模拟信号</li></ul></li><li>离散时间信号<ul><li>振幅离散：数字信号</li></ul></li></ul></li></ul><h3 id="复数信号和解析信号"><a href="#复数信号和解析信号" class="headerlink" title="复数信号和解析信号"></a>复数信号和解析信号</h3><h4 id="复数信号"><a href="#复数信号" class="headerlink" title="复数信号"></a>复数信号</h4><ul><li><p>Why?</p><ul><li>信号表示更加复杂（相位，幅度） -&gt; 信息量很大 -&gt; 信号处理更加简单，易于处理</li></ul></li><li><p>希尔伯特变换 HT</p><ul><li>$h_{HT} = \frac{1}{\pi t}$</li><li>$H_{HT}(j\Omega) = \begin{cases} -j &amp; \Omega &gt; 0 \\  j &amp;  \Omega &lt; 0  \end{cases} $<!--这里要用\\\来表示换行--><h4 id="实数信号"><a href="#实数信号" class="headerlink" title="实数信号"></a>实数信号</h4></li></ul></li><li><p>实数信号</p><ul><li>FT性质 =&gt; 幅度偶对称，相位奇对称</li><li>正频率 + 负频率 $X(j\Omega) = X_p(j\Omega)+X_n(j\Omega)$</li><li>经过HT =&gt; $\hat{X}(j\Omega) = -j X_p(j\Omega)+jX_n(j\Omega)$  =&gt; $\hat{x}(t)$也是实数信号</li></ul></li></ul><h4 id="解析信号"><a href="#解析信号" class="headerlink" title="解析信号"></a>解析信号</h4><p>=&gt; 解析信号  $y(t) = x(t) + j\hat{x}(t)$ </p><p>$x(t), \hat{x}(t)$ 为<strong>同相分量</strong>和<strong>正交分量</strong></p><p>$Y(j\Omega) = X(j\Omega)+j\hat{X}(j\Omega) = 2 X_p(j\Omega)$</p><p>我们可以看出<em>解析信号只包含正频率的部分</em></p><h2 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h2><ul><li>简单运算<ul><li>衰减</li><li>延迟 $y(t) = x(t-t_0)$ </li><li>相加，相乘</li><li>积分 $y(t) = \int_{-\infty}^{t}x(\tau) d\tau$ </li><li>微分 $y(t) = \frac{dx(t)}{dt}$</li><li>傅里叶变换Fourier Transform(FT)  $X(j\Omega) = \int_{-\infty}^{+\infty}x(t) e^{-j\Omega t} dt$</li></ul></li></ul><ul><li>滤波<ul><li>$y(t) = \int_{-\infty}^{+\infty} h(t-\tau)x(\tau)d\tau$</li><li>低通，高通，带通</li><li>带阻（陷波器3）</li><li>多频带滤波器：多个通带阻带</li><li>梳状滤波器：阻断某个低频的整数倍</li></ul></li></ul><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><ul><li>Why?<ul><li>低频信号无法直接用于传输</li><li>调制到高频进行传输- 原理：利用信号的振幅、相位、频率表示信号</li></ul></li></ul><h1 id="时域离散时间信号"><a href="#时域离散时间信号" class="headerlink" title="时域离散时间信号"></a>时域离散时间信号</h1><p>离散时间信号， Why？</p><blockquote><p> 现代计算机、微处理器、嵌入式设备都是处理数字信号的，但是我们的物理世界充斥着连续信号（模拟信号），如声音信号等。而直接处理模拟信号是比较困难的（1G通信），设备器件做的很大（大哥大），而且不便于加密（你树根天线就能窃听到隔壁老王在电话里说什么）。这就涉及到<em>模拟信号数字化</em>（<strong>采样，或者抽样</strong>），转换为数字信号进行处理。</p></blockquote><h2 id="时域表示"><a href="#时域表示" class="headerlink" title="时域表示"></a>时域表示</h2><p>采样： $x[n] = x_a{(t)}|_{t = nT} = x_a(nT)$</p><p>采样频率（抽样频率）： $F_t = \frac{1}{T}$</p><p>采样得到的值由于ADC（数模转换器）的精度问题（例如12 Bit ADC）有<strong>舍入的问题</strong>。</p><h2 id="频域表示"><a href="#频域表示" class="headerlink" title="频域表示"></a>频域表示</h2><p>归一化角频率：$\omega_c$ 为归一化角频率，因为样本$n$是无量纲的，所以应该是弧度/样本，且<br>$$<br>\omega = 2\pi f<br>$$<br>$f$ 是归一化角频率， 单位是周期/样本，即一个样本多少周期</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>例子2.1：集合平均</strong></p><p>$s[n]=2[n(0.9)^n]$ 和噪声$d(n)$，受干扰后的集合平均可以减少干扰影响</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Program_2_1</span></span><br><span class="line"><span class="comment">% Generation of the ensemble average</span></span><br><span class="line">N = <span class="number">50</span>; <span class="comment">% total number</span></span><br><span class="line">n = <span class="number">0</span> : N<span class="number">-1</span>;</span><br><span class="line">s = <span class="number">2</span>*(n.*<span class="number">0.9</span>.^n); <span class="comment">% generate the original signal s[n]</span></span><br><span class="line">rng();</span><br><span class="line">d = <span class="built_in">rand</span>(N, <span class="number">1</span>) - <span class="number">0.5</span>; <span class="comment">% generate the noise signal d[n]</span></span><br><span class="line"></span><br><span class="line">x1 = s+d&#x27;; <span class="comment">% the corrupted signal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the corrupted signal</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">stem(n, x1);</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Corrupted Signal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the Noise Signal</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">stem(n, d)</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Noise Signal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensemble average</span></span><br><span class="line"><span class="keyword">for</span> m = <span class="number">1</span>:<span class="number">50</span></span><br><span class="line">    rng();</span><br><span class="line">    noise = <span class="built_in">rand</span>(N,<span class="number">1</span>) - <span class="number">0.5</span>;</span><br><span class="line">    x = s + noise&#x27;;</span><br><span class="line">    x1 = x1 + x;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x1 = x1 / N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the ensemble average signal</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(n, x1);</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Ensemble Average Signal&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/DSP/2-1-01.png" alt=""></p><p><img src="/images/DSP/2-1-02.png" alt=""></p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>使用函数<code>conv</code>即可作为卷积运算</p><h3 id="抽样率转换"><a href="#抽样率转换" class="headerlink" title="抽样率转换"></a>抽样率转换</h3><p><strong>抽样率转换比:</strong>  $\frac{F_T^{‘}}{F_T} = R$, $F_T$ 是原本的抽样率, 再拿$F_T^{‘}$ 去抽样</p><h3 id="序列分类"><a href="#序列分类" class="headerlink" title="序列分类"></a>序列分类</h3><ul><li>周期、非周期</li><li>能量信号、功率信号</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- toc --&gt;


&lt;blockquote&gt;
&lt;p&gt;本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DSP" scheme="https://blog.difan.tech/tags/DSP/"/>
    
      <category term="Math" scheme="https://blog.difan.tech/tags/Math/"/>
    
      <category term="SignalProcessing" scheme="https://blog.difan.tech/tags/SignalProcessing/"/>
    
  </entry>
  
  <entry>
    <title>无线网络物理层</title>
    <link href="https://blog.difan.tech/2020/12/20/Wireless%20Physical%20Layer/"/>
    <id>https://blog.difan.tech/2020/12/20/Wireless%20Physical%20Layer/</id>
    <published>2020-12-19T16:00:00.000Z</published>
    <updated>2020-12-28T05:36:29.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记来源于书籍《MIMO OFDM Wireless Communications with MATLAB》</p></blockquote><h1 id="无线信道"><a href="#无线信道" class="headerlink" title="无线信道"></a>无线信道</h1><h2 id="衰落："><a href="#衰落：" class="headerlink" title="衰落："></a>衰落：</h2><p><em>衰落</em>：信号在时间和频率上的上下浮动</p><a id="more"></a><p><em>产生原因：</em></p><ul><li>多径（接收端的经多条路径收到发射端发射的信号）</li><li>噪声</li><li>障碍物（阴影衰落）</li></ul><p><em>分类</em></p><ul><li>大尺度衰落</li></ul><h1 id="SISO-模型"><a href="#SISO-模型" class="headerlink" title="SISO 模型"></a>SISO 模型</h1><h1 id="MIMO模型"><a href="#MIMO模型" class="headerlink" title="MIMO模型"></a>MIMO模型</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本笔记来源于书籍《MIMO OFDM Wireless Communications with MATLAB》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;无线信道&quot;&gt;&lt;a href=&quot;#无线信道&quot; class=&quot;headerlink&quot; title=&quot;无线信道&quot;&gt;&lt;/a&gt;无线信道&lt;/h1&gt;&lt;h2 id=&quot;衰落：&quot;&gt;&lt;a href=&quot;#衰落：&quot; class=&quot;headerlink&quot; title=&quot;衰落：&quot;&gt;&lt;/a&gt;衰落：&lt;/h2&gt;&lt;p&gt;&lt;em&gt;衰落&lt;/em&gt;：信号在时间和频率上的上下浮动&lt;/p&gt;
    
    </summary>
    
    
      <category term="Communications" scheme="https://blog.difan.tech/categories/Communications/"/>
    
    
      <category term="Wireless Communications" scheme="https://blog.difan.tech/tags/Wireless-Communications/"/>
    
  </entry>
  
  <entry>
    <title>TMUX</title>
    <link href="https://blog.difan.tech/2020/10/09/TMUX/"/>
    <id>https://blog.difan.tech/2020/10/09/TMUX/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2021-04-13T09:20:38.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li><code>tmux new -s window_name</code></li><li>ctrl + b + d : detach 当前的window</li><li><code>tmux a -t window_name</code></li><li>ctrl + b + w : 看一下window， panne</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>维护管理终端正在运行的程序</li><li>执行多个任务</li><li>远程使用时尤其方便，断开连接也不会挂掉正在跑的东西<a id="more"></a></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>Sessions 包含多个windows，表示一个工作区</li><li>Windows 相当于浏览器的tabs</li><li>Panes 一个window分割成几个视觉上分开的Panes</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>session<ul><li>tmux 开启新session</li><li>tmux new -s NAME </li><li>tmux ls 列出现存的session</li><li><C-b> d 分离当前的session</li><li>tmux a 继续上一个session </li><li>tmux a -t 0 指定session 0</li></ul></li><li>window<ul><li><C-b> c 创建window</li><li><C-b> + number 去 第几 window</li><li><C-b> p 上一个window</li><li><C-b> n 下一个window</li><li><C-b> w 列出现有的windows</li></ul></li><li>pane<ul><li><C-b> “ （我这里是 | ）水平方向分割</li><li><C-b> % （我这里是 - ）竖直方向分割</li><li><C-b> z 全屏，然后再按一次恢复</li><li><C-b> <C> ← →来改变pane大小</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tmux new -s window_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ctrl + b + d : detach 当前的window&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux a -t window_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ctrl + b + w : 看一下window， panne&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;维护管理终端正在运行的程序&lt;/li&gt;
&lt;li&gt;执行多个任务&lt;/li&gt;
&lt;li&gt;远程使用时尤其方便，断开连接也不会挂掉正在跑的东西
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="tmux" scheme="https://blog.difan.tech/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>Vim 随手记</title>
    <link href="https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    <id>https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-05-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><a id="more"></a><ul><li><p>i : insert 光标字符之前</p></li><li><p>a : append 光标字符之后加入</p></li><li><p>o : open a line below 当前行下面开一行</p></li><li><p>A : 在本行最后append</p></li><li><p>O : 本行上面插入一行，开头插入</p></li><li><p>I : 在本行开头插入</p></li></ul><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><ul><li>normal<ul><li>使用 gi 快速恢复到原始插入位置</li><li>w 下个单词开头，e下个单词结尾</li><li>b 上个单词开头 </li><li>大写跳动到以空白符为间隔的地方</li><li>f+字符，搜索字符, ; 下一个 ,上一个 F+ 字符反过来搜</li><li>0 行首，$ 行尾</li><li>g 移动到开头，G移动到结尾 H/M/L跳转到屏幕的开头，结尾</li><li>ctrl u ctrl d翻页 cltr F/B</li><li>dw 删除一个单词 delete a world x删除字符</li><li>r replalce一个字符 s 删除当前字符进入插入模式 </li><li>R 不断地替换 S 整行删除，进入插入模式</li><li>c(change) aw 删掉一个词进入插入 C 删除整行进入插入模式 ct” 删除整个“”中的内容</li><li>? / 进行反向前向搜索，n/N下一个上一个 # * 当前单词向上搜索/向下搜索</li></ul></li><li>insert<ul><li>ctrl + w 删除word</li><li>ctrl + u 删除行</li><li>ctrl + h 删除上一个字符</li><li>用ctrl + [ 代替esc</li></ul></li><li>command <ul><li>:vs(vertical split) 竖分屏（左右）</li><li>:sp(split) 上下分屏</li><li>set nu 行号</li><li>% s/word1/word2/g 全局替换</li><li>1,6 s/word1/word2/g 1-6行之间替换</li><li>1,6 self//n 统计1-6行几个匹配self n指number，报告匹配到的次数</li><li>% s/&lt;quack&gt;/word2/g</li></ul></li><li>visual<ul><li>normal 模式 v</li><li>V选行</li><li>ctrl v选方块</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="vim" scheme="https://blog.difan.tech/tags/vim/"/>
    
      <category term="Linux" scheme="https://blog.difan.tech/tags/Linux/"/>
    
      <category term="随手记" scheme="https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在CentOS 7上使用FirewallD设置防火墙</title>
    <link href="https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2020-01-10T11:40:44.000Z</published>
    <updated>2020-05-04T08:33:06.038Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a></p><a id="more"></a><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Firewalld是可用于许多Linux发行版的防火墙管理解决方案，它充当Linux内核提供的iptables数据包过滤系统的前端。 在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用firewall-cmd管理工具管理防火墙的基本知识（如果您希望在CentOS中使用iptables，请遵循 <a href="https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7">这个指南</a>。</p><h2 id="Firewalld-的基本概念"><a href="#Firewalld-的基本概念" class="headerlink" title="Firewalld 的基本概念"></a>Firewalld 的基本概念</h2><p>在开始讨论如何实际使用firewall-cmd实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。</p><h3 id="Zones-区域"><a href="#Zones-区域" class="headerlink" title="Zones(区域)"></a>Zones(区域)</h3><p>Firewalld守护程序使用称为“区域”的实体管理规则组。 区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。 为网络接口分配一个Zone来指示防火墙应允许和拒绝哪些行为。</p><p>对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。 在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。 对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改。</p><p>无论您的网络环境动态性有多强，熟悉防火墙的每个预定义区域背后的概念仍然很有用。 按从最不信任到最受信任的顺序，firewalld中的预定义区域为：</p><ul><li><p><strong>drop</strong>：最低级别的信任度。 所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。</p></li><li><p><strong>block</strong>：与上述类似，但不仅仅是丢弃连接，而是使用icmp-host-prohibited或icmp6-adm-prohibited消息拒绝传入的请求。</p></li><li><p><strong>public</strong>：代表公共的，不受信任的网络。 您不信任其他计算机，但可能会视情况允许选择的传入连接。</p></li><li><p><strong>external</strong>：external network用于这种情形：您将firewalld当成网关使用。 将其配置为伪NAT，以便您的内部网络保持私有但可访问。</p></li><li><p><strong>internal</strong>：外部区域的另一侧，用于网关的内部。 这些计算机相当值得信赖，并且可以使用一些其他服务。</p></li><li><p><strong>dmz</strong>：用于DMZ（无法访问网络其余部分的隔离计算机）。 仅允许某些传入连接。</p></li><li><p><strong>work</strong>：用于工作机。 信任网络中的大多数计算机。 可能还允许其他一些服务。</p></li><li><p><strong>home</strong>：家庭环境。 通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。</p></li><li><p><strong>trusted</strong>：信任网络中的所有计算机。 可用选项中最开放的，应谨慎使用。</p></li></ul><p>要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口（network interface）分配给最合适的区域（zones）。</p><h3 id="规则永久性"><a href="#规则永久性" class="headerlink" title="规则永久性"></a>规则永久性</h3><p>在firewalld中，可以将规则指定为<strong>永久规则</strong>或<strong>立即规则</strong>。 如果添加或修改规则，则默认情况下，将修改当前运行的防火墙规则。 下次启动时，旧规则将恢复。</p><p>大多数<code>firewall-cmd</code>操作都可以使用<code>--permanent</code>标志来指示应永久防火墙规则作为目标。 这将影响在引导时重新加载的规则。 这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。 您还可以使用<code>--permanent</code>标志随着时间的推移建立一套完整的规则，这些规则将在发出<code>reload</code>命令时立即应用。</p><h2 id="安装并启动防火墙"><a href="#安装并启动防火墙" class="headerlink" title="安装并启动防火墙"></a>安装并启动防火墙</h2><p>firewalld默认安装在一些Linux发行版上，包括许多CentOS 7的映像。但是，您可能需要自己安装firewalld:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install firewalld</span><br></pre></td></tr></table></figure><p>安装firewalld之后，可以启用服务并重新启动服务器。请记住，启用firewalld将导致服务在引导时启动。最好的做法是<strong>先创建防火墙规则</strong>，并在配置此行为之前对其进行测试，以避免潜在的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable firewalld </span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>当服务器重新启动时，你的防火墙应该会打开，你的网络接口应该放入已配置的区域(或退回到已配置的默认区域)，与区域相关的任何规则都将应用于相关的接口。</p><p>我们可以通过键入以下内容来验证该服务正在运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --state</span><br></pre></td></tr></table></figure><p>这表明我们的防火墙已经启动并使用默认配置运行。</p><h2 id="熟悉当前的防火墙规则"><a href="#熟悉当前的防火墙规则" class="headerlink" title="熟悉当前的防火墙规则"></a>熟悉当前的防火墙规则</h2><p>在开始进行修改之前，我们应该熟悉守护进程提供的默认环境和规则。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>我们可以通过输入以下内容来查看当前选择的默认区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">public</span><br><span class="line">  interfaces: eth0 eth1</span><br></pre></td></tr></table></figure><p> 在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（eth0和eth1）。 目前，它们都根据为public zone定义的规则进行管理。</p><p>我们如何知道与public zone相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">public (default, active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0 eth1</span><br><span class="line">  sources: </span><br><span class="line">  services: ssh dhcpv6-client</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure><p>从输出中可以看出，该区域既是默认区域又是活动区域，并且eth0和eth1接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。 但是，我们还可以看到，该区域允许与DHCP客户端（用于IP地址分配）和SSH（用于远程管理）相关的正常操作。</p><h3 id="可替代区"><a href="#可替代区" class="headerlink" title="可替代区"></a>可替代区</h3><p>现在，我们对缺省和活动区域的配置有了很好的了解。我们也可以找到其他区域的信息。要获得可用区域的列表，请输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure><p>我们可以通过在<code>—list-all</code>命令中包含<code>—zone=</code>参数来查看与区域关联的特定配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;home --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">home</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ipp-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>您可以使用–list-all-zones选项输出所有区域定义。 您可能希望将输出通过管道以便于查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-all-zones | less</span><br></pre></td></tr></table></figure><h2 id="为接口选择区域"><a href="#为接口选择区域" class="headerlink" title="为接口选择区域"></a>为接口选择区域</h2><p>除非您已经配置了您的网络接口，否则在防火墙启动时，每个接口都将放在默认区域。</p><h3 id="改变接口的区域"><a href="#改变接口的区域" class="headerlink" title="改变接口的区域"></a>改变接口的区域</h3><p>您可以在会话期间使用<code>—zone=</code>参数和<code>—change-interface=</code>参数在区域之间转换接口。与修改防火墙的所有命令一样，您将需要使用sudo。</p><p>例如，我们可以通过输入以下内容将eth0接口转换到home区域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;home --change-interface&#x3D;eth0</span><br></pre></td></tr></table></figure><blockquote><p>每当将接口转换到新区域时，请注意，您可能正在修改将可操作的服务。例如，在这里，我们将移动到”home”区域，其中有 SSH 可用。这意味着我们的连接不应该断开。默认情况下，某些其他区域未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。</p></blockquote><p>我们可以通过再次请求活动区域来验证这是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">home</span><br><span class="line">  interfaces: eth0</span><br><span class="line">public</span><br><span class="line">  interfaces: eth1</span><br></pre></td></tr></table></figure><h3 id="调整默认区域"><a href="#调整默认区域" class="headerlink" title="调整默认区域"></a>调整默认区域</h3><p>如果所有接口都可以最好地由单个区域处理，那么只需选择最佳默认区域，然后将其用于配置可能更容易。</p><p>您可以使用 参数更改默认区域。这将立即将默认的接口更改回新区域：<code>--set-default-zone=</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --set-default-zone&#x3D;home</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="为应用程序设置规则"><a href="#为应用程序设置规则" class="headerlink" title="为应用程序设置规则"></a>为应用程序设置规则</h2><p>为您希望提供的服务定义防火墙的基本方法非常简单。我们将在这里了解基本思想。</p><h3 id="向区域添加服务"><a href="#向区域添加服务" class="headerlink" title="向区域添加服务"></a>向区域添加服务</h3><p>最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用以下选项获取可用服务的列表：<code>--get-services</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>您可以使用命令行参数为区域启用服务。该操作将针对默认区域或参数指定的任何区域。默认情况下，这将仅调整当前防火墙会话。您可以通过包含<code>permanent</code>标志来调整永久防火墙配置。<code>--add-service=--zone=--permanent</code></p><p>例如，如果我们正在运行一个为传统HTTP流量提供服务的web服务器，我们可以通过输入以下命令来允许该会话的公共区域中的接口的流量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;http</span><br></pre></td></tr></table></figure><p>我们可以用这个验证操作是否成功：<code>--zone=--list-all--list-services</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure><p>测试完所有功能后，可能需要修改永久防火墙规则，以便在重新启动后服务仍然可用。通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;http</span><br></pre></td></tr></table></figure><p>现在，您的“公共”区域将允许端口80上的HTTP Web通信。如果您的Web服务器配置为使用SSL / TLS，则还需要添加服务。 我们可以通过以下内容将其添加到当前session和永久规则集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;https</span><br></pre></td></tr></table></figure><h3 id="如果没有合适的服务可用呢"><a href="#如果没有合适的服务可用呢" class="headerlink" title="如果没有合适的服务可用呢?"></a>如果没有合适的服务可用呢?</h3><p>firewalld安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见需求。但是，可能会出现这些服务不适合您的需求的情况。</p><p>在这种情况下，你有两种选择：</p><h4 id="为你的区域开一个端口"><a href="#为你的区域开一个端口" class="headerlink" title="为你的区域开一个端口"></a>为你的区域开一个端口</h4><p>支持你特定服务最简单的方法就是在合适的区域(zone)内开放一个端口， 这很容易指定端口或端口范围，以及需要打开的端口相关的协议。</p><p>比如，如果你的应用在5000端口中使用TCP，<br>你可以在public区域内使用这个参数进行增加，协议可以为tcp，udp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;5000&#x2F;tcp</span><br></pre></td></tr></table></figure><p>我们可以通过<code>--list-ports</code>进行确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --list-ports</span><br></pre></td></tr></table></figure><p>使用横杠进行连续端口的指定也是可能的，例如，下面的例子就开放了4990到4999的UDP端口，当然同样是在Public zone中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public ---add-port&#x3D;4990-4999&#x2F;udp</span><br></pre></td></tr></table></figure><p>在测试后，我们想把它们增加为永久的防火墙规则，你可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;5000&#x2F;tcp</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;4990-4999&#x2F;udp</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --list-ports</span><br></pre></td></tr></table></figure><h4 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h4><p>为您的区域打开端口很容易，但是很难跟踪每个端口的用途。如果您曾经在您的服务器上停止过一个服务，那么您可能很难记住哪些过去被打开了的端口仍然是必需的。为了避免这种情况，可以定义一个服务。</p><p>服务只是具有相关名称和描述的端口的集合。使用服务比端口更容易管理，但是需要一些前期工作。最简单的启动方式是将现有的脚本复制到防火墙查找非标准定义的目录中。<code>/usr/lib/firewalld/services/etc/firewalld/services</code></p><p>例如，我们可以复制SSH服务定义来使用我们的’example’服务定义，如下所示。文件名减去后缀将指示防火墙服务列表中的服务名称:<code>.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;services&#x2F;ssh.xml &#x2F;etc&#x2F;firewalld&#x2F;services&#x2F;example.xml</span><br></pre></td></tr></table></figure><p>首先，该文件将包含您复制的SSH定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该定义的大部分实际上是元数据。 您将要在标签内更改服务的简称。 这是您的服务的易读名称。 您还应该添加描述，以便在需要审核服务时获得更多信息。 您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。 可以多次指定。</p><p>对于我们的示例服务，假设我们需要为TCP打开7777端口，为UDP打开8888端口。通过按下按钮进入插入模式，我们可以这样修改现有的定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>Example Service<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is just an example service.  It probably shouldn&#x27;t be used on a real system.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;udp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新加载防火墙以访问新服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>我们可以看到example服务已经被成功定义。</p><h2 id="创造属于你自己的区域（zones）"><a href="#创造属于你自己的区域（zones）" class="headerlink" title="创造属于你自己的区域（zones）"></a>创造属于你自己的区域（zones）</h2><p>尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。</p><p>例如，您可能要为Web服务器创建一个名为“ publicweb”的zone。 但是，您可能希望为您在专用网络上提供的DNS服务而去配置另一个zone。 您可能需要一个名为“ privateDNS”的zone。</p><p>添加区域时，必须将其添加到永久防火墙配置中。 然后，您可以重新加载以将配置带入正在运行的会话。 例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --new-zone&#x3D;publicweb</span><br><span class="line">sudo firewall-cmd --permanent --new-zone&#x3D;privateDNS</span><br></pre></td></tr></table></figure><p>您可以通过键入来验证它们是否存在于您的永久配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --get-zones</span><br></pre></td></tr></table></figure><p>如前所述，这些在防火墙的当前实例中还不可用,重新加载防火墙，将这些新区域引入活动配置2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure><p>现在，您可以开始为您的区域分配适当的服务和端口。先调整active instance，然后在测试之后将这些更改转移到永久配置，这通常是一个好主意。例如，对于publicweb专区，您可能希望添加SSH、HTTP和HTTPS服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;ssh</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;http</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">publicweb</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: ssh http https</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>同样，我们可以将DNS服务添加到我们的privateDNS zone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --add-service&#x3D;dns</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">privateDNS</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dns</span><br><span class="line">  ports: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>然后，我们可以更改对应zone的网络接口以对其进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1</span><br></pre></td></tr></table></figure><p>此时，您就有机会测试您的配置了。如果这些值对您有效，您将希望向永久配置添加相同的规则。您可以通过重新应用带有标志的规则来做到这一点:<code>--permanent</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;ssh</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;http</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --permanent --add-service&#x3D;dns</span><br></pre></td></tr></table></figure><p>在永久地应用这些规则之后，您可以重新启动网络并重新加载防火墙服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart network</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure><p>确认已经成功分配了zones：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privateDNS</span><br><span class="line">  interfaces: eth1</span><br><span class="line">publicweb</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure><p>确认合适的服务已经在每个zones里面可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">http https ssh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns</span><br></pre></td></tr></table></figure><p>现在您已经成功地建立了属于您的区域！如果您想要把其中一个区域设置为其他网络接口的默认区域，记得使用参数<code>--set-defalut-zone=</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --set-default-zone&#x3D;publicweb</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您现在应该对如何在CentOS系统上日常使用的防火墙服务进行充分的了解。</p><p>Firewalld服务允许您配置依据网络环境的可维护规则和规则集。 它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。 掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。</p><p>By Justin Ellingwood</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7&quot;&gt;How To Set Up a Firewall Using FirewallD on CentOS 7&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.difan.tech/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://blog.difan.tech/tags/CentOS/"/>
    
      <category term="FirewallD" scheme="https://blog.difan.tech/tags/FirewallD/"/>
    
  </entry>
  
  <entry>
    <title>微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验</title>
    <link href="https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/</id>
    <published>2019-12-16T02:52:37.000Z</published>
    <updated>2020-05-04T08:32:54.737Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge<br><strong>采用了 Chromium 内核</strong>，当然也兼容以前 IE 的功能。</p></blockquote><a id="more"></a><p>由于最新的Edge采用Chromium内核，对于平时使用Chrome作为使用工具的人来说不会有太大学习成本，基本无缝迁移。最新版本在功耗，性能，UI上都取得了比较不错的表现。</p><p>最新的Edge版采用了Chromium的内核，当然现在没有正式版，可以用<a href="https://www.microsoftedgeinsider.com/zh-cn/">Beta版</a> 来体验。</p><p><img src="https://img-blog.csdnimg.cn/20191215235301329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Beta版进行下载</p><p><img src="https://img-blog.csdnimg.cn/20191215235921432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191215235957717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看到进去后提示导入chrome收藏，一键导入很方便，UI风格很漂亮，下面看一下开发者工具：</p><p><img src="https://img-blog.csdnimg.cn/20191216000333905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191216001742765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>和之前Chrome的类似，不会有学习成本。新Edge浏览器因为只是测试版，因此插件很少，不过我们可以将<strong>Chrome的插件直接打包过来或者直接访问<a href="https://chrome.google.com/webstore/">Chrome商店</a>进行下载</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20191216002513982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>亲测可直接添加Chrome插件，使用体验没有任何区别，在正常工作环境下（插件数量相同，打开6个TAB），新Edge占用内存较低：</p><p><img src="https://img-blog.csdnimg.cn/20191216004233444.png" alt="在这里插入图片描述"><br>目前来看，优势主要有：</p><ul><li><p>账户可以直接用微软账户，同步不需要翻墙</p></li><li><p>和Chrome一致的的性能，更好的UI</p></li><li><p>平滑滚动好</p><p>要注意的是，现在的Edge Beta版和自带的Edge不是覆盖的，所以可以放心试用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191216005133562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge&lt;br&gt;&lt;strong&gt;采用了 Chromium 内核&lt;/strong&gt;，当然也兼容以前 IE 的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="MicroSoft" scheme="https://blog.difan.tech/tags/MicroSoft/"/>
    
  </entry>
  
  <entry>
    <title>Git 实战</title>
    <link href="https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/"/>
    <id>https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2021-01-16T09:50:17.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><ul><li>集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作</li><li>分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧</li></ul><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;×××&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;×××@gmail.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>会在~ 目录生成一个.gitconfig</p><p>如果你想不是global，则不带–global即可，会在本项目目录下创建.git/config</p><p><code>git init</code> 初始化一个git project</p><p><code>git diff --cached</code> 查看缓存区里有哪些文件被修改了。<code>git diff</code>会显示所有已做但是没有加到缓存区的修改</p><p>add 和commit操作不赘述，commit操作后<code>-a</code>将所有没有加到缓存区的修改也一起提交，不过<strong>不会提交新文件</strong></p><p><code>git remote add origin https://github.com/myname/myproject.git</code></p><p><code>git push origin master</code></p><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><p>分支在多人协作开发用的多，比如你负责的一个功能需要一个月完成，就可以创建一个分支，只把功能代码提交到这个分支上，最后合并到master分支上</p><p><code>git branch experimental</code> 创建分支</p><p><code>git branch</code> 查看分支</p><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* experimental </span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git checkout experimental</code> 切换到其他分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将experimental分支合并到master</span><br><span class="line">$ git merge -m &#39;merge experimental branch&#39; experimental</span><br></pre></td></tr></table></figure><p>如果有冲突，比如两个分支都修改了同一个文件，就会merge失败，这是在master分支修改对应文件再commit即可。</p><p>当我们完成分支，可以用<code>git branch -d experimental</code> 来删除（只能删除已经合并了的分支，强行删除用<code>-D</code>）</p><p>如果你觉得<strong>合并错了</strong>，可以回到合并前的状态</p><p><code>git reset --hard HEAD^</code></p><h2 id="Git-日志"><a href="#Git-日志" class="headerlink" title="Git 日志"></a>Git 日志</h2><p><code>git log</code></p><p><code>git log --stat</code> 会显示哪些文件被修改</p><p><code>git log --pretty=oneline</code> 会一行显示一条信息</p><p><code>git log --pretty=short</code> 显示简短信息</p><p><code>git log --graph -pretty=oneline</code> 画一个漂亮的历史</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff不仅仅能查看两个文件的差别，也可以看两个branch的区别。 </p><p><code>git diff anotherbranch</code>  + 表示本分支比anotherbranch分支多的，- 表示本分支少的</p><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>如果要经常操作远程分支，可以定义缩写</p><p><code>git remote add myrepo /tmp/myrepo</code></p><p>git pull 相当于两个操作：使用git fetch抓取最新的修改信息，然后git merge</p><p><strong>为什么不需要指定远程仓库？</strong></p><p>因为Git把远程地址存到了配置文件的remote.origin.url</p><p>git 也可以是服务器的地址：</p><p><code>git clone ssh://服务器/账号/仓库名称</code></p><p><code>git push ssh://服务器仓库地址 master:master</code></p><h2 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h2><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><p><code>git tag tagname 8c2940</code></p><p><code>git tag</code></p><h3 id="标签对象"><a href="#标签对象" class="headerlink" title="标签对象"></a>标签对象</h3><p><code>git tag -a stable-2 8c315325 -m &quot;stable 2&quot;</code></p><h3 id="签名标签"><a href="#签名标签" class="headerlink" title="签名标签"></a>签名标签</h3><p>签名标签可以让提交和标签更加完整可信</p><h2 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h2><p>.gitignore 来忽略不需要提交的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.html</span><br><span class="line">!foo.html #foo.html例外</span><br><span class="line">*.[oa] #忽略所有.o .a </span><br></pre></td></tr></table></figure><h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p><code>git reset --hard HEAD^</code> 回到上次提交的状态</p><p><code>git checkout -- hello.rb</code> 恢复一个文件</p><p><code>git revert HEAD</code> 撤销最近的一次提交</p><h2 id="建设私有仓库"><a href="#建设私有仓库" class="headerlink" title="建设私有仓库"></a>建设私有仓库</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>可以导出一个裸仓库，然后用scp命令拷贝到服务器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;home&#x2F;user&#x2F;myrepo&#x2F;.git &#x2F;tmp&#x2F;myrepo.git</span><br><span class="line">scp -r &#x2F;tmp&#x2F;myrepo.git myserver.com:&#x2F;opt&#x2F;git&#x2F;myrepo.git</span><br></pre></td></tr></table></figure><p>对于其他人来说，直接</p><p><code>git clone myserver:com:/opt/git/myrepo.git</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制系统&quot;&gt;&lt;a href=&quot;#版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;版本控制系统&quot;&gt;&lt;/a&gt;版本控制系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作&lt;/li&gt;
&lt;li&gt;分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://blog.difan.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 16.04 home挂载 系统重装</title>
    <link href="https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"/>
    <id>https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/</id>
    <published>2019-06-09T05:39:30.000Z</published>
    <updated>2021-03-29T06:12:00.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-系统重装并挂载"><a href="#Ubuntu-系统重装并挂载" class="headerlink" title="Ubuntu 系统重装并挂载"></a>Ubuntu 系统重装并挂载</h1><p>昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..</p><a id="more"></a><h2 id="linux分区"><a href="#linux分区" class="headerlink" title="linux分区"></a>linux分区</h2><blockquote><p>SWAP分区是LINUX暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为SWAP使用的分区不用指定“Mout Point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，<strong>一般来说它的大小是内存的一至两倍</strong>。另外你也可以创建和使用一个以上的交换分区，最多16个。</p></blockquote><h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><p>为什么要自定义多个分区</p><ul><li>在不损失数据的情况下重装系统，比如独立设置/home挂载点,重装系统的时候直接标记回/home，数据不会有任何损失。</li><li>针对不同挂载点的特性分配合适的文件系统以合理发挥性能，比如对/var使用reiserfs，对/home使用xfs，对/使用ext4。</li><li>针对不同的挂载点开启不同的挂载选项，如是否需要即时同步，是否开启日志，是否启用压缩。</li><li>大硬盘搜索范围大，效率低</li><li>磁盘配额只能对分区做设定</li><li>/home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MjQxMDM4LTIzMzllNDk4YzkyZGU1MjIuanBn?x-oss-process=image/format,png" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></li></ul><p>（常见的挂载目录结构）</p><blockquote><p>/ 根目录，存放系统命令和用户数据等（如果下面挂载点没有单独的分区，它们都将在根目录的分区中） /boot boot loader 的静态链接文件，存放与Linux启动相关的程序 /home 用户目录，存放普通用户的数据 /tmp 临时文件 /usr 是Linux系统存放软件的地方,如有可能应将最大空间分给它 /usr/local 自已安装程序安装在此 /var 不断变化的数据，服务器的一些服务、日志放在下面 /opt （Option可选的）附加的应用程序软件包 /bin 基本命令执行文 /dev 设备文件 /etc 主机特定的系统配置 /lib 基本共享库以及内核模块 /media 用于移动介质的挂载点 /mnt 用于临时挂载文件系统或者别的硬件设备（如光驱、软驱） /proc 系统信息的虚拟目录(2.4 和 2.6 内核)，这些信息是在内存中，由系统自己产生的 /root root 用户的目录 /sbin 基本系统命令执行文件 /sys 系统信息的虚拟目录(2.6 内核) /srv 系统提供的用于 service 的数据 /usr/X1186 X-Windows目录，存放一些X-Windows的配置文件 /usr/include 系统头文件，存储一些C语言的头文件 /usr/src Linux内核源代码，Linux系统所安装的内核源代码都保存在此 /usr/bin 对/bin目录的一些补充 /usr/sbin 对/sbin目录的一些补充 /lost+found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下</p></blockquote><h3 id="为什么会有挂载"><a href="#为什么会有挂载" class="headerlink" title="为什么会有挂载"></a>为什么会有挂载</h3><p>因为<strong>linux 下一切皆文件</strong>！换句说法就是linux操作系统将系统中的一切都作为文件来管理。在windows中我们常见的硬件设备（打印机、网卡、声卡…）、磁盘分区等，在linux中统统都被视作文件，对设备、分区的访问就是读写对应的文件。</p><h2 id="linux挂载"><a href="#linux挂载" class="headerlink" title="linux挂载"></a>linux挂载</h2><h3 id="临时挂载"><a href="#临时挂载" class="headerlink" title="临时挂载"></a>临时挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mount &#x2F;dev&#x2F;sda11 &#x2F;data   ##sda3分区挂载在data目录下</span><br><span class="line">$ umount &#x2F;data   ##卸载data目录下分区 &#x2F;dev&#x2F;sda11 &#x2F;data   ##sda3分区挂载在data目录下</span><br><span class="line">$ umount &#x2F;data   ##卸载data目录下分区</span><br></pre></td></tr></table></figure><h3 id="永久挂载：开机自动挂载"><a href="#永久挂载：开机自动挂载" class="headerlink" title="永久挂载：开机自动挂载"></a>永久挂载：开机自动挂载</h3><p><strong>需要修改/etc/fstab</strong></p><p><strong><img src="https://img-blog.csdn.net/20180609133109749" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></strong></p><p><strong><img src="https://img-blog.csdn.net/20180609133131519" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</strong></p><p><strong>Device</strong></p><p>By default, Ubuntu now uses <a href="http://en.wikipedia.org/wiki/UUID">UUID</a> to identify partitions.</p><p>默认，Ubuntu用uuid识别分区</p><p>To list your devices by UUID use blkid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>使用命令 <code>fdisk -l</code> 可以列出系统中当前连接的硬盘,设备和分区信息.新硬盘没有分区信息,则只显示硬盘大小信息.</p><p><img src="https://img-blog.csdn.net/20180609133150762" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以先mkdir一个目录，比如new_dir，然后挂载分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda11 &#x2F;mnt&#x2F;new_dir</span><br></pre></td></tr></table></figure><p>将所有东西全部cp到new_dir中</p><p>move原有的home </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;</span><br><span class="line">mv &#x2F;home &#x2F;old_home &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;</span><br><span class="line">mv &#x2F;home &#x2F;old_home</span><br></pre></td></tr></table></figure><p>再<code>mkdir</code>一个新的home,将sda11再mount到home上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda11 &#x2F;home</span><br></pre></td></tr></table></figure><p><code>df -h</code>查看硬盘大小和挂载情况</p><p><img src="https://img-blog.csdn.net/20180609133221926" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>最后根据要求，修改/etc/fstab 文件，注意格式要和其他保持一致，查看UUID可以用前文中说的方法。最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a-a</span><br></pre></td></tr></table></figure><p>这样就设置了fstab中的参数，<strong>设置完之后一定要看看生不生效，再继续操作</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu-系统重装并挂载&quot;&gt;&lt;a href=&quot;#Ubuntu-系统重装并挂载&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 系统重装并挂载&quot;&gt;&lt;/a&gt;Ubuntu 系统重装并挂载&lt;/h1&gt;&lt;p&gt;昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.difan.tech/categories/Linux/"/>
    
    
      <category term="ubuntu" scheme="https://blog.difan.tech/tags/ubuntu/"/>
    
      <category term="挂载" scheme="https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
</feed>
