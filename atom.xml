<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tigerroarm&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/7880b27a93b174bc9a1cbe57a5bba5ff</icon>
  <subtitle>Stay naive, stay simple.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.difan.tech/"/>
  <updated>2022-04-06T17:32:15.880Z</updated>
  <id>https://blog.difan.tech/</id>
  
  <author>
    <name>Tigerroarm</name>
    <email>difanmu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU-15441 关系型数据库实现-Buffer Pool</title>
    <link href="https://blog.difan.tech/2022/04/07/CMU-15441%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93(Buffer_Pool)/"/>
    <id>https://blog.difan.tech/2022/04/07/CMU-15441%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93(Buffer_Pool)/</id>
    <published>2022-04-06T16:00:00.000Z</published>
    <updated>2022-04-06T17:32:15.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="assignment-0-C-primter"><a href="#assignment-0-C-primter" class="headerlink" title="assignment 0  C++ primter"></a>assignment 0  C++ primter</h2><p>目的是熟悉一下C++，这里的提交需要注意一下格式，比如statement必须在{}之间的要求等等，否则gradescope通过不了。我的第一次提交就有这样的问题，这个评测系统对于格式的要求很高。</p><p><strong>GDB：</strong></p><ul><li><a href="https://www.cs.cmu.edu/~gilpin/tutorial/">Debugging Under Unix: gdb Tutorial</a></li><li><a href="http://www.techbeamers.com/how-to-use-gdb-top-debugging-tips/">GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers</a></li><li><a href="https://www.youtube.com/watch?v=PorfLSr3DDI">Give me 15 minutes &amp; I’ll change your view of GDB</a> [VIDEO]</li></ul><p>顺便复习了一下智能指针：</p><ul><li>某一时刻只能有一个 <code>unique_ptr&lt;T&gt;</code>指向对象，不支持拷贝赋值</li><li><code>shared_ptr&lt;T&gt;</code>可以拷贝赋值，内有自己的计数器</li></ul><span id="more"></span><p>本地测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[       OK ] StarterTest.ElementAccessTest (0 ms)</span><br><span class="line">[ RUN      ] StarterTest.AdditionTest</span><br><span class="line">[       OK ] StarterTest.AdditionTest (0 ms)</span><br><span class="line">[ RUN      ] StarterTest.MultiplicationTest</span><br><span class="line">[       OK ] StarterTest.MultiplicationTest (0 ms)</span><br><span class="line">[----------] 5 tests from StarterTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 5 tests from 1 test suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 5 tests.</span><br></pre></td></tr></table></figure><p>gradescope提交结果<br><img src="/images/db/20211027134144.png" alt=""></p><h2 id="Assignment-1-Buffer-Pool"><a href="#Assignment-1-Buffer-Pool" class="headerlink" title="Assignment 1 Buffer Pool"></a>Assignment 1 Buffer Pool</h2><p>ass1主要需要实现数据库的存储管理部分，分为三部分：</p><ul><li>LRU</li><li>Buffer Pool</li><li>Parallel Buffer Pool</li></ul><p>首先第一个是实现一个LRU，这里主要使用hash list（一个unordered_map 和一个list）就可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cap_; <span class="comment">// the capacity</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt; q_list_; <span class="comment">// linked list of frame_id</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">frame_id_t</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; cache_map_; <span class="comment">// cache map</span></span><br><span class="line"><span class="built_in">std</span>::mutex latch; <span class="comment">// mutex for thread safety</span></span><br></pre></td></tr></table></figure><p>实现过程不复杂但是我这里看了好久，主要是任务说明刚开始没太看懂。它的意思是LRU模块是给上层缓存池用的，缓存池对于一个page进行pin，pin之后相当于DBMS要拿来用这个Page，所以这时候是不能淘汰的（即需要从LRU中删除）。当且仅当buffer unpin到pin_count=0时才丢给LRU进行管理，这时候可以淘汰。</p><p>注意写的时候要完全按照clang-format-tidy进行，否则语法检查不通过。</p><p>单元测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  build git:(ghess/p2-refinement) ✗ ./test/lru_replacer_test</span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 1 test from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 1 test from LRUReplacerTest</span><br><span class="line">[ RUN      ] LRUReplacerTest.SampleTest</span><br><span class="line">[       OK ] LRUReplacerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 1 test from LRUReplacerTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 1 test from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br></pre></td></tr></table></figure><p>之后是缓冲池管理器的实现，BufferPoolManger从DiskManager中获取数据库页，存进内存，同样负责将脏页写回磁盘。</p><p><strong>页表管理</strong></p><p>在数据库原理的博客中我已经介绍了页表的管理，DBMS由于其特殊性（可知道缓存数据是否需要使用、查询临近）等原因可以自己设计缓冲池。</p><p><strong>加锁</strong><br>在数据库的背景下，locks和latches概念不同：<br>Locks：</p><ul><li>保护索引的逻辑内容不被别的<strong>txn</strong>改</li><li>在整个txn过程中保持</li><li>需要回滚</li></ul><p>Latches：</p><ul><li>保护索引的内部关键数据结构不被别的<strong>线程</strong>改</li><li>在整个操作的过程中保持</li><li>不需要回滚（本身就没有事务的概念）</li></ul><p>Page：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data_[PAGE_SIZE]&#123;&#125;;</span><br><span class="line"><span class="comment">/** The ID of this page. */</span></span><br><span class="line"><span class="keyword">page_id_t</span> page_id_ = INVALID_PAGE_ID;</span><br><span class="line"><span class="comment">/** The pin count of this page. */</span></span><br><span class="line"><span class="keyword">int</span> pin_count_ = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */</span></span><br><span class="line"><span class="keyword">bool</span> is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/** Page latch. */</span></span><br><span class="line">ReaderWriterLatch rwlatch_;</span><br></pre></td></tr></table></figure><p>PAGE_SIZE 定为4096 Bytes，即4KB，<code>page_id_</code> 唯一标注了Page，当一个进程pin了页的时候<code>pin_count_</code>就++，然后is_dirty_标注脏页，rwlathch_是封装的读写锁。</p><p><strong>Buffer Pool Manager：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Pointer to the disk manager. */</span></span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Pointer to the log manager. */</span></span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">page_id_t</span>, <span class="keyword">frame_id_t</span>&gt; page_table_;</span><br><span class="line"><span class="comment">/** Replacer to find unpinned pages for replacement. */</span></span><br><span class="line">Replacer *replacer_;</span><br><span class="line"><span class="comment">/** List of free pages. */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt; free_list_;</span><br><span class="line"><span class="comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span></span><br><span class="line"><span class="built_in">std</span>::mutex latch_;</span><br></pre></td></tr></table></figure><ul><li>pages_是缓存池的page数组，由page id进行索引，是缓存池的核心数据</li><li>disk_manager 和log_manger 是指向磁盘管理器和日志管理器的指针</li><li>page_table_是page id和真实frame_id的映射，两者都是int32_t</li><li>replacer_ 是LRUReplacer对象，主要负责unpin之后的frame的管理</li><li>free_list_是一个空闲页的list，里面是frame的id</li><li>latch_是防止资源同时被多个进程读写</li></ul><p>这里要搞明白几个概念，frame是缓存池中的缓存frame page，page_id是请求的页表编号，DBMS向缓存池请求的是page_id，磁盘中存储的也是。所以我们需要一个page_id到frame_id的映射来快速进行缓存选择，所以page_table_一定映射的是<strong>有效的页</strong>，故当淘汰页出缓存时需要将映射删除，这个我debug了好久。</p><p>下面是实现细节：<br><strong>FetchPgImp:</strong><br>本函数实现从缓存中拿page的操作，可以通过page_table_查询page_id对应的缓存frame，如果没查到就在free_list_里面找个空闲的frame_id，如果free_list_为空说明已经用完了缓存（buffer pool满了），这时候需要进行LRU，里面的replacer调用victim方法找到一个“牺牲”的frame_id，如果脏就读回disk，然后在page_table中删除（因为我们已经淘汰了这个页），并将新的page_id =&gt; frame_id映射加入page_table，最后更新frame就可以了（更新page_id，pin_count, is_dirty_）。  </p><p><strong>UnpinPageImpl</strong><br>本函数主要处理unpin一个页的操作，如果pin_count &gt; 0那么减一即可，之后如果<code>==0</code>就加入lru_replacer中。如果进程拿到的pin_count就是&lt;= 0，那么直接return false。这里注意要在pin_count = 0时从page_table_中erase掉：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pages_[frame_id].GetPinCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    page_table_.erase(page_id);</span><br><span class="line">    replacer_-&gt;Unpin(frame_id); <span class="comment">// give it to replacer_</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FlushPageImpl</strong><br>将page刷新到磁盘中,找到这个page然后WritePage就可以了，记得更新page信息。</p><p><strong>FlushAllPgsImp</strong><br>将所有有效地页面全部写回到disk中去，这里注意要在page_table_中找，因为其保存的都是有效的页。</p><p><strong>NewPgImp</strong><br>在buffer pool中创建一个新page，返回指向page的指针。这里麻烦的地方在于缓存池可能满，此时可能需要将页面写回磁盘，并删除映射和重置数据。<br>如果不能新建page（free_list_和LRU都满了），那么return nullptr。找到一个空闲的frame_id并更新data即可。新建页完成之后别忘了让replacer_ Pin一下frame_id（frame对应的页是新建的，不应该在LRU淘汰队列中）。</p><p><strong>DeletePgImp</strong><br>在buffer pool中删除某一个page。注意只能删pin_count&gt;0的，之后更新frame即可。</p><p>这里主要的思路就是通过buffer pool 和lru_replacer进行frame的管理。buffer pool的page_table_是page_id到frame_id的映射，注意这里主要管理pinned page，而unpinned page则会交给lru_replacer进行管理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  build git:(ghess/p2-refinement) ✗ ./test/buffer_pool_manager_instance_test</span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from BufferPoolManagerInstanceTest</span><br><span class="line">[ RUN      ] BufferPoolManagerInstanceTest.BinaryDataTest</span><br><span class="line">[       OK ] BufferPoolManagerInstanceTest.BinaryDataTest (3 ms)</span><br><span class="line">[ RUN      ] BufferPoolManagerInstanceTest.SampleTest</span><br><span class="line">[       OK ] BufferPoolManagerInstanceTest.SampleTest (0 ms)</span><br><span class="line">[----------] 2 tests from BufferPoolManagerInstanceTest (4 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (4 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><p><strong>Parallel Buffer Pool Manager</strong><br>这里的意思是如果只用一个buffer pool的话，虽然我们有互斥锁来保证线程安全，但是当交互的时候可能会产生大量争用，故我们可以设置多个buffer pool来缓解。具体思想就是根据页表编号进行分流，具体是编号page_id % buffer_pool_instance 的缓冲池负责page_id的缓存。</p><p>具体实现在ParallelBufferPoolManager，这里我的数据结构设计如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> num_instances_; <span class="comment">// 缓冲池数量</span></span><br><span class="line">  <span class="keyword">size_t</span> pool_size_; <span class="comment">// 缓冲池Page大小</span></span><br><span class="line">  <span class="keyword">size_t</span> start_index_; <span class="comment">// 起始序号</span></span><br><span class="line">  <span class="built_in">std</span>::mutex parallel_latch_; <span class="comment">// 互斥锁</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BufferPoolManagerInstance *&gt; buffer_pools_; <span class="comment">// 存放缓冲池指针</span></span><br></pre></td></tr></table></figure><p>初始化时new出所有的缓冲池，并由buffer_pools_进行管理。具体的page操作都只需要找到对应的缓冲池进行操作即可，这里注意NewPgImp的时候要加锁，因为涉及到start_index变量的修改问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::scoped_lock <span class="title">scoped_db_latch</span><span class="params">(parallel_latch_)</span></span>;</span><br></pre></td></tr></table></figure><p>加完锁之后从缓冲池</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from ParallelBufferPoolManagerTest</span><br><span class="line">[ RUN      ] ParallelBufferPoolManagerTest.BinaryDataTest</span><br><span class="line">[       OK ] ParallelBufferPoolManagerTest.BinaryDataTest (2 ms)</span><br><span class="line">[ RUN      ] ParallelBufferPoolManagerTest.SampleTest</span><br><span class="line">[       OK ] ParallelBufferPoolManagerTest.SampleTest (1 ms)</span><br><span class="line">[----------] 2 tests from ParallelBufferPoolManagerTest (3 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (4 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><p>gradescope 测试：<br><img src="/images/db/20220407003556.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;assignment-0-C-primter&quot;&gt;&lt;a href=&quot;#assignment-0-C-primter&quot; class=&quot;headerlink&quot; title=&quot;assignment 0  C++ primter&quot;&gt;&lt;/a&gt;assignment 0  C++ primter&lt;/h2&gt;&lt;p&gt;目的是熟悉一下C++，这里的提交需要注意一下格式，比如statement必须在{}之间的要求等等，否则gradescope通过不了。我的第一次提交就有这样的问题，这个评测系统对于格式的要求很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GDB：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cs.cmu.edu/~gilpin/tutorial/&quot;&gt;Debugging Under Unix: gdb Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.techbeamers.com/how-to-use-gdb-top-debugging-tips/&quot;&gt;GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=PorfLSr3DDI&quot;&gt;Give me 15 minutes &amp;amp; I’ll change your view of GDB&lt;/a&gt; [VIDEO]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顺便复习了一下智能指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某一时刻只能有一个 &lt;code&gt;unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;指向对象，不支持拷贝赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;可以拷贝赋值，内有自己的计数器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="DB" scheme="https://blog.difan.tech/categories/DB/"/>
    
    
      <category term="C++" scheme="https://blog.difan.tech/tags/C/"/>
    
      <category term="数据库" scheme="https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++ Coding标准和最佳实践</title>
    <link href="https://blog.difan.tech/2022/03/15/C++%20Coding%20%E6%A0%87%E5%87%86%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://blog.difan.tech/2022/03/15/C++%20Coding%20%E6%A0%87%E5%87%86%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-03-14T16:00:00.000Z</published>
    <updated>2022-03-30T15:29:15.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>编码风格清晰一致</li><li>合理命名，并有注释</li><li>header干净，除非绝对需要，不在header文件中添加系统头文件</li><li>class 的private成员不暴露，所有数据成员都应该是私有的，并加下划线标记</li><li>尽可能使用const</li><li>可移植性，不依赖特定大小的long或者unsigned类型</li><li>内存问题</li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li>遵循三/五法则</li><li>不使用全局数据</li><li>使用构造函数初始化列表</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>nullptr而不是null</p></li><li><p>使用auto只要清晰</p></li><li><p>统一的初始化语法，使用列表初始化{}</p></li><li><p>利用STL，通常情况下没有特别理由不要自己定义已经实现了的数据结构和算法</p><p><a href="http://web.mit.edu/6.s096/www/standards.html">http://web.mit.edu/6.s096/www/standards.html</a></p><p><a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编码风格清晰一致&lt;/li&gt;
&lt;li&gt;合理命名，并有注释&lt;/li&gt;
&lt;li&gt;header干净，除非绝对需要，不在header文件中
      
    
    </summary>
    
    
      <category term="C++" scheme="https://blog.difan.tech/categories/C/"/>
    
    
      <category term="C++" scheme="https://blog.difan.tech/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统总结</title>
    <link href="https://blog.difan.tech/2022/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://blog.difan.tech/2022/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-02-19T12:19:49.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《modern operating systems&gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。</p></blockquote><h1 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1 进程和线程"></a>1 进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><ul><li>多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。</li></ul><span id="more"></span><p><strong>进程与程序的区别</strong>：<br>书中类比食谱和做饭的活动，食谱就是程序（program），而做饭的过程（读食谱，拿食材，做饭）就是进程的概念</p><p><strong>进程创建</strong></p><p>引起创建进程的事件：</p><ul><li>系统初始化</li><li>正在运行的进程执行了系统调用</li><li>用户请求创建进程</li><li>启动批处理作业(batch job),在大型机的批处理操作系统中</li></ul><p>在Linux中，只有一个系统调用可以创建新进程: fork.</p><p><strong>进程终止</strong></p><ul><li>正常退出</li><li>错误退出</li><li>严重错误退出</li><li>被其他进程kill</li></ul><p><strong>进程层次结构</strong></p><ul><li>一个进程只有一个父进程，但可以有0-N个子进程。</li><li>Unix是通过init进程进行初始化的</li><li>Windows在创建进程时，父进程得到子进程的句柄(handle)，但是handle可以传递，故没有进程层次结构的概念。</li></ul><p><strong>进程状态</strong></p><ul><li>运行态（正在使用CPU）</li><li>就绪态（可以运行）</li><li>阻塞态（不能运行，需要条件）</li></ul><p>阻塞状态可能是还没有得到运行的条件，例如在进程中读文件没有可用的输入时，就blocked。当万事俱备时，就可以转入就绪态等待进程调度。<br>从运行态到就绪态相互的过程是进程调度程序引起的，例如分时系统中时间到了就调度正在运行的程序进入就绪状态。</p><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>在具体的实现中，OS维持一张进程表：process table，每一个项成为进程控制块（process control block），包含了关于进程的重要信息：PC: program counter，栈指针，内存分配，打开文件的状态，调度信息等等。</p><p>如图所示，IO对于CPU利用率影响很大：<br><img src="/images/modern_os_assets/2.1.png" alt="image"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>为什么要有线程</li><li>线程实现</li></ul><p>内存是重要资源，操作系统的存储管理主要是针对内存的管理。</p><p>直接引入内存地址带来的问题（在multiprogramming 计算机中）：</p><ul><li>保护问题 protection</li><li>重定位问题（需要用到的地址未知） relocation</li></ul><p>保护问题IBM 360机是通过加入保护键解决的，重定位问题如果使用加入初始地址解决，但是会比较麻烦，因为要判断每个地址需不需要更改。</p><h2 id="地址空间：-一种存储器抽象"><a href="#地址空间：-一种存储器抽象" class="headerlink" title="地址空间： 一种存储器抽象"></a>地址空间： 一种存储器抽象</h2><p>每个进程有自己的地址空间，并且独立于其他进程。</p><ul><li>解决重定位问题：每个CPU配置两个特殊的寄存器，base 和 limit，分别对应物理空间的初始地址和长度（单位byte）。CPU会自动把base加载到进程发出的地址上，同时做界限检查</li></ul><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>把空闲进程存储在磁盘上，不过不够好，因为RAM和磁盘之间速度太低，swap一次时间很长，在后面的虚拟内存技术更好。</p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><ul><li>位图</li><li>空闲链表</li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>问题：软件需要的内存更大</p><p>交换技术不是很好的解决方案，使用虚拟内存的方法更好（1961）：</p><ul><li>每个程序有自己的地址空间</li><li>地址空间分成多个块，每块称为页面（page）</li><li>每一个page映射到物理地址的page中</li><li>用到的时候再装入内存</li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>Paging技术：内存管理单元（MMU）把虚拟地址映射到物理内存地址。</p><p>虚拟地址空间分成以page大小的若干单元，在物理内存中对应的称为页框（page frame）。RAM和磁盘之间的交换是以页框为单位。 页号作为页表的索引，找到对应的页框号（实际物理地址）。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>页表：每一项标记了在/不再内存中和对应的页框号（对应的物理页框号）</p><p>页框号+页内偏移 = 真实物理地址</p><p>页表项</p><ul><li>页框号</li><li>在/不在位，不在就直接缺页中断</li><li>保护位</li><li>修改位，有时称为脏位（dirty bit）</li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul><li>加速虚拟地址到物理地址的转换<ul><li>TLB（快表）</li></ul></li><li>解决巨大的虚拟地址空间的问题<ul><li>多级页表</li><li>倒排页表</li></ul></li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>最优页面置换算法</li><li>NRU 算法（Not Recently Used， 最近未使用）<ul><li>想法：淘汰一个访问修改最少的页面</li></ul></li><li>FIFO<ul><li>最新进入的页面放表尾，最久进入的表头，当却也中断时淘汰表头（很少使用）</li></ul></li><li>second chance 算法（改进）<ul><li>最老页面的R位（访问位）如果是1，那么再给它一次机会，置零后放入队尾</li></ul></li><li>clock 算法<ul><li>避免经常在链表里移动页面</li><li>所有页面保存在一个环形链表里，表指针指向最老的页面</li><li>R=0，淘汰页面，新页面加入此地，之后移位，R=1就置零后移位</li></ul></li><li>LRU算法<ul><li>最近最少使用： 缺页中断发生时，置换未使用时间最长的页面</li><li>NFU时一种近似算法，性能不是很好，老化算法更接近LRU，更有效</li></ul></li></ul><p>文件是对disk的抽象，以名称存取</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>Case Sensitive<ul><li>Linux/UNIX</li></ul></li><li>Case Insensitive<ul><li>DOS</li></ul></li><li>Case Insensitive， Case Preserving<ul><li>Windows</li><li>Mac</li></ul></li></ul><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>三种文件结构：</p><p><img src="/images/modern_os_assets/file_structure.png" alt=""></p><p>a. 字节序列： UNIX，DOS，Windows采用<br>b. 记录序列：读操作返回一个记录，写操作重写或者追加一个记录，大型机常用<br>c.  记录树：树按照键字段进行排序，好处是可以针对特定的键进行快速查找</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul><li>普通文件<ul><li>ASCII 文件</li><li>二进制文件</li></ul></li><li>目录文件</li><li>字符特殊文件（Unix）<ul><li>用于串行IO设备</li></ul></li><li>块特殊文件（Unix）<ul><li>用于磁盘类设备</li></ul></li></ul><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p><img src="/images/modern_os_assets/file_att.png" alt=""></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul><li>create</li><li>delete</li><li>open</li><li>close</li><li>read</li><li>write</li><li>append</li><li>seek</li><li>get attributes</li><li>set attributes</li><li>rename</li></ul><p>一个简单的复制文件的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个4096B的缓冲区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="comment">// 输出文件的保护位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTPUT_MODE 0700</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> in_fd, out_fd, rd_count, wt_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    in_fd = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 打开源文件</span></span><br><span class="line">    <span class="keyword">if</span> (in_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    out_fd = creat(argv[<span class="number">2</span>], OUTPUT_MODE); <span class="comment">//创建目标文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out_fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        rd_count = read(in_fd, buffer, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rd_count &lt;= <span class="number">0</span>) <span class="comment">// 文件结束或者读时出错，则退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        wt_count = write(out_fd, buffer, rd_count);</span><br><span class="line">        <span class="keyword">if</span> (wt_count &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(in_fd);</span><br><span class="line">    close(out_fd);</span><br><span class="line">    <span class="keyword">if</span> (rd_count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;《modern operating systems&amp;gt; 我看的是第四版，主要介绍了操作系统相关的理论性的东西，为了防止遗忘，记录下重点备查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-进程和线程&quot;&gt;&lt;a href=&quot;#1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;1 进程和线程&quot;&gt;&lt;/a&gt;1 进程和线程&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程是程序的一个正在执行的实例，包括相关的PC（program counter），寄存器和变量等。理论上说，每一个进程都有属于自己的虚拟CPU。&lt;/p&gt;
&lt;h3 id=&quot;进程模型&quot;&gt;&lt;a href=&quot;#进程模型&quot; class=&quot;headerlink&quot; title=&quot;进程模型&quot;&gt;&lt;/a&gt;进程模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多道程序设计（multiprogramming）: 指仅使用一个CPU（单核），在进程中来回切换，造成多个进程同时进行的效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="https://blog.difan.tech/categories/OS/"/>
    
    
      <category term="操作系统" scheme="https://blog.difan.tech/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++基础简明总结</title>
    <link href="https://blog.difan.tech/2021/10/20/C++%E5%9F%BA%E7%A1%80%E7%AE%80%E6%98%8E%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.difan.tech/2021/10/20/C++%E5%9F%BA%E7%A1%80%E7%AE%80%E6%98%8E%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-19T16:00:00.000Z</published>
    <updated>2022-03-01T12:12:18.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li>预处理 Preprocessing cpp test.cpp -&gt; test.i</li><li>编译 Compilation g++ -g -S test.i</li><li>汇编 assembly as -o test.o test.s gcc -g -c test.c;</li><li>链接 linker ld -o …</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h4 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h4><p>lvalue, rvalue</p><span id="more"></span><blockquote><p>In C: 左值可以放在赋值语句左边，右值则不行。</p></blockquote><p>左值利用的主要是对象的身份，右值则利用的是对象的值</p><ul><li>decltype 作用左值时自动变成引用</li><li>取地址符作用于一个左值，返回一个右值（指针）</li><li>赋值运算符左侧作为左值运算对象</li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>一般来说是占用空间小的向占用空间大的方向转换，如果相同则无符号转换。</p><ul><li>数组转换为指针：赋值时</li><li>指针转换</li><li>转换为bool</li><li>non-const 指针或引用 向const 指针或引用转换</li><li>类的类型转换 如 <code>while (cin &gt;&gt; str)</code> IO库中定义了istream转换规则。</li></ul><p>显示转换：</p><ul><li>强制类型转换</li><li>命名的强制类型转换<ul><li>static_cast <code>double db = static_cast&lt;double&gt;(j) /i;</code> 大转小也可以（精度损失）</li><li>dynamic_cast 支持运行时类型识别</li><li>const_cast 改变运算对象的底层const，去掉const，只能改变const属性，无法改动类型</li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><code>throw</code>，结束程序执行，回到函数调用处，抛出一个异常,并做资源清理</li><li><code>try-catch</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;my exception&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> MyException();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MyException&amp; e) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyException\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e.msg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>头文件</p><ul><li>iostream</li><li>fstream</li><li>sstream</li></ul><p>状态查看</p><ul><li>s.bad()</li><li>s.good()</li><li>s.fail() 数据错误</li><li>s.bad() IO流错误</li><li>s.clear() 状态位复位</li><li>s.eof() 文件结束符</li></ul><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>为什么要有Stream ?</p><pre><code>Stream 是输入输出的抽象，提供了String类型和别的类型数据的相互转换</code></pre><p>Stream分类：</p><ul><li>输入流 InputStream </li><li>输出流 OutputStream</li></ul><h4 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h4><p>只能用 &lt;&lt; 符号接受数据，将数据转换为String并发送给Stream<br>举例：</p><ul><li>std::cout</li><li>std::ofstream ：file stream是一种type</li><li>ostringstring :把String当成Stream</li></ul><p>fstream <strong>文件的例子</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//You should include fstream</span></span><br><span class="line"><span class="function">ofstream <span class="title">myStream</span><span class="params">(<span class="string">&quot;File.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>打开文件 <code>void open(const char *filename), ios::openmode mode);</code><ul><li>ios::app 追加到文件末尾</li><li>ios::ate 定位到文件末尾</li><li>ios::in 用于读取</li><li>ios::out 写入文件</li><li>ios::trunc 截断模式,覆盖掉原有</li><li>e.g. <code>ofstm.open(&quot;file.dat&quot;, ios::out|ios::trunc);</code></li></ul></li><li>关闭 void close();</li></ul><p>ostringstream 的例子(stringstream可以读入读出)：<strong>字符串的例子</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">ostringstream</span> <span class="title">oss</span><span class="params">(<span class="string">&quot;Ito En Green Tea&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; oss.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    oss &lt;&lt; <span class="number">16.9</span> &lt;&lt; <span class="string">&quot;Oh&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; oss.str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ito En Green Tea</span><br><span class="line">16.9Oh Green Tea</span><br></pre></td></tr></table></figure><h4 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h4><ul><li>std::cin</li><li>ifstream</li></ul><p>fstream 的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//You should include fstream</span></span><br><span class="line"><span class="function">ifstream <span class="title">myFileStream</span><span class="params">(<span class="string">&quot;file.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> integer;</span><br><span class="line">myFileStream &gt;&gt; integer;</span><br><span class="line"><span class="comment">// Or:</span></span><br><span class="line">ifstream myFileStream2;</span><br><span class="line">myFileStream2.open(<span class="string">&quot;file.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>mystream.fail()</code>可以检测stream是否fail，例如</p><ul><li>读文件读到结束</li><li>文件不存在</li><li>读入的类型错误</li></ul><h4 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h4><p>cin 一直读到空格，换行符等，如果输入单词可能有问题</p><p>但是要用getline要注意下面的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val2;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">getline(<span class="built_in">cin</span>, val2); <span class="comment">// read \n</span></span><br></pre></td></tr></table></figure><p>第二次读入的就是第一次的\n，因为cin 并不会处理后面的\n，只将前面的 \n 空格略去，等于说此时<code>getline</code>在streambuffer里读入的是第一次结尾的\n。</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><ul><li>size(), 返回string::size_type</li><li>empty()</li><li><code>[]</code> 以string::size_type为索引，注意类型是unsigned 的</li><li>字符串相关操作：<ul><li>str1 + str2</li><li>str1 + “字面量”</li><li>os &lt;&lt; str, is &gt;&gt; s</li><li>getline(cin, str)，读取一行，丢弃换行符</li><li>== 按字符序比大小，如果前面相同比长度，长者大</li></ul></li><li>cctype 头文件<ul><li>isupper(), toupper() 大写</li><li>islower(), tolower() 小写</li><li>isdigit(), isalpha() 数字和字幕</li><li>ispunct() 标点</li><li>isspace() 空白</li></ul></li></ul><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>顺序容器的元素排列顺序与其值无关，而仅仅由元素添加到容器里的次序决定。</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>功能：</p><ul><li>创建<ul><li><code>vector&lt;int&gt; a(v2)</code>; <code>vector&lt;int&gt; a = v2</code>;</li><li><code>vector&lt;int&gt; a&#123;0, 1, 2, 3, 4&#125;</code>;</li><li><code>vector&lt;int&gt; a = &#123;0, 1, 2, 3, 4&#125;</code>;</li><li><code>vector&lt;int&gt; a(n)</code>: 初始化为0</li><li><code>vector&lt;int&gt; a(n, val)</code>: n个以val为值的vector元素</li></ul></li><li>增加<ul><li>push_back(val):在最后增加</li><li>insert(index, val):在index处（或理解为index前面）增加</li></ul></li><li>删除<ul><li>erase(v.begin()+i)：按地址删除</li><li>pop_back();</li><li>clear()：清除所有 </li></ul></li><li>修改<ul><li>v[i] = val:没有边界检查</li><li>v.at(i) = val</li></ul></li><li>查找<ul><li>v.at(i)</li><li>v[i] ：没有边界检查</li><li>v.front();</li><li>v.back();</li></ul></li><li>其他<ul><li>v.empty();</li><li>v.reserve(size): 预留size个地方</li></ul></li></ul><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端队列，跟vector类似，用的比较少，好处在于<strong>大量插入删除操作时速度快</strong></p><p>有和vector一样的函数，还有<strong>front操作</strong>：</p><ul><li>push_front(val)</li><li>pop_front()</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>插入删除开销少，但是不能根据index进行快速定位<br>有<strong>front操作</strong>：</p><ul><li>push_front(val)</li><li>pop_front()</li></ul><p>使用技巧</p><ul><li>可以先reserve一定大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec.reserve(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line"> vec.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><h4 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h4><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h4><h3 id="基于hash-table的容器"><a href="#基于hash-table的容器" class="headerlink" title="基于hash table的容器"></a>基于hash table的容器</h3><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>迭代器</p><ul><li>begin(), end() 返回首尾迭代器，是否为const由元素决定</li><li>cbegin(),cend()返回const_iterator</li><li>算术运算+-</li></ul><h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><p>参考C++Primer第10章</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><code>&lt;memory&gt;</code></p><ul><li>unique_ptr : move 语意， 资源只有一个指向它</li><li>shared_ptr : copy 语意， 资源可以有多个指向它，要知道最后一个用的，没有人指向我，那就delete</li><li>weak_ptr</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;classA&gt; r1 &#123; <span class="built_in">std</span>::make_unique&lt;classA&gt;()&#125;;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;classA&gt; r2 &#123; <span class="built_in">std</span>::shared_unique&lt;classA&gt;()&#125;;</span><br><span class="line"><span class="function">weak_ptr&lt;classA&gt; <span class="title">wr</span><span class="params">(r2)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (wr.expired()) <span class="keyword">return</span>; <span class="comment">//过期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> resource = wr.lock();</span><br></pre></td></tr></table></figure><p>常用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;X&gt; <span class="title">make_X</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">// etc.</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;X&gt;&#123;<span class="keyword">new</span> X&#123;i&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">user</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, ios_base::openmode mode)</span> </span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;fstream&gt; fp &#123;<span class="keyword">new</span> fstream(name, mode)&#125;;</span><br><span class="line"><span class="keyword">if</span>(!*p) <span class="comment">// 确定文件打开</span></span><br><span class="line"><span class="keyword">throw</span> No_file&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>RAII： Resource acquisition Is Initialization<br>资源获取即初始化</p><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><ul><li>匿名函数</li><li>capture list 外部变量访问方式说明符<ul><li><code>=</code> 只读</li><li><code>&amp;</code> 可修改</li><li>空的，不用到外面的变量 </li><li><code>[=, &amp;x, &amp;y]</code>，x,y 可改，其余变量不能修改</li><li><code>[&amp;, x, y]</code>除了x,y以外的外部变量都可以修改</li></ul></li><li><code>-&gt;</code>可以省略，让编译器自己推导</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (parameter <span class="built_in">list</span>) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//e.g.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;lambda function&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> square = [=, &amp;name](<span class="keyword">const</span> <span class="keyword">int</span>&amp; value) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">name = <span class="string">&quot;inda&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> value*value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>C++14 generic lambda</li></ul><h2 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="显式"><a href="#显式" class="headerlink" title="显式"></a>显式</h4><ul><li>C style: (type) expression</li><li><code>const_cast&lt;type&gt;</code> (expr): 修改类型的const属性</li><li><code>dynamic_cast&lt;type&gt; (expr)</code>: <em>runtime</em> 执行转换，若失败，expr被认定为nullptr，若引用失败catch std::bad_cast</li><li><code>static_cast&lt;type&gt;</code>: 非动态转换，没有运行时类检查来保证转换的安全性，例如int到size_t</li><li><code>reinterpret_cast&lt;type&gt; (expr)</code> : 最好不用</li></ul><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><ul><li>注意类的隐式类型转换<ul><li>例如有函数combine(const Sale_data &amp;sd),且有构造函数可以接受string, 则combine(string(“str”))则会默认生成一个Sale_data类</li><li>拷贝形式： Sales_data item = string(“str”);</li><li>可以使用<code>explicit</code> 关键字避免不期望的隐式类型转换</li></ul></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>定义一个范围</li><li>类本身就是一个特殊的命名空间</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> My_code &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">sqrt</span><span class="params">(<span class="built_in">complex</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用干的时候加上命名空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">My_code::main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">complex</span> z&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> My_code::main():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要在头文件里使用命名空间（using namespace …)</li></ul><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><p><strong>C struct:</strong></p><ul><li>没有封装</li><li>没有操作</li></ul><p><strong>类Class</strong></p><ul><li>数据抽象</li><li>封装<ul><li>private</li><li>public</li><li>protected (子类)</li></ul></li><li>动态绑定（运行时绑定）</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">X(Sometype); <span class="comment">// 构造函数</span></span><br><span class="line">X();<span class="comment">// 默认构造函数</span></span><br><span class="line">X(<span class="keyword">const</span> X&amp;); <span class="comment">// 复制构造函数</span></span><br><span class="line">X(<span class="keyword">const</span> X&amp;&amp;); <span class="comment">// 移动构造函数，用std::move()调用</span></span><br><span class="line">X&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> X&amp;); <span class="comment">// 复制操作符</span></span><br><span class="line">X&amp; <span class="keyword">operator</span>=(X&amp;&amp;); <span class="comment">// 移动操作符</span></span><br><span class="line">~X(); <span class="comment">// 析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>friend 函数</strong></p><ul><li><p>定义在类外部</p></li><li><p>有权访问累的所有private 成员和protected 成员</p></li><li><p>friend 函数并不是成员函数</p><pre><code>相同Class的各个objects互为friends</code></pre></li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>常量成员函数</li><li>常量对象 -&gt; 只能调用 const 函数</li></ul><p>const &amp; constexpr</p><ul><li>修饰对象<ul><li>const主要表示这是个常量，不会变动</li><li>constexpr是修饰一个常量表达式</li></ul></li><li>修饰函数<ul><li>const只能用于<strong>非静态成员函数</strong>，保证函数不修改任何<strong>非静态数据</strong></li><li>constexpr适用于常量表达式，通常是简单函数，只允许return语句，参数和返回值必须是字面量。</li></ul></li></ul><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><h3 id="virtual-关键字"><a href="#virtual-关键字" class="headerlink" title="virtual 关键字"></a>virtual 关键字</h3><p>在继承时通过晚绑定和vtable来实现多态，这样就可以用基类指针来操作各种派生类。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><ul><li>vitual double function() = 0;</li></ul><p>声明一个function为接口，接口类不能被实例化，但是可以有成员变量，该类是纯虚类。</p><h2 id="类的不可改性"><a href="#类的不可改性" class="headerlink" title="类的不可改性"></a>类的不可改性</h2><ul><li>const 成员函数</li><li>const 成员变量</li><li>class 为final： class A final {} 不能再被继承了</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>递归<ul><li>好处：<ul><li>分而治之</li><li>简洁性好</li></ul></li></ul></li><li>迭代<ul><li>好处<ul><li>效率高：编译器在同一个stack里面容易优化代码，cross-stack 优化不容易做</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h1&gt;&lt;h2 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;预处理 Preprocessing cpp test.cpp -&amp;gt; test.i&lt;/li&gt;
&lt;li&gt;编译 Compilation g++ -g -S test.i&lt;/li&gt;
&lt;li&gt;汇编 assembly as -o test.o test.s gcc -g -c test.c;&lt;/li&gt;
&lt;li&gt;链接 linker ld -o …&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;表达式&quot;&gt;&lt;a href=&quot;#表达式&quot; class=&quot;headerlink&quot; title=&quot;表达式&quot;&gt;&lt;/a&gt;表达式&lt;/h2&gt;&lt;h4 id=&quot;左值右值&quot;&gt;&lt;a href=&quot;#左值右值&quot; class=&quot;headerlink&quot; title=&quot;左值右值&quot;&gt;&lt;/a&gt;左值右值&lt;/h4&gt;&lt;p&gt;lvalue, rvalue&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="https://blog.difan.tech/categories/C/"/>
    
    
      <category term="C++" scheme="https://blog.difan.tech/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>常用数据结构与算法代码</title>
    <link href="https://blog.difan.tech/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.difan.tech/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2022-04-06T17:33:21.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板练习"><a href="#模板练习" class="headerlink" title="模板练习"></a>模板练习</h2><p><strong>数组</strong></p><ul><li>快排 <a href="https://leetcode-cn.com/problems/sort-an-array/">912 排序</a></li><li>堆 <a href="https://www.acwing.com/problem/content/840/">838. 堆排序</a></li><li>归并 <a href="https://leetcode-cn.com/problems/sort-an-array/">912 排序</a></li><li>二分 <a href="https://www.acwing.com/problem/content/791/">789. 数的范围</a> <a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根</a></li><li>大整数 +-* /</li><li>前缀和<ul><li>二维前缀和 <a href="https://leetcode-cn.com/problems/O4NDxx/">剑指 Offer II 013. 二维子矩阵的和</a></li></ul></li><li>差分 <a href="https://www.acwing.com/problem/content/799/">797. 差分</a><ul><li>二维差分</li></ul></li><li>位运算 <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></li><li>离散化 <a href="https://www.acwing.com/blog/content/1778/">区间和</a></li><li>双指针 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a><ul><li>KMP <a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></li></ul></li><li>区间合并 <a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a> 两种写法<span id="more"></span></li></ul><p><strong>表</strong></p><ul><li>链表合并 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> (迭代，递归方法)</li><li>Union-find <a href="https://www.acwing.com/problem/content/838/">836. 合并集合</a></li><li>链表 <a href="https://www.acwing.com/problem/content/828/">AcWing 826. 单链表</a><ul><li><a href="https://www.acwing.com/problem/content/829/">827. 双链表</a></li></ul></li><li>LRU <a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></li><li>LFU <a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></li></ul><p><strong>栈 队列</strong></p><ul><li>单调栈 <a href="https://leetcode-cn.com/problems/daily-temperatures/">LC 739. 每日温度</a></li><li>单调队列 <a href="https://www.acwing.com/problem/content/156/">154. 滑动窗口</a></li></ul><p><strong>搜索与图</strong></p><ul><li>DFS <a href="https://leetcode-cn.com/problems/binary-tree-coloring-game/">1145. 二叉树着色游戏</a> <a href="https://www.acwing.com/file_system/file/content/whole/index/content/4122628/">树的重心</a> <a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a> <a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></li><li>BFS <a href="https://www.acwing.com/file_system/file/content/whole/index/content/544216/">图中点的层次</a></li><li>拓扑排序 <a href="https://www.acwing.com/file_system/file/content/whole/index/content/441348/">有向图的拓扑序列</a></li><li>Dijkstra <a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路 I</a><ul><li>堆优化 <a href="https://www.acwing.com/problem/content/852/">850. Dijkstra求最短路 II</a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a><ul><li>(Bellman-ford 可不看)负权边Dijkstra <a href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路</a></li><li>(SPFA) 堆优化 Bellman-ford <a href="https://www.acwing.com/problem/content/853/">851. spfa求最短路</a></li></ul></li></ul></li><li>最小生成树 <a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a> <a href="https://leetcode-cn.com/problems/accounts-merge/">721. 账户合并</a> <a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">685. 冗余连接 II</a><ul><li>prim</li><li>kruskal</li></ul></li><li>二分图判定<ul><li>DFS染色<ul><li>判别 <a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a></li><li>染色 <a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a></li></ul></li><li>匈牙利算法<ul><li><a href="https://www.acwing.com/solution/content/5334/">二分图的最大匹配</a></li></ul></li></ul></li></ul><p><strong>数学</strong></p><ul><li>质数判别：试除法</li><li>质因数分解</li><li>筛选质数：埃式筛法 线性筛法 <a href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></li><li>因数之和，因数个数（公式法，一般法）<ul><li><a href="https://www.acwing.com/problem/content/872/">872约数个数</a></li><li><a href="https://leetcode-cn.com/problems/four-divisors/">1390. 四因数</a></li></ul></li><li>最大公约数 欧几里得  <a href="https://www.acwing.com/problem/content/874/">最大公约数</a></li><li>求欧拉函数  <a href="https://www.acwing.com/problem/content/875/">欧拉函数</a></li><li>筛法求欧拉函数 <a href="https://www.acwing.com/activity/content/problem/content/943/">筛法</a></li><li>快速幂 <a href="https://www.acwing.com/problem/content/877/">快速幂</a> <a href="https://www.acwing.com/problem/content/878/">求逆元</a></li><li><a href="https://www.acwing.com/problem/content/879/">扩展欧几里得</a> <a href="https://www.acwing.com/problem/content/880/">线性同余方程</a></li></ul><h2 id="数组与串"><a href="#数组与串" class="headerlink" title="数组与串"></a>数组与串</h2><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912 排序</a> 练排序<br><a href="https://leetcode-cn.com/problems/graph-valid-tree/">261. 以图判树</a><br><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a><br><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a><br><a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a><br><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a> 练KMP<br><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a><br><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a> 自定义排序</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 这样分 &lt;=j的元素都是小于x的值</span></span><br><span class="line">    <span class="keyword">int</span> x = a[l], i = l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">quick_sort(a, l, j);</span><br><span class="line">quick_sort(a, j+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (nums[++i] &lt; x);</span><br><span class="line"><span class="keyword">while</span> (nums[--j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) swap(nums[i], nums[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quick_sort(nums, l, j);</span><br><span class="line">quick_sort(nums, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;<span class="comment">//版本2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l,  pivot = a[l], j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pivot) j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    a[i] = pivot;</span><br><span class="line">    quick_sort(a, l, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   swap(nums[l], nums[l + rand() % (r - l + <span class="number">1</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pivot = nums[l], i = l, j = r;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= pivot) j--;</span><br><span class="line">nums[i] = nums[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot) i++;</span><br><span class="line">nums[j] = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums[i] = pivot;</span><br><span class="line">quick_sort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">quick_sort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>topK</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int topK(int a[], int k, int l, int r) &#123;</span><br><span class="line">    if (l &gt;&#x3D; r) return a[l];</span><br><span class="line">  </span><br><span class="line">    int x &#x3D; a[ l + r &gt;&gt; 1], i &#x3D; l - 1, j &#x3D; r + 1;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        do i++; while (q[i] &lt; x);</span><br><span class="line">        do j--; while (q[j] &gt; x);</span><br><span class="line">        if (i &lt; j) swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; k - 1) return topK(a, k, j + 1, r);</span><br><span class="line">    else return topK(a, k, l, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) swap(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) &#123;</span><br><span class="line">        q[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge the two orded seq</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p1 = left, p2 = left2;</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;  <span class="comment">// index for new array</span></span><br><span class="line">  <span class="keyword">int</span> tmp[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= right &amp;&amp; p2 &lt;= right2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[p1] &lt;= a[p2]) &#123;</span><br><span class="line">      tmp[index++] = a[p1++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[index++] = a[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store the rest array</span></span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= right) &#123;</span><br><span class="line">    tmp[index++] = a[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right2) &#123;</span><br><span class="line">    tmp[index++] = a[p2++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">    a[left + i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[left, right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    merge_sort(a, left, mid);</span><br><span class="line">    merge_sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(a, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[j], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for ( ; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[i]; j--) &#123;</span></span><br><span class="line">        <span class="comment">//     nums[j + 1] = nums[j];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a> 二分简化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： 不满足 | 满足</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">//严谨点也可以</span></span><br><span class="line">    <span class="comment">/* return (l == r &amp;&amp; nums[l] == target) ? l : -1(or N);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： 满足 | 不满足</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;  </span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == x) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt;= x) &#123;</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找&gt;=</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search_greatequ</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= x) &#123; <span class="comment">// if greater equal than x, modify here if &gt;</span></span><br><span class="line">      end = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.size(); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        res.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    <span class="keyword">while</span> (res.size() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span> ) &#123;</span><br><span class="line">        res.pop_back();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">my_minus</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>)</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) &#123;</span><br><span class="line">        C.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) &#123;</span><br><span class="line">            C.push_back( (A[i] * b + t) % <span class="number">10</span>);</span><br><span class="line">            t = (A[i] * b + t)/ <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            C.push_back(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>S[i] = a[1] + a[2] + … a[i]<br>a[l] + … + a[r] = S[r] - S[l - 1]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">s[i] = s[i<span class="number">-1</span>] + a[i]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>i - j: s[j+1] - s[i + 1]</code></p><p>二维：</p><pre><code>S[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">pref_sum[i][j] = pref_sum[i - <span class="number">1</span>][j] + pref_sum[i][j - <span class="number">1</span>] - pref_sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">sort(intervals.begin(), intervals.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = INT_MIN; </span><br><span class="line"><span class="keyword">int</span> right = INT_MIN;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; in : intervals) &#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt; in[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (left != INT_MIN) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line">left = in[<span class="number">0</span>];</span><br><span class="line">right = in[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">right = max(right, in[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (right != INT_MIN) ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;left, right&#125;));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值</span><br><span class="line">sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序</span><br><span class="line">alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二分求出x对应的离散化的值</span><br><span class="line">int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置</span><br><span class="line">&#123;</span><br><span class="line">    int l &#x3D; 0, r &#x3D; alls.size() - 1;</span><br><span class="line">    while (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid &#x3D; l + r &gt;&gt; 1;</span><br><span class="line">        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;</span><br><span class="line">        else l &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.size(), m = needle.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>next[j-1]</code>的含义是跳了之后的下一个元素</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li>将两个集合合并</li><li>询问是否在一个集合当中</li></ul><p>近乎O(1)复杂度</p><p><strong>基本原理：</strong> 每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code>表示x的父节点。</p><ul><li>树根 <code>if(p[x])==x</code></li><li>求x的集合编号 <code>while(p[x] != x) x=p[x];</code></li><li>合并两个集合：px 是x的集合编号，py是y的集合编号，<code>p[x]=y</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">// 返回根节点并路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) &#123;  </span><br><span class="line">        p[x] = find(p[x]);  </span><br><span class="line"> &#125;  </span><br><span class="line">    <span class="keyword">return</span> p[x];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (parent[x] != x) &#123;  </span><br><span class="line">parent[x] = parent[parent[x]]; </span><br><span class="line">x = parent[x];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// combine</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (find(a) == find(b)) <span class="keyword">return</span>;</span><br><span class="line">size[find(a)] += size[find(b)];</span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;<span class="comment">// store the tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) &#123; <span class="comment">// if empty</span></span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123; <span class="comment">// query the str appearance time</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/">LC reverse LL</a><br><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a><br><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a><br><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a><br><a href="https://www.acwing.com/problem/content/1453/">链表快速排序</a></p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stl, list</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line">lst.push_back(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">std</span>::find(l.begin(), l.end(), <span class="number">16</span>);</span><br><span class="line">lst.insert(it, <span class="number">42</span>); <span class="comment">// insert before 42</span></span><br></pre></td></tr></table></figure><p>数组</p><p>head存链表头，val存数值，next存下一个node的idx，idx表示当前用到了哪个（还没用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head = <span class="number">-1</span>, val[N], next[N], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">val[idx] = a, next[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = next[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>翻转链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *prev = <span class="literal">nullptr</span>, *ne = head;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ne = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = ne;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursive</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针模板</span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">      </span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>存储结构<ul><li>开放寻址</li><li>拉链法</li></ul></li></ul><p>常见情景：$10^9$ 映射到$10^5$ 个数</p><h3 id="LRU-amp-amp-LFU"><a href="#LRU-amp-amp-LFU" class="headerlink" title="LRU &amp;&amp; LFU"></a>LRU &amp;&amp; LFU</h3><p>最近最少使用：溢出时淘汰最远的。</p><p>这里可以使用 <code>int min_freq</code> 存最小的理由是：</p><ul><li>如果一个item是freq最小的，且list只有它一个元素，那么freq+1就是最小的</li><li>如果新进的元素是最新的元素，那么 <code>min_freq = 1</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用双端链表+哈希表：</span></span><br><span class="line"><span class="comment">- 双端链表存每个key，value对</span></span><br><span class="line"><span class="comment">- 哈希表存key, 链表元素迭代器的映射</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">make_recently函数: 删掉key对应的list节点，并加到尾部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">get：</span></span><br><span class="line"><span class="comment">- 用哈希表查node，如果在就make_recently，返回value</span></span><br><span class="line"><span class="comment">- 如果不在return -1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">put:</span></span><br><span class="line"><span class="comment">- 用哈希表查node，如果在就make_recently，修改value</span></span><br><span class="line"><span class="comment">- 如果不在检查是否溢出，溢出就删除front()，加入最新的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; cache_map; <span class="comment">// key to list node</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q_list; <span class="comment">// key list</span></span><br><span class="line">    <span class="keyword">int</span> cap = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_map.find(key) != cache_map.end()) &#123; <span class="comment">// if find int the map</span></span><br><span class="line">            <span class="keyword">auto</span> lp = *cache_map[key];</span><br><span class="line">            make_recently(lp.first);</span><br><span class="line">            <span class="keyword">return</span> lp.second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if in the map</span></span><br><span class="line">        <span class="keyword">if</span> (cache_map.find(key) != cache_map.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lp = cache_map[key];</span><br><span class="line">            lp-&gt;second = value;</span><br><span class="line">            make_recently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// if not in the map</span></span><br><span class="line">        <span class="keyword">if</span> (cache_map.size() &gt;= cap) &#123;</span><br><span class="line">            delete_key(q_list.front().first);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        q_list.push_back(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        cache_map[key] = prev(q_list.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_recently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = delete_key(key);</span><br><span class="line">        q_list.push_back(<span class="built_in">make_pair</span>(key, val));</span><br><span class="line">        cache_map[key] = prev(q_list.end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete_key</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itr = cache_map[key];</span><br><span class="line">        <span class="keyword">int</span> val = (*itr).second;</span><br><span class="line">        q_list.erase(itr);</span><br><span class="line">        cache_map.erase(key);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>最不经常使用：溢出时淘汰频率最低的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _key = <span class="number">0</span>, <span class="keyword">int</span> _val = <span class="number">0</span>, <span class="keyword">int</span> _freq = <span class="number">0</span>) &#123;</span><br><span class="line">        value = _val;</span><br><span class="line">        key = _key;</span><br><span class="line">        freq = _freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;::iterator&gt; key_node_map;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;Node&gt;&gt; freq_node_map;</span><br><span class="line">    <span class="keyword">int</span> min_freq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        min_freq = <span class="number">0</span>;</span><br><span class="line">        key_node_map.clear();</span><br><span class="line">        freq_node_map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find in the key node</span></span><br><span class="line">        <span class="keyword">if</span> (key_node_map.find(key) != key_node_map.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l_itr =  key_node_map[key];</span><br><span class="line">            <span class="keyword">int</span> res_val = l_itr-&gt;value;</span><br><span class="line">            <span class="keyword">int</span> cur_freq = l_itr-&gt;freq;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update </span></span><br><span class="line">            freq_node_map[cur_freq].erase(l_itr);</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map[cur_freq].empty()) &#123;</span><br><span class="line">                freq_node_map.erase(cur_freq);</span><br><span class="line">                <span class="keyword">if</span> (cur_freq == min_freq) &#123;</span><br><span class="line">                    min_freq++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            freq_node_map[cur_freq + <span class="number">1</span>].push_front(Node(key, res_val, cur_freq + <span class="number">1</span>));</span><br><span class="line">            key_node_map[key] = freq_node_map[cur_freq + <span class="number">1</span>].begin();</span><br><span class="line">            <span class="keyword">return</span> res_val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key_node_map.find(key) != key_node_map.end()) &#123;</span><br><span class="line">            <span class="comment">// if find the key</span></span><br><span class="line">            <span class="keyword">auto</span> l_itr = key_node_map[key];</span><br><span class="line">            <span class="keyword">int</span> freq_put = l_itr-&gt;freq;</span><br><span class="line">            freq_node_map[freq_put].erase(l_itr);</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map[freq_put].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                freq_node_map.erase(freq_put);</span><br><span class="line">                <span class="keyword">if</span> (min_freq == freq_put) &#123;</span><br><span class="line">                    min_freq++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            freq_node_map[freq_put + <span class="number">1</span>].push_front(Node(key, value, freq_put + <span class="number">1</span>));</span><br><span class="line">            key_node_map[key] = freq_node_map[freq_put + <span class="number">1</span>].begin();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">         <span class="comment">// not find</span></span><br><span class="line">        <span class="keyword">if</span> (key_node_map.size() &gt;= cap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq_node_map.find(min_freq) != freq_node_map.end()) &#123;</span><br><span class="line">                <span class="comment">// remove the least frequently used  </span></span><br><span class="line">                <span class="keyword">int</span> min_key  = freq_node_map[min_freq].back().key;</span><br><span class="line">                freq_node_map[min_freq].pop_back();</span><br><span class="line">                key_node_map.erase(min_key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (freq_node_map[min_key].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    freq_node_map.erase(min_key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// min_freq no found</span></span><br><span class="line">                <span class="built_in">cerr</span> &lt;&lt;  <span class="string">&quot;Min Frequency No Found.&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add it</span></span><br><span class="line">        min_freq = <span class="number">1</span>;</span><br><span class="line">        freq_node_map[min_freq].push_front(Node(key, value, <span class="number">1</span>));</span><br><span class="line">        key_node_map[key] = freq_node_map[<span class="number">1</span>].begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">LC 739. 每日温度</a><br><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I - 力扣（LeetCode） (leetcode-cn.com)</a><br><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a><br><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a><br><a href="https://www.acwing.com/problem/content/156/">AcWing 154. 滑动窗口</a><br><a href="https://leetcode-cn.com/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a></p><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>stack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">stk.push(<span class="number">10</span>);</span><br><span class="line">stk.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组实现</span></span><br><span class="line"><span class="keyword">int</span> stk[N], tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// top</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>queue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert to tail</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// front</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// empty</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>本质上是可以暂存左边或者右边<strong>最近</strong>，<strong>符合要求的</strong>序列（一个递增序列），而对于离得比较远的还比最近还差的那就丢弃。<br>例如：</p><p>1 3 2 1 6 9 4 5 3 4 13</p><p><strong>例题： 输出左边第一个比它小的：</strong><br>那么在栈中存一个<em>递增序列</em>，从小到大，栈顶元素小于当前元素</p><p>栈：</p><ul><li>先进1，然后进3，</li><li>2的时候比3小</li><li>3出栈，2进栈（对于后面2离得比3近并且比3小）</li><li>1：全部出栈，1进</li><li>6，9进栈</li><li>4：6，9出，4进栈</li><li>5：5进栈</li><li>3：5，4出栈</li><li>4：4进栈</li><li>13：13进栈</li></ul><p>此时：1，4，13，栈中始终都是按序排的，栈顶是最近最不满足的。</p><p><strong>Q  为什么要用栈？队列可以不可以</strong></p><p><strong>A</strong> ：栈FILO的特点能保留元素<em>离得最近</em>的一些值，也就是说pop出来的都是离$n[i]$ 最近的值，对于”第一个比它小的“，”第一个比它大的“这种问题非常合适。</p><p>N 数列，输出每个数字左边第一个比它小的数字，不存在则-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出每个数左边离它最近的比它大/小的数</span></span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; check(stk[tt], i)) tt -- ;</span><br><span class="line"><span class="comment">//输出结果，栈顶就是极值</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    stk[ ++ tt] = i; <span class="comment">// 保存i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ STL写法</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= vec.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!vec.empty() &amp;&amp; check(vec, sta, i)) &#123;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sta.push(vec[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a><br><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a><br><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a><br><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a><br><a href="https://leetcode-cn.com/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a><br><a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></p><h3 id="树的实现方式"><a href="#树的实现方式" class="headerlink" title="树的实现方式"></a>树的实现方式</h3><ul><li>数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tree(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//0不用，2i + 1右子树，2i左子树</span></span><br><span class="line"><span class="keyword">int</span> sz = n;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span>*i &lt;= sz &amp;&amp; check(<span class="number">2</span> * i)) ...<span class="comment">//左子树</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span>*i &lt;= sz &amp;&amp; check(<span class="number">2</span> * i)) ...<span class="comment">//右子树</span></span><br></pre></td></tr></table></figure><ul><li>结构体</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode(<span class="keyword">int</span> _val = <span class="number">0</span>) : val(_val)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树-BST"><a href="#二叉搜索树-BST" class="headerlink" title="二叉搜索树 BST"></a>二叉搜索树 BST</h3><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a><br><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><br><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a><br><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p><h4 id="红黑树实现"><a href="#红黑树实现" class="headerlink" title="红黑树实现"></a>红黑树实现</h4><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>是<strong>完全二叉树</strong></p><ul><li>插入一个数 :<code>heap[++size] = x; up(size)</code> 放到最后一个，然后上移</li><li>求最小值: <code>heap[1]</code></li><li>删除最小值: 覆盖top， 然后down一遍 <code>heap[1] = heap[size]; size--; down(1)</code></li><li>删除任意一个元素 k : <code>heap[k] = heap[size]; size--; down(k); up(k)</code></li><li>修改任意一个元素: <code>heap[k] = x; down(k), up(k);</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//如何手写一个堆？完全二叉树 5个操作</span></span><br><span class="line"><span class="comment">//1. 插入一个数         heap[ ++ size] = x; up(size);</span></span><br><span class="line"><span class="comment">//2. 求集合中的最小值   heap[1]</span></span><br><span class="line"><span class="comment">//3. 删除最小值         heap[1] = heap[size]; size -- ;down(1);</span></span><br><span class="line"><span class="comment">//4. 删除任意一个元素   heap[k] = heap[size]; size -- ;up(k); down(k);</span></span><br><span class="line"><span class="comment">//5. 修改任意一个元素   heap[k] = x; up(k); down(k);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = u;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * u &lt;= size &amp;&amp; h[<span class="number">2</span> * u &lt; h[min]]) min = <span class="number">2</span> * u;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= size &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span> &lt; h[min]]) min = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (min != u) &#123;</span><br><span class="line">swap(h[u], h[min]);</span><br><span class="line">down(min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">// if father &gt; self, swap </span></span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u]) &#123; <span class="comment">// father node &gt; node u</span></span><br><span class="line">swap(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">u /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span>; i; i--) &#123;</span><br><span class="line">down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><p><a href="https://leetcode-cn.com/problems/permutations/">全排列</a><br><a href="https://leetcode-cn.com/problems/n-queens/">N 皇后</a><br><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a><br><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></p><p><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a><br><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></p><p><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a><br><a href="https://leetcode-cn.com/problems/path-with-maximum-probability/">1514. 概率最大的路径</a><br><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></p><p><a href="https://www.acwing.com/problem/content/851/">Dijkstra</a><br><a href="https://www.acwing.com/problem/content/852/">Dijkstra2</a><br><a href="https://www.acwing.com/problem/content/description/853/">SPFA</a></p><p><a href="https://www.acwing.com/problem/content/855/">有边数限制的最短路</a><br><a href="https://leetcode-cn.com/problems/bus-routes/">815. 公交路线</a></p><p>二分图：<br><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a><br><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a></p><h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>邻接矩阵</li><li>邻接表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//matrix</span></span><br><span class="line">_g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)); <span class="comment">// no weight</span></span><br><span class="line">_g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;(n)) <span class="comment">// neigbor idx and weight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// table</span></span><br><span class="line">_g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;;<span class="comment">// no weight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组表示邻接表</span></span><br><span class="line"><span class="keyword">int</span> head[N], val[M], next[M], idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">val[idx] = b, next[idx] = head[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记visited</span></span><br><span class="line"></span><br><span class="line">dfs (node) &#123;</span><br><span class="line">visited[node] = <span class="literal">true</span>; <span class="comment">// 标记访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (neighbor of node) &#123;</span><br><span class="line"><span class="keyword">do</span> something;</span><br><span class="line"><span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">dfs(neighbor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先搜索，一直走到头，边回去边看</p><ul><li>数据结构：stack</li><li>空间：<code>O(h)</code></li><li>优点：使用空间少</li><li>顺序</li></ul><p><strong>全排列</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (idx == n) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;  </span><br><span class="line">            path[idx] = i + <span class="number">1</span>;  </span><br><span class="line">            visited[i] = <span class="literal">true</span>;  </span><br><span class="line">            dfs(idx + <span class="number">1</span>);  </span><br><span class="line">            visited[i] = <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>n 皇后问题</strong></p><p>用dg，udg记录对角线</p><p>尝试在每一行放，然后递增，回溯即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx == n) &#123;</span><br><span class="line">res.push_back(cur_state);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!col[i] &amp;&amp; !dg[idx + i] &amp;&amp; !udg[n - idx + i]) &#123;</span><br><span class="line">cur_state[idx][i] = <span class="string">&#x27;Q&#x27;</span>; </span><br><span class="line">col[i] = dg[idx + i] = udg[n - idx + i] = <span class="literal">true</span>;</span><br><span class="line">dfs(idx + <span class="number">1</span>, n);</span><br><span class="line">col[i] = dg[idx + i] = udg[n - idx + i] = <span class="literal">false</span>;</span><br><span class="line">cur_state[idx][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>广度优先搜索</p><ul><li>数据结构：queue</li><li>空间 <code>O(2^h)</code></li><li>优点：最短路的概念</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;- initialize // 初始化<span class="built_in">queue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">queue</span>.empty()) &#123; </span><br><span class="line">t&lt;-front();</span><br><span class="line">拓展 t 能到的所有邻居x</span><br><span class="line"><span class="keyword">if</span> (x 未被遍历)</span><br><span class="line"><span class="built_in">queue</span>&lt;-x;</span><br><span class="line">//<span class="keyword">do</span> sth 例如更新距离etc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//即：</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">st[1] = <span class="literal">true</span>; </span><br><span class="line">q.push(1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.size())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> t = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != -1; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; </span><br><span class="line">            q.push(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓扑序列：</strong></p><p>BFS的一种变体</p><p>思路：</p><pre><code>找其中度为0的点存队列，遍历邻居并删除边，过程中再找度为0的点即可。无环肯定有拓扑序列，有环肯定没有（后面的指向前面的）</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!indegree[i]) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> tt = q.front();</span><br><span class="line">        res.push_back(tt);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nr : g[tt]) &#123;</span><br><span class="line">            indegree[nr]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[nr] == <span class="number">0</span>) q.push(nr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (res.size() == n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    indegree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>);</span><br><span class="line">    g = <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        g[x].push_back(y);</span><br><span class="line">        indegree[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (topsort()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><ul><li>单源<ul><li>边权正数<ul><li>朴素Dijkstra算法 O(n^2) 适用稠密图</li><li>堆优化Dijkstra算法 O(mlogn) 适用稀疏图</li></ul></li><li>有负权边<ul><li>Bellman-Ford O(nm)</li><li>SPFA 一般 O(m)，最坏O(nm)</li></ul></li></ul></li><li>多源<ul><li>Floyd O(n^3)</li></ul></li></ul><p><strong>朴素Dijkstra算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. dist[1] &#x3D; 0, dist[0] &#x3D; +infinity</span><br><span class="line">2. for v : 0-n:</span><br><span class="line">t &lt;- 不在s中的距离最近的点 n*n</span><br><span class="line">t加到s里面去</span><br><span class="line">用t更新其他点的距离 m次</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 选中了一个点，故只需要n-1</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">-1</span>; <span class="comment">//find min dist idx</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">t = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">st[t] = <span class="literal">true</span>; <span class="comment">// add t to the S set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">dist[j] = min(dist[j], dist[t] + g[t][j]);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Dijkstra算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>]  = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (heap.size()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// update </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; p : g[ver]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j  = p.first;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + p.second) &#123;</span><br><span class="line">                dist[j] = distance + p.second;</span><br><span class="line">                heap.push(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == infinity) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bellman Ford 算法</strong><br>O(nm)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For n次</span><br><span class="line">For 所有边a, b, w</span><br><span class="line">dist[b] &#x3D; min(dist[b], dist[a] + w);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(bakcup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[j].a, b= edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b] = min(dist[b], bakcup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SPFA算法</strong></p><ul><li><code>dist[x]</code> 最短距离 -&gt; 判断距离</li><li><code>cnt[x]</code> 边数<ul><li><code>cnt[x] &gt;= n</code>  存在负环 -&gt; 有负环</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;- 1</span><br><span class="line">while (queue不空)</span><br><span class="line">t &#x3D; queue pop</span><br><span class="line">更新 t 的所有出边 &#x2F;&#x2F; 我变小了，后继的点才能更新</span><br><span class="line">queue &lt;- b </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] =<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[min_idx] = <span class="literal">false</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : g[min_idx]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = p.first;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[min_idx] + p.second) &#123;</span><br><span class="line">                dist[j] = dist[min_idx] + p.second;</span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Floyd算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ul><li>prim<ul><li>朴素版 O(n^2)</li><li>堆优化 O(mlogn)</li></ul></li><li>Kruskal 稀疏图<ul><li>O(mlogm)</li></ul></li></ul><p><strong>prim算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">dist[i] &lt;- inf</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">t&lt;- 集合外距离最近的点</span></span><br><span class="line"><span class="comment">用t更新其他点到集合的距离</span></span><br><span class="line"><span class="comment">将t加入集合</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">**/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (min_idx == <span class="number">-1</span> || dist[min_idx] &gt; dist[j])) &#123;</span><br><span class="line">                min_idx = j; <span class="comment">// 找到最近的点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[min_idx] == inf) <span class="keyword">return</span> inf; <span class="comment">// 图不连通  </span></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[min_idx];</span><br><span class="line">        st[min_idx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dist[j] = min(dist[j], g[min_idx][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>kruskal算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 将所有边按从小到大排序</span></span><br><span class="line"><span class="comment">2. 枚举每条边x, y, w</span></span><br><span class="line"><span class="comment">1. 如果x, y不连通</span></span><br><span class="line"><span class="comment">2. 加入集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="keyword">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>     // 存储边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge &amp;W)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = find(a), b = find(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)   <span class="comment">//不连通  </span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b; <span class="comment">// 连通a,b</span></span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ; <span class="comment">// 加的边数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF; <span class="comment">//加的边数&lt;n-1，说明不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>当且仅当图中不含奇数环（分成两个集合）</p><ul><li>判断是否二分图<ul><li>DFS染色法 O(n+m)</li><li>匈牙利算法 O(nm)  实际一般远小于</li></ul></li></ul><p><strong>染色法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _g;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _colors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (_colors[i] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!bfs(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">_colors[idx] = <span class="number">0</span>;</span><br><span class="line">q.push(idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> ii = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nei : _g[ii]) &#123;</span><br><span class="line"><span class="keyword">if</span> (_colors[nei] == <span class="number">-1</span>) &#123;</span><br><span class="line">_colors[nei] = !_colors[ii];</span><br><span class="line">q.push(nei);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (_colors[nei] == _colors[ii]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs_coloring</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">_colors[idx] = col;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> nei : _g[idx]) &#123; <span class="comment">// traverse the neighbors</span></span><br><span class="line"><span class="keyword">if</span> (_colors[nei] == <span class="number">-1</span>) &#123; <span class="comment">// no visited </span></span><br><span class="line"><span class="keyword">if</span> (!dfs_coloring(nei, !col)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_colors[nei] == col) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (_colors[i] == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line"><span class="keyword">if</span> (!dfs_coloring(i, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="keyword">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!dfs(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>匈牙利算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="keyword">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || find(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (find(i)) res ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a><br><a href="https://leetcode-cn.com/problems/four-divisors/">1390. 四因数</a> 因数个数<br><a href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a><br><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a><br><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a><br><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a><br><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code>求n的第k位数字: n &gt;&gt; k &amp; 1返回n的最后一位1：lowbit(n) = n &amp; -ni &amp; (i - 1)把最后一位的1变成0[剑指 Offer II 003. 前 n 个数字二进制中 1 的个数](https://leetcode-cn.com/problems/w3tCBm/)</code></pre><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><p>求质数 时间复杂度$O(\sqrt(n))$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// i是质因数，s, 是次数, n中最多只包含一个大于sqrt(n)的质因子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) &#123; <span class="comment">// sqrt(n)</span></span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">n /= i;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判定质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x/i; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛选质数"><a href="#筛选质数" class="headerlink" title="筛选质数"></a>筛选质数</h4><p><strong>筛选质数(埃氏筛法) O(nloglogn)</strong><br>从小到大筛掉质数的倍数</p><p>缺点是会将一个合数重复筛选，比如2已经筛掉了6，3会再筛选一遍6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt;= n; j += i) &#123;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性筛法</strong><br>改进了埃氏筛法，n只会被最小质因子筛掉</p><p>pj * i 一定不是质数，质数从小for到大一直到i的最小质因子即可。</p><ul><li>如果i的最小质因子比pj大，那么pj* i的最小质因子是pj</li><li>如果i的最小质因子是pj， 那么pj * i 的最小质因子还是pj</li><li>任何一个合数i都会被筛掉：一定有一个最小质因子，最小质因子乘以i, i为2-n</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">primes[cnt++] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n/i; j++) &#123;</span><br><span class="line">st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j] 一定是i的最小质因子 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><h4 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h4><p>枚举到 $\sqrt{n}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_divisors</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n/i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i; <span class="comment">//约数1</span></span><br><span class="line"><span class="keyword">if</span> (i != n / i) <span class="built_in">cout</span> &lt;&lt; n / i; <span class="comment">// 约数2 两个约数不一样才放进去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数和约数之和"><a href="#约数个数和约数之和" class="headerlink" title="约数个数和约数之和"></a>约数个数和约数之和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)</span><br></pre></td></tr></table></figure><ul><li>求约数个数 <a href="https://www.acwing.com/problem/content/872/">https://www.acwing.com/problem/content/872/</a></li><li>约数之和 <a href="https://www.acwing.com/problem/content/873/">https://www.acwing.com/problem/content/873/</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; primes;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes) &#123;</span><br><span class="line">        res = res * (prime.second + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><p>欧几里得算法</p><p>$$<br>(a,b) =  (b, a \ mod \ b)<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>$\phi(N)$ 1-N中和N互质的个数<br>则</p><p>$$<br>\phi(N) = N \times \frac{p_1 - 1}{p_1}\times \frac{p_2 - 1}{p_2} … \frac{p_m - 1}{p_m}<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉定理：$a^{\phi(n)} \ mod \ n =1$  a, n互质</p><p>如果p是质数，则$a^{p-1} = 1(modp)$  费马定理</p><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>求$a^k$ ，把k拆成二进制的形式就可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (LL) res * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h4><pre><code>裴蜀定理：任意正整数a, b 一定存在整数x, y使得ax+by = (a, b)</code></pre><p>那么比如让求，ax + by = (a, b), 让你求出任意一个x, y</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="comment">// b = 0, a * 1 + 0 = a</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">y -= a / b * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：求解线性同余方程<br><code>ax == b (mod m)</code></p><p>其方程有解的充要条件是 b 是 (a, m)的倍数（反证法）,故要求的是<br><code>ax + my = (a,b) * b/(a,b)</code><br>求出来的x别忘了%m</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = exgcd(a, m, x, y);</span><br><span class="line"><span class="keyword">if</span> (b % d) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; x * (b / d) % m;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a><br><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></p><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a><br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p><p><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a><br><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a><br><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>DP:</p><ul><li>状态表示<ul><li>集合<ul><li>所有选法</li><li>条件</li></ul></li><li>属性 ： max, min, nums</li></ul></li><li>状态计算  集合划分</li></ul><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0 1背包"></a>0 1背包</h4><p>N个物品 容量是V的背包<br>每个物品容量vi, 价值wi，目标是总价值最大。</p><ul><li>01背包 每件物品最多一次 $max(f(i - 1, j), f(i - 1, j - v(i)))$</li><li>完全背包 每件物品无限次 $max(f(i - 1, j), f(i, j - v) + w)$</li><li>多重背包 si 个</li></ul><p>状态方程</p><p>$$<br>f(i, j) = max(放vi，不放vi) =  max(f(i - 1, j), f(i - 1, j - v(i)))<br>$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><p>状态方程:</p><p>$$<br>f(i, j) = max(f(i - 1, j - v(i) k) + w(i) k)<br>  = max(f(i - 1, j), f(i - 1, j - v) + w …<br>$$</p><p> 经化简得：</p><p>$$<br>f(i, j) =  max(f(i - 1, j), f(i, j - v) + w)<br>$$</p><p>nums里面是东西，一个容量为sum的背包，把东西放背包里，多少种放法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不拿i</span></span><br><span class="line"><span class="keyword">if</span> (j &gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换成一维的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = v[i]; j &lt;= m; j++) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><p>每个有个数 <code>s[i]</code>限制</p><p>完全背包问题： <code>f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k)</code><br><code>k = 0, 1, 2, ....s[i]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k *v[i] &lt;= j; k++) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：<br><code>f[i,j] = max(f[i-1,j], f[i-1, j-v]+w,f[i-1, j-2v]+2w,...f[i-1,j-sv]+sw)</code><br><code>f[i,j-v] = max(f[i-1,j-v], f[i-1,j-2v]+w, ..., f[i-1,j-(s+1)v]    +sw)</code></p><p>化归成01背包问题，将1 2 4 … logsi 打包成一个物品，选择或者不选择就可以优化成nmlogsi复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, s; <span class="comment">//体积，价值，数量</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt;= s) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">v[cnt] = a * k;</span><br><span class="line">w[cnt] = b * k;</span><br><span class="line">s -= k;</span><br><span class="line">k *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">v[cnt] = a * s;</span><br><span class="line">w[cnt] = b * s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = cnt;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= v[i]; j--) &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s[i]; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i][k] &lt;= j) &#123;</span><br><span class="line">f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leetcode 题目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(sum + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(sum + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 第i个物品</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[j] = dp[j] + dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[j] = dp[j]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h3><ul><li>最长上升子序列问题（二维DP， 一维模拟stk优化）</li><li>最长公共子序列问题<ul><li>子集划分<ul><li>所有在a中前i个出现的，b中前j个字母出现的子序列集合</li><li>包括不包括ai, bj 四种情况</li></ul></li><li>属性：Max个数</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><ul><li>石子合并<ul><li>集合：将i到j堆石子合并成一堆石子的合并方式</li><li>属性：Min<br><code>dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r] + s[r] - s[l - 1]);</code></li></ul></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p><code>vector</code> 变长数组，倍增<br>    size()<br>    empty() 返回是否为空<br>    clear() queue就没有清空函数<br>    front(), back() 返回首尾的数<br>    pop_back(), push_back()<br>    begin()/end()<br>    []取地址<br>      支持比较运算： 按字典序比大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt; b;</span><br></pre></td></tr></table></figure><p><code>pair&lt;int, string&gt; p</code><br>    p.first 第一元素<br>    p.second 第二元素<br>    支持比较运算，第一个值为第一元素<br>    构造：<br>    <code>p = make_pair(10, &quot;asdf&quot;)</code><br>    <code>p = &#123;20, &quot;asdf&quot;&#125;</code> // C++11</p><p><code>string</code><br>    size()<br>    empty()<br>      substr(start_index, length), substr(start_index)<br>    c_str() 转为字符数组的起始位置 printf(“%s”, string_a.c_str())</p><p><code>queue</code><br>    push(), 队尾插入<br>    pop(),  对头弹出<br>    front()/back() 返回队头队尾元素</p><p><code>priority_queue</code>（堆）默认大跟堆<br>       top(), 返回堆头元素<br>    push(),  插入一个元素<br>    pop() 弹出堆头元素<br>     小跟堆 <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code></p><p><code>stack</code><br>    push(),<br>    pop(),<br>    top();</p><p><code>deque</code> 加强版的vector，缺点是速度比较慢，比一般数组慢好几倍<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back(),  push_front()<br>    pop_back(), pop_front()<br>    begin()()/end()<br>    <code>[]</code></p><p><code>list</code> 链表<br>     size()<br>     empty()<br>     clear()<br>     push_front(), push_back()<br>     pop_back(), pop_front()<br>     insert(it, val)</p><p><code>set , map, multiset, multimap</code> 平衡二叉树<br>    size()<br>    empty()<br>    clear()<br>    begin()/end() ++ – O(logn)<br>    set/multiset  multiset 可以重复<br>            insert() 插入一个数<br>            find() 寻找一个数<br>            count()  返回某一个数的个数<br>            erase()<br>                    (5)输入是一个数字，删除所有x ：O(logn + k)<br>                    (iterator) 删除对应的元素<br>            lower_bound()/upper_bound()<br>                    lower_bound(x) 返回&gt;=x的最小的iterator<br>                    upper_bound(x) 返回&gt; x 的最小的数iterator<br>    map/multimap<br>            insert(pair&lt;A, B&gt;)<br>            erase() 输入pair或者迭代器<br>            find()<br>            <code>[]</code> 可以像用数组一样去用map，时间复杂度O(logn)<br>            lower_bound(x) 返回&gt;=x的最小的iterator<br>            upper_bound(x) 返回&gt; x 的最小的数iterator</p><p><code>unordered_set, unordered_map, unordered_multiset, unordered_multimap</code> 哈希表<br>    和上面类似，但是绝大部分操作的复杂度是O(1), 不支持lower_bound, upper_bound(), ++–迭代器</p><p><code>bitset</code> 压位 相比于bool数组省空间<br>    bitset&lt;1000&gt; s;<br>    ~ &amp; | ^<br>    &lt;&lt; &gt;&gt;<br>    == !=<br>    <code>[]</code><br>    count() 返回多少个1<br>    any() 判断是否至少有一个1<br>    none() 判断是否全为0<br>    set() 全设为1<br>    set(k, val), 第k位设为1<br>    reset() 全设为0<br>    flip() 全~<br>    flip(k)</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>去除前后空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.erase(s.begin(), find_if(s.begin(), s.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ch) &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isspace</span>(ch);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">s.erase(find_if(s.rbegin(), s.rend(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; ch) &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="built_in">std</span>::<span class="built_in">isspace</span>(ch);</span><br><span class="line">&#125;).base(), s.end());</span><br></pre></td></tr></table></figure><p>INT溢出问题<br>当给一个x == INT_MIN时，我们-x就会溢出，此时给一个longlong去承载就可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> nn = n;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模板练习&quot;&gt;&lt;a href=&quot;#模板练习&quot; class=&quot;headerlink&quot; title=&quot;模板练习&quot;&gt;&lt;/a&gt;模板练习&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快排 &lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;912 排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;堆 &lt;a href=&quot;https://www.acwing.com/problem/content/840/&quot;&gt;838. 堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;归并 &lt;a href=&quot;https://leetcode-cn.com/problems/sort-an-array/&quot;&gt;912 排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分 &lt;a href=&quot;https://www.acwing.com/problem/content/791/&quot;&gt;789. 数的范围&lt;/a&gt; &lt;a href=&quot;https://www.acwing.com/problem/content/792/&quot;&gt;790. 数的三次方根&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;大整数 +-* /&lt;/li&gt;
&lt;li&gt;前缀和&lt;ul&gt;
&lt;li&gt;二维前缀和 &lt;a href=&quot;https://leetcode-cn.com/problems/O4NDxx/&quot;&gt;剑指 Offer II 013. 二维子矩阵的和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;差分 &lt;a href=&quot;https://www.acwing.com/problem/content/799/&quot;&gt;797. 差分&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;二维差分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;位运算 &lt;a href=&quot;https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/&quot;&gt;剑指 Offer 15. 二进制中1的个数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;离散化 &lt;a href=&quot;https://www.acwing.com/blog/content/1778/&quot;&gt;区间和&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;双指针 &lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot;&gt;3. 无重复字符的最长子串&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;KMP &lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot;&gt;28. 实现 strStr()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区间合并 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot;&gt;56. 合并区间&lt;/a&gt; 两种写法
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.difan.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C/C++" scheme="https://blog.difan.tech/tags/C-C/"/>
    
      <category term="数据结构" scheme="https://blog.difan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://blog.difan.tech/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Gossip 算法</title>
    <link href="https://blog.difan.tech/2021/09/10/Gossip%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.difan.tech/2021/09/10/Gossip%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-09T16:00:00.000Z</published>
    <updated>2021-09-13T12:25:31.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gossip-算法"><a href="#Gossip-算法" class="headerlink" title="Gossip 算法"></a>Gossip 算法</h2><p>在一个有界网络中，每个node传播message给随机的几个节点，经过杂乱无章的通信，最终所有节点都会达成一致。每个节点有可能知道所有的节点，也可能仅仅知道几个邻居节点，最后状态都是一致的，又称为反熵。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可扩展性<ul><li>使用$O(\log N)$ rounds 到达所有nodes，N为node的个数。</li></ul></li><li>容错<ul><li>从源头节点到目的节点路径不止一条，可以在不规则为止连接性的网络中运行。</li></ul></li><li>健壮性<ul><li>故障节点不会阻止其他节点发送消息，每个节点都可以随意加入和退出，不会严重啊影响服务质量</li><li>但是如果消息有关于故障节点或者恶意节点，那么系统就不健壮</li></ul></li><li>收敛速度<ul><li>指数收敛速度</li></ul></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>两个概念</p><ul><li>Cycle 传播一个消息的轮数</li><li>Fanout 每轮种node通信的节点数</li></ul><ol><li>周期性散播消息</li><li>每轮随机选择fanout个节点散播消息</li><li>每轮散播消息都选择尚未发送过的节点进行散播</li><li>收到消息的节点不再往send节点散播</li></ol><blockquote><p>Goosip 和 raft<br>raft是强一致性的，而gossip是最终一致</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>Riak 使用gossip协议分享并通信ring state和bucket properties</li><li>CASSANDRA 分享周围nodes和自己的信息</li><li><a href="https://github.com/hashicorp/serf">serf</a>：go实现的服务发现和治理的框架</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Gossip-算法&quot;&gt;&lt;a href=&quot;#Gossip-算法&quot; class=&quot;headerlink&quot; title=&quot;Gossip 算法&quot;&gt;&lt;/a&gt;Gossip 算法&lt;/h2&gt;&lt;p&gt;在一个有界网络中，每个node传播message给随机的几个节点，经过杂乱无章的通信
      
    
    </summary>
    
    
      <category term="Network" scheme="https://blog.difan.tech/categories/Network/"/>
    
    
      <category term="Network" scheme="https://blog.difan.tech/tags/Network/"/>
    
      <category term="分布式" scheme="https://blog.difan.tech/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>POSIX thread</title>
    <link href="https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.difan.tech/2021/05/10/C%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2022-02-19T12:14:55.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POSIX-thread"><a href="#POSIX-thread" class="headerlink" title="POSIX thread"></a>POSIX thread</h1><blockquote><p>Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。</p></blockquote><p>POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。</p><ul><li>多处理器用多线程：效果最好</li><li>单处理器使用多线程： 也有增益（一个线程等IO，另外的执行）</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>多任务同时进行</li><li>阻止潜在的长时间IO等待</li><li>一些地方很多CPU周期</li><li>必须响应异步</li><li>优先级中断</li></ul><span id="more"></span><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程共享模型"><a href="#线程共享模型" class="headerlink" title="线程共享模型"></a>线程共享模型</h3><p>所有线程都可以访问相同的全局共享内存,但是也有自己的私有数据。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>由多个线程共享资源引起的，如果例程没有使用某种类型的同步结构来防止数据损坏，那么它就不是线程安全的。</p><h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>依赖于具体实现（我的WSLunlimit -Hu）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">tigerroarm@Mudifan:~$ <span class="built_in">ulimit</span> -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 50633</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 50633</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>线程共享如下资源</p><ul><li>进程指令（ Process instructions）</li><li>大部分数据</li><li>文件描述符</li><li>signals 和 signal handlers</li><li>当前目录</li><li>User 和 group id</li></ul><p>每个线程独立有：</p><ul><li>Tread ID </li><li>registers, stack pointer集合</li><li>local variables, return addresses 栈 </li><li>signal mask</li><li>priority</li><li>Return value: <code>errno</code></li></ul><p>pthread 如果OK会return 0</p><p>编译程序需要用：</p><p><code>gcc -pthread thread_program.c</code></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> * thread, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> * attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> * (*start_routine)(<span class="keyword">void</span> *), </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>thread : 返回的thread ID</li><li>attr: 使用默认thread 就NULL</li><li>start_routine: 需要线程运行的函数</li><li>arg: 函数参数</li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>thread 库提供了三种同步机制</p><ul><li>互斥（mutexes）:互斥锁（mutual exclusion lock）</li><li>joins: 等待其他进程完成</li><li>条件变量: pthread_cond_t</li></ul><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex:"></a>mutex:</h3><p>用<code>pthread_mutex_lock</code>和<code>pthread_mutex_unlock</code>加锁解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">functionC</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span>  counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> rc1, rc2;</span><br><span class="line">   <span class="keyword">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create independent threads each of which will execute functionC */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( (rc1=pthread_create( &amp;thread1, <span class="literal">NULL</span>, &amp;functionC, <span class="literal">NULL</span>)) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed: %d\n&quot;</span>, rc1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( (rc2=pthread_create( &amp;thread2, <span class="literal">NULL</span>, &amp;functionC, <span class="literal">NULL</span>)) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Thread creation failed: %d\n&quot;</span>, rc2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Wait till threads are complete before main continues. Unless we  */</span></span><br><span class="line">   <span class="comment">/* wait we run the risk of executing an exit which will terminate   */</span></span><br><span class="line">   <span class="comment">/* the process and all threads before the threads have completed.   */</span></span><br><span class="line"></span><br><span class="line">   pthread_join( thread1, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_join( thread2, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">functionC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pthread_mutex_lock( &amp;mutex1 );</span><br><span class="line">   counter++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Counter value: %d\n&quot;</span>,counter);</span><br><span class="line">   pthread_mutex_unlock( &amp;mutex1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h3><p>等待线程完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTHREADS 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">int</span>  counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> thread_id[NTHREADS];</span><br><span class="line">   <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      pthread_create( &amp;thread_id[i], <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt; NTHREADS; j++)</span><br><span class="line">   &#123;</span><br><span class="line">      pthread_join( thread_id[j], <span class="literal">NULL</span>); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Now that all threads are complete I can print the final result.     */</span></span><br><span class="line">   <span class="comment">/* Without the join I could be printing a value before all the threads */</span></span><br><span class="line">   <span class="comment">/* have been completed.                                                */</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *dummyPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Thread number %ld\n&quot;</span>, pthread_self());</span><br><span class="line">   pthread_mutex_lock( &amp;mutex1 );</span><br><span class="line">   counter++;</span><br><span class="line">   pthread_mutex_unlock( &amp;mutex1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h3><h4 id="为什么需要条件变量"><a href="#为什么需要条件变量" class="headerlink" title="为什么需要条件变量"></a>为什么需要条件变量</h4><p>使用互斥锁的时候，如果有一个下面的情况</p><ul><li>线程1: 如果有变化，就把本地buff save 到cloud上</li><li>线程2：改本地buff，标记变化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    pthread_mutex_lock(lock); </span><br><span class="line">    <span class="keyword">if</span>(is_change) &#123;</span><br><span class="line">        save_to_cloud(buff);</span><br><span class="line">        is_change = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span> = tmp[<span class="number">50</span>];</span><br><span class="line">    read(tmp, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(lock);</span><br><span class="line">    <span class="built_in">strcpy</span>(buff, tmp);</span><br><span class="line">    is_change = <span class="literal">true</span>;</span><br><span class="line">    pthead_mutex_unlock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候is_change 一直是false， 那么thread1一直在执行循环。</p><p>想达到的目的是：<strong>直到某个状态改变，才开始执行</strong></p><p>需要的是<em>lock+condition</em></p><p>就需要有条件变量</p><blockquote><p>互斥锁通过控制线程对数据的访问来实现同步，而条件变量允许线程根据数据的实际值进行同步。如果没有条件变量，程序员将需要线程持续轮询(可能在关键部分) ，以检查条件是否满足。这可能会非常消耗资源，因为线程在此活动中将持续忙碌。条件变量是一种不用轮询就可以实现相同目标的方法。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>主线程：<ul><li>声明和初始化需要同步的<strong>全局数据/变量</strong>(例如“ count”)</li><li>声明和初始化<strong>条件变量对象</strong></li><li>声明并初始化一个的<strong>互斥锁</strong> </li><li>创建线程 a 和 b 来做工作</li></ul></li><li>线程A<ul><li>一直工作到某个条件必须发生的点(例如“ count”必须达到指定的值)</li><li>锁住互斥锁，然后检查值</li><li><strong>pthread_cond_wait()</strong> ，阻塞等待来自B线程信号（自动解锁相关的互斥锁）</li><li>当收到信号时就唤醒进程</li></ul></li><li>线程B<ul><li>锁住互斥锁</li><li>更改线程A正在等待的全局变量的值</li><li>检查全局变量的值，如果满足条件，给A发信号</li><li>解锁互斥锁</li></ul></li></ul><h4 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h4><ul><li><p><code>pthread_cond_wait()</code> 阻塞线程直到条件达到</p></li><li><p><code>pthread_cond_init</code></p><ul><li><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code></li></ul></li><li><p>pthread_cond_signal()：唤醒另一个等待条件变量的信号</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">Linux Tutorial: POSIX Threads (cmu.edu)</a></li><li><a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/multi-thread/multi-thread.html">Multi-Threaded Programming With POSIX Threads (kent.edu)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;POSIX-thread&quot;&gt;&lt;a href=&quot;#POSIX-thread&quot; class=&quot;headerlink&quot; title=&quot;POSIX thread&quot;&gt;&lt;/a&gt;POSIX thread&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Portable operating system interface (POSIX) 是IEEE Computer Society为维持操作系统兼容性定义的一套标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;POSIX 线程库规定了C/C++的线程API，相比于fork这种创造新进程的方式，使用线程开销更小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多处理器用多线程：效果最好&lt;/li&gt;
&lt;li&gt;单处理器使用多线程： 也有增益（一个线程等IO，另外的执行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;&lt;a href=&quot;#适用场景&quot; class=&quot;headerlink&quot; title=&quot;适用场景&quot;&gt;&lt;/a&gt;适用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;多任务同时进行&lt;/li&gt;
&lt;li&gt;阻止潜在的长时间IO等待&lt;/li&gt;
&lt;li&gt;一些地方很多CPU周期&lt;/li&gt;
&lt;li&gt;必须响应异步&lt;/li&gt;
&lt;li&gt;优先级中断&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="https://blog.difan.tech/categories/C-C/"/>
    
    
      <category term="多线程" scheme="https://blog.difan.tech/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Unix" scheme="https://blog.difan.tech/tags/Unix/"/>
    
      <category term="C/C++" scheme="https://blog.difan.tech/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 协议</title>
    <link href="https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.difan.tech/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-09-05T16:51:51.442Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议（HTTP协议）</p><p>特点：</p><ul><li>简单</li><li>易解析</li><li>可读性好</li></ul><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC 2616 Link (HTTP 1.1)</a></p><span id="more"></span><h2 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h2><ul><li>HTTP/1.1 : 1999年 RFC 2616，还有RFC7230。目前少于三分之一的网站使用（包括其和其早期版本）。<ul><li>1.1相比于1.0：使用一个TCP连接可以传多个HTTP request/response（引入keep-alive-mechanism，<strong>HTTP长连接</strong>）， client不需要在发送第一个请求后重新协商 TCP 3-Way-Handshake 连接。</li><li>1.1相比于1.0：带宽优化：使用了<strong>分块传输编码</strong>（Chunked transfer encoding）的流式传输机制，即把内容分块（Chunk）进行流式传输</li></ul></li><li>HTTP/2.0 : 2015年，超过一半的网站使用，以谷歌的SPDY为基础开始指定的新版本HTTP协议，RFC 7540.</li><li>HTTP/3.0 : HTTP over QUIC，18%网站使用，使用UDP作为底层传输协议</li></ul><h2 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h2><p>HTTP Request 是client端向server端做的一个请求。</p><p>包括：</p><ul><li>一个请求行： <code>GET /images/logo.png HTTP/1.1</code></li><li>请求头：<code>Accept-Language: en</code>  <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">Link</a><ul><li><code>Accept-Language: en</code></li><li><code>Accept-Ranges: type</code>：指定bytes可以作为一个单位去定义一个range，如果是<code>none</code>则表示不支持partial request。</li></ul></li><li>空行</li><li>HTTP 消息正文( message body) : 可选</li></ul><p>请求行和其他头字段必须以 <code>&lt;CR&gt;&lt;LF&gt;</code>结尾，空行只包括 <code>&lt;CR&gt;&lt;LF&gt;</code>且无空格</p><h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><ul><li>GET （1.0）</li><li>HEAD（1.0） ：除了没有响应体外（Response body）与 GET 请求相同，可以用于检索</li><li>POST （1.0） ：请求服务器接收包括的entity </li><li>OPTIONS（1.1） ： 返回某个URL支持的HTTP 方法</li><li>PUT （1.1）： 请求服务器将entity的保存在URI下（如果存在则修改，不存在则新建）</li><li>DELETE（1.1） ：删除</li><li>TRACE （1.1） ： 回复收到的请求，client知道server做了什么改动，由于XST攻击建议关闭</li><li>CONNECT （1.1）: 用于proxy较多</li></ul><table><thead><tr><th align="center">HTTP method</th><th align="center">RFC</th><th align="center">Request has Body</th><th align="center">Response has Body</th><th align="center">Safe</th><th align="center">Idempotent</th><th align="center">Cacheable</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">HEAD</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr><tr><td align="center">POST</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">PUT</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">DELETE</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">CONNECT</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">No</td></tr><tr><td align="center">OPTIONS</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">Optional</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">TRACE</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc7231">7231</a></td><td align="center">No</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">PATCH</td><td align="center"><a href="https://en.wikipedia.org/wiki/RFC_(identifier)">RFC</a> <a href="https://tools.ietf.org/html/rfc5789">5789</a></td><td align="center">Yes</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td><td align="center">No</td></tr></tbody></table><p>表格来自[1]</p><h2 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h2><ul><li>状态行 ：<code>HTTP/1.1 200 OK</code></li><li>响应头： <code>Content-Type: text/html</code></li><li>空行</li><li>消息体</li></ul><h3 id="状态码（status-code）"><a href="#状态码（status-code）" class="headerlink" title="状态码（status code）"></a>状态码（status code）</h3><ul><li>信息 1XX</li><li>成功 2XX 200 OK</li><li>重定向Redirection 3XX </li><li>Client Error 4XX</li><li>Server Error 5XX</li></ul><p>几个常见的状态码：</p><ul><li>206 : Partial Content</li><li>200: OK</li><li>404: Not Found </li><li>500: Internal Server error</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 23 May 2005 22:38:34 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>155</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 08 Jan 2003 23:11:55 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.3.7 (Unix) (Red-Hat/Linux)</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;3f80f-1b6-3e1cb03b&quot;</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;An Example Page&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello World, this is a very simple HTML document.&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a></p><p>[2] <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a></p><p>[3] <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">https://www.w3.org/Protocols/rfc2616/rfc2616.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;超文本传输协议（HTTP协议）&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;易解析&lt;/li&gt;
&lt;li&gt;可读性好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;RFC 2616 Link (HTTP 1.1)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Network" scheme="https://blog.difan.tech/categories/Network/"/>
    
    
      <category term="http" scheme="https://blog.difan.tech/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB编程指北</title>
    <link href="https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/"/>
    <id>https://blog.difan.tech/2021/01/16/MATLAB%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/</id>
    <published>2021-01-15T16:00:00.000Z</published>
    <updated>2021-01-23T12:46:24.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><!-- toc --><ol><li>折叠<ul><li>ctrl = 折叠代码</li><li>shift ctrl  =展开代码</li></ul></li><li>缩进整理 ctrl i（==全选+ctrl i==）</li><li>跳转到第几行 ctrl g</li><li>F5运行，F10 debug，shift+F5 退出Debug模式</li><li>doc 取代help，直接跳出文档（由于外网，网络可能不稳定）</li></ol><span id="more"></span><h1 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h1><ul><li>注意，MATLAB所有序号都是==从1开始==</li><li>MATLAB中 ==Class Array== 的思想随处不在<ul><li>例如对于<code>a = 54</code>，使用<code>whos</code>命令可以看到，MATLAB认为这是一个Size 1×1 8 Bytes的double array，==而非一个简单的double变量==。</li><li>再例如，<code>str1 =&quot;string&quot;</code>，是一个Size 1×1的，150 Bytes的Class为String的Array变量。也就是说，<em>你完全可以直接str1(2) = “string2”</em>，这种操作被理解为在<code>str1</code>这个string array变量中增加了一个元素。</li><li>同样的，<code>char = &#39;char&#39;</code>是定义了一个Size 1×4的，Bytes为8的 Class 为 char的Array变量。</li></ul></li><li>使用<code>%%</code> <code>%</code>来区分不同Block的代码是一种好方法</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>double </li><li>single（单精度）</li><li>logical</li><li>int8(1B 8bit)</li><li>int16</li><li>int32</li><li>int64</li><li>uint8</li><li>char(‘’)</li><li>string(“”)</li><li>NaN(Not a Number)</li><li>Inf(无穷)：有正负之分</li><li>cell</li><li>struct</li><li>function_handle</li><li><class_name></li></ul><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><ul><li><code>flipud(M)</code>: 翻转矩阵，从下面往上反转</li><li><code>fliplr</code>：左右翻转</li><li><code>flip([])</code>： 翻转向量，矩阵的话和ud一样</li><li><code>repmat(A, 2, 3)</code>：横向重复两次，纵向3次</li><li><code>repelem(A, 2, 3)</code>：repeat element 原来矩阵每个元素都2×3，重新组成新的</li><li><code>max(A)</code>:每列中最大的元素</li><li><code>diff()</code>: 每次相邻两个元素之间做差</li><li><code>prod()</code> :返回数组乘积</li><li><code>cumsum()</code>：返回前n个元素的和<ul><li><code>cumprod()</code></li><li><code>cummin()</code></li><li><code>cummax()</code></li></ul></li><li><code>linspace(x1,x2,n)</code> ：产生n个x1到x2的数据，间隔(x2-x1)/(n-1)<ul><li><code>logspace(x1,x2,n)</code>： 产生n个$$10^{x1}$$到x2的数据</li></ul></li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li><code>find(logical_vector, k, &#39;first&#39;)</code> ：首k个true值</li><li><code>any(logical_vector)</code></li><li><code>all(logical_vector)</code></li></ul><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ul><li><p>线颜色</p><ul><li>b : blue</li><li>g : green</li><li>r : red</li><li>c : cyan 青蓝色</li><li>m : magenta 品红色</li><li>y : yellow</li><li>k ：black</li><li>w ：white</li></ul></li><li><p>线样式</p><ul><li><code>--</code> 段虚线</li><li><code>:</code> 点虚线</li><li><code>-.</code> 段点虚线</li><li>marker<ul><li><code>*-.</code> *为marker</li><li><code>o</code> </li><li><code>.</code></li><li><code>x</code> </li><li><code>s</code> square 方块</li><li><code>d</code> 菱形</li><li><code>v</code></li><li><code>^</code></li><li><code>&lt;</code></li><li><code>&gt;</code></li><li><code>p</code> 五角形</li><li><code>h</code> 六角形</li></ul></li></ul></li><li><p><code>close all</code> 关闭所有的figure</p></li><li><p><code>clf</code> 清空当前画布 clear current figure </p><ul><li>还有<code>cla</code>，清空坐标区 </li></ul></li><li><p><code>subplot(row, col, n_th)</code> </p></li><li><p><code>grid on</code> 网格</p></li><li><p><code>legend()</code> 图例</p></li><li><p><code>xlabel(&#39;&#39;)</code> <code>ylabel(&#39;&#39;)</code> <code>title(&#39;&#39;)</code></p><ul><li>如果要LaTeX显示，需要在后面的<code>&#39;Interpreter&#39;</code>设置为<code>&#39;latex&#39;</code><ul><li>例如  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title([<span class="string">&#x27;Predictive signal $\hat&#123;d&#125;(n)$ and orignal signal $d(n)$ with p=&#x27;</span>,num2str(p)],<span class="string">&#x27;Interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>plot</code>修饰</p><ul><li><code>color+marker+line_shape</code>, e.g. <code>&#39;ro-.&#39;</code></li><li><code>LineWidth</code> 默认为1</li><li><code>MarkerEdgeColor</code> Marker边缘的颜色</li><li><code>MakerFaceColor</code> Marker里面的颜色 </li></ul></li><li><p><code>axis([x1 x2 y1 y2])</code> 设置坐标轴范围</p></li></ul><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><ul><li><code>strlength(&quot;string&quot;)</code>： 字符串长度</li><li>string 类型可以通过<code>&#123;&#125;</code>的方式提取出char类型结果，例如可以通过<code>string&#123;1&#125;(2)</code>提取出第一个string中的第二个char</li><li><code>input(&#39;Some suggestion string:&#39;,&#39;s&#39;)</code> 输入的是char类型</li><li><code>Upper</code>，全部大写</li><li><code>strcmp(str1, str2, num)</code>，前num位的字符是否相同</li><li><code>strfind(text, pattern)</code> 找text中pattern 的位置</li><li><code>strsplit(text, pattern)</code> split 字符串</li></ul><h2 id="元胞数组"><a href="#元胞数组" class="headerlink" title="元胞数组"></a>元胞数组</h2><ul><li><code>&#123;48, &quot;uui&quot;, 1:4:9&#125;</code></li><li>访问使用{index} {1,2}</li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><code>S = struct(&#39;field1&#39;,VALUES1,&#39;field2&#39;,VALUES2,...)</code></li></ul><h2 id="保存加载"><a href="#保存加载" class="headerlink" title="保存加载"></a>保存加载</h2><ul><li><code>save testfile.dat mydata -ascii</code> save 文件名 变量名</li><li><code>load file_name.dat</code> </li></ul><h2 id="可变长输入输出"><a href="#可变长输入输出" class="headerlink" title="可变长输入输出"></a>可变长输入输出</h2><ul><li>varargin{1}： variable argument input, cell 类型，存储输入参数</li><li>nargin 输入参数个数</li><li>varargout 输出参数    </li><li>nargout 输出个数</li></ul><h2 id="本地函数和嵌套函数"><a href="#本地函数和嵌套函数" class="headerlink" title="本地函数和嵌套函数"></a>本地函数和嵌套函数</h2><ul><li>本地函数，单个m文件中定义的函数，作用域为整个m文件</li><li>嵌套函数（可以使用所有外层函数定义的量）</li></ul><h2 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h2><ul><li>function_handle，为一个单独的数据类型</li><li>使用 func_han = @(argm1, argm2) argm1*argm2; 即可定义手柄</li><li>func2str(func_hndl);得到函数名字</li><li>相关函数<ul><li><code>fplot(@sin(), [0, 2*pi])</code></li><li><code>feval(@sin(), 0:0.1:1)</code> 返回每个值对应的函数输出</li><li><code>timeit(func_handle)</code>，算函数计算的时间<h2 id="通信相关"><a href="#通信相关" class="headerlink" title="通信相关"></a>通信相关</h2></li></ul></li></ul><h3 id="qammod"><a href="#qammod" class="headerlink" title="qammod"></a>qammod</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ModDataTX = qammod(BinData, MOD, <span class="string">&#x27;InputType&#x27;</span>, <span class="string">&#x27;bit&#x27;</span>, <span class="string">&#x27;PlotConstellation&#x27;</span>,<span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 对于输入bit 流进行 QAM调制，MOD是调制阶数，InputType指定输入类型</span></span><br></pre></td></tr></table></figure><p>注意 matlab中 vector’ 如果是vector复数向量，就算的直接是共轭转置，这个被坑过，如果想只转置可以用 vector.’</p><h3 id="berfading"><a href="#berfading" class="headerlink" title="berfading"></a>berfading</h3><p>估计fading时的性能，参数是SNR，调制方式，调制模，复用参数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EbNo = <span class="number">8</span>:<span class="number">2</span>:<span class="number">20</span>; <span class="comment">% Eb/N0</span></span><br><span class="line">ber = <span class="built_in">zeros</span>(<span class="built_in">length</span>(EbNo),<span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> L = <span class="number">1</span>:<span class="number">20</span> </span><br><span class="line">    ber(:,L) = berfading(EbNo,<span class="string">&#x27;qam&#x27;</span>,<span class="number">16</span>,L); <span class="comment">% 16 QAM</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">semilogy(EbNo,ber,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">text(<span class="number">18.5</span>, <span class="number">0.02</span>, sprintf(<span class="string">&#x27;L=%d&#x27;</span>,<span class="number">1</span>))</span><br><span class="line">text(<span class="number">18.5</span>, <span class="number">1e-11</span>, sprintf(<span class="string">&#x27;L=%d&#x27;</span>,<span class="number">20</span>))</span><br><span class="line">title(<span class="string">&#x27;QAM over fading channel with diversity order 1 to 20&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;E_b/N_0 (dB)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">grid on</span><br></pre></td></tr></table></figure><p><img src="https://www.mathworks.com/help/examples/comm/win64/EstimateBERPeformanceOf16QAMInFadingExample_01.png" alt="image"></p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p><code>rng(&#39;shuffle&#39;)</code>来使用当前时间作为随机数种子</p><h3 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h3><p>0-1 随机数</p><h3 id="randi"><a href="#randi" class="headerlink" title="randi"></a>randi</h3><p>伪随机整数</p><p>X = randi([imin,imax],size_1,size_2)</p><p>X = randi(imax,sz1,…,szN)</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">randi([<span class="built_in">min</span> <span class="built_in">max</span>], row_number, col_number);</span><br><span class="line"><span class="comment">% e.g.</span></span><br><span class="line">randi([<span class="number">0</span> <span class="number">10</span>], <span class="number">1000</span>, <span class="number">1</span>); <span class="comment">% Generate 1000✖1 random vector with range from 0 to 10</span></span><br></pre></td></tr></table></figure><h3 id="randn"><a href="#randn" class="headerlink" title="randn"></a>randn</h3><p>randn生成正态分布随机数</p><p>X = randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。</p><p>X = randn(sz1,…,szN) 返回由随机数组成的 sz1×…×szN 数组，其中 sz1,…,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。</p><p>X = randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用技巧&quot;&gt;&lt;a href=&quot;#常用技巧&quot; class=&quot;headerlink&quot; title=&quot;常用技巧&quot;&gt;&lt;/a&gt;常用技巧&lt;/h1&gt;&lt;!-- toc --&gt;

&lt;ol&gt;
&lt;li&gt;折叠&lt;ul&gt;
&lt;li&gt;ctrl = 折叠代码&lt;/li&gt;
&lt;li&gt;shift ctrl  =展开代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缩进整理 ctrl i（==全选+ctrl i==）&lt;/li&gt;
&lt;li&gt;跳转到第几行 ctrl g&lt;/li&gt;
&lt;li&gt;F5运行，F10 debug，shift+F5 退出Debug模式&lt;/li&gt;
&lt;li&gt;doc 取代help，直接跳出文档（由于外网，网络可能不稳定）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MATLAB" scheme="https://blog.difan.tech/categories/MATLAB/"/>
    
    
      <category term="MATLAB" scheme="https://blog.difan.tech/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>Inband Full-duplex Wireless Communication System</title>
    <link href="https://blog.difan.tech/2021/01/02/fullduplex/"/>
    <id>https://blog.difan.tech/2021/01/02/fullduplex/</id>
    <published>2021-01-01T16:00:00.000Z</published>
    <updated>2022-02-19T12:19:58.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-Band<br>Full-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。</p><span id="more"></span><h2 id="主要想法"><a href="#主要想法" class="headerlink" title="主要想法"></a>主要想法</h2><p>要实现全双工，主要就是减少自干扰（self-interference），即同一设备发射的信号对于接收信号的干扰。WiFi信号的平均功率为20dBm（100mW），接收机的噪声基底（noise<br>floor）大致为-90dBm，所以要将自干扰降低到-90dBm，需要降低110dB的线性抵消能力。</p><p>对于非线性自干扰（Harmonics），其为-10dBm（比基底高80dB），即需要80dB的非线性抵消能力。</p><p><img src="/images/media/c45cb054af14da46a727521c6b3ac8de.png" alt=""></p><p><strong>图 1</strong> 抵消目标[1]</p><p>图1中，我们看到，SIC中线性分量是主要分量，发射机噪声为-40dBm，由于OFDM的PAPR特性所以我们需要预留10dB，即模拟域需要提供60dB的消除能力。</p><h2 id="自干扰分析"><a href="#自干扰分析" class="headerlink" title="自干扰分析"></a>自干扰分析</h2><p>在WiFi场景下，自干扰主要有以下三种（如图1所示）</p><ul><li>天线与环行器阻抗不匹配导致的反射分量 RA</li><li>环行器1端口到3端口的泄露分量 I</li><li>环境散射分量RC</li></ul><p><img src="/images/media/4685cb8996f44b2128c3c41a1981c02c.png" alt=""></p><p><strong>图 2</strong> 自干扰分析图</p><h2 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h2><h3 id="4-1-天线隔离"><a href="#4-1-天线隔离" class="headerlink" title="4.1 天线隔离"></a>4.1 天线隔离</h3><ul><li>环行器 Circulator（大部分的方法）</li><li>电平衡 EBD (×)</li></ul><h3 id="4-2-RF域（模拟域）干扰抵消"><a href="#4-2-RF域（模拟域）干扰抵消" class="headerlink" title="4.2 RF域（模拟域）干扰抵消"></a>4.2 RF域（模拟域）干扰抵消</h3><h4 id="4-2-1-IMT-方法（RF-front）-2"><a href="#4-2-1-IMT-方法（RF-front）-2" class="headerlink" title="4.2.1 IMT 方法（RF front）[2]"></a>4.2.1 IMT 方法（RF front）[2]</h4><p>I和RA因为没有路径损耗，具有主要的能量，是我们在模拟域/RF域主要需要抵消的信号。RC由于其环境反射特性可以在数字域建模消除。</p><p>使用IMT网络控制RA的振幅和相位，直接抵消I。</p><p>根据计算得到反射系数结果：</p><p><img src="/images/media/99ae3ce95c644451471721ac19aabd59.png" alt=""></p><p>S为端之间的回波损耗。</p><p><img src="/images/media/d4d66762a16d084a48221bf39bbb108d.emf" alt=""></p><p>上图具有并联和串联变容二极管的可重配置IMT电路的示意图，可以通过调整Vs，Vp来调整Zin。</p><p>ZL是天线输入阻抗，根据反射系数定义，可以得到：</p><p><img src="/images/media/74e6cba8d12936066cf3668c3f988b41.png" alt=""></p><p>Z0是环行器器2端口的特性阻抗。</p><p><strong>实验部分：</strong></p><p>用了RFCI CR5853环行器，15.5dB固有隔离度。Skyworks Inc的可变容二极管SMV 2019</p><p>结果：</p><p><img src="/images/media/a8d08156add47aa647e04dbec788b785.png" alt=""></p><p><strong>图3</strong> IMT结果</p><h4 id="4-2-2-信号重建方法-SR-SIC（第一阶段）"><a href="#4-2-2-信号重建方法-SR-SIC（第一阶段）" class="headerlink" title="4.2.2 信号重建方法 SR-SIC（第一阶段）"></a>4.2.2 信号重建方法 SR-SIC（第一阶段）</h4><p>以[1]为代表的抽头延迟线横向滤波器，通过对射频信号采样，用sinc函数插值重建原始信号。<strong>是我们第一阶段采用的方法。</strong></p><p><img src="/images/media/6d826fb6bee579455ea260605c32698f.png" alt=""></p><p><strong>图 4</strong> 时域信号重建方法</p><p>图4<br>为时域的方法，基于时域的抵消架构对发射信号进行采样，并将其分成不同的分支，称为抽头。这些抽头中的每一个都有不同的时间延迟，并且可以在组合成单个输出之前独立调整信号的幅度和相位。正是这种延迟和抽头的复杂加权使得抵消器能够匹配自干扰信号，并产生与接收机内的自干扰相消的信号。</p><p>由于使用原始信号进行信号重建，故其发射机噪声可以被消除（也只能在模拟域进行消除）。其线性消除能力为62dB，非线性能力为30dB</p><p>当然也有频域相关的方法，可以参考哥伦比亚大学Jin<br>Zhou团队，优点是可以芯片小型化，缺点是目前为止其指标并不高。</p><h4 id="4-2-3-信道响应方法-CR-SIC"><a href="#4-2-3-信道响应方法-CR-SIC" class="headerlink" title="4.2.3 信道响应方法 CR-SIC"></a>4.2.3 信道响应方法 CR-SIC</h4><p>[8]中的方法</p><h4 id="4-2-4-数字域辅助模拟域方法"><a href="#4-2-4-数字域辅助模拟域方法" class="headerlink" title="4.2.4 数字域辅助模拟域方法"></a>4.2.4 数字域辅助模拟域方法</h4><p>[5]的方法，可以作为参考</p><h3 id="4-3-数字域干扰抵消"><a href="#4-3-数字域干扰抵消" class="headerlink" title="4.3 数字域干扰抵消"></a>4.3 数字域干扰抵消</h3><p>参考[3]和专著[12]</p><h4 id="4-3-1-功放模型"><a href="#4-3-1-功放模型" class="headerlink" title="4.3.1 功放模型"></a>4.3.1 功放模型</h4><p>在理想情况下，对于均值为0的射频信号，我们期望功率放大器的输出信号总是其输入信号的线性放大</p><p>其中表示某一常数。然而在实际情况中功率放大器的增益是一个随着输入信号大小而变化的函数</p><p><img src="/images/media/ca41f139d0ebf6a5d3d7f7e9cb645d96.jpg" alt=""></p><p><strong>图 4</strong> 幅度-幅度（AM-AM）特性 幅度-相位（AM-PM）特性</p><p>AM-AM特性和AM-PM特性指的是输入幅度变化造成的输出幅度和输出相移的非线性改变。早期通信系统带宽比较窄，远小于功放的工作带宽，所以使用无记忆模型，在频域上的体现就是功率放大器的行为特性不依赖于信号频率。当通信的带宽越来越大，其记忆效应更加明显，简单的无记忆模型不再适用。其记忆效应在频域体现在频率依赖行为，在时域体现在不仅与当前信号有关，还与过去一段时间信号有关。</p><p>记忆效应分为长记忆效应（线性记忆效应）和短记忆效应（非线性记忆效应），前者与匹配网络有关，后者主要由于功放的低频散射，具体模型如表1所示。</p><p>功放非线性指标</p><ul><li>1dB压缩点:相对线性增益降低1dB的输出功率点</li><li>三阶截断点:IP3</li></ul><p><strong>表1</strong> 常用功放模型分类</p><table><thead><tr><th>无记忆模型</th><th></th><th></th></tr></thead><tbody><tr><td>多项式模型</td><td>结构简单，参数辨识度高</td><td></td></tr><tr><td>记忆模型</td><td></td><td></td></tr><tr><td>两盒模型</td><td>Wiener</td><td>线性滤波+静态非线性模块（无记忆）</td></tr><tr><td></td><td>Hammerstein</td><td>静态非线性模块（无记忆）+线性滤波</td></tr><tr><td>Volterra级数及其改进形式</td><td>记忆多项式模型(Memory Polynomial)的性能具有稳健性，多种情况下优于Wiener, Hammerstein等模型的线性化性能，结构简单，复杂度低。</td><td></td></tr></tbody></table><h5 id="PA的Volterra级数模型"><a href="#PA的Volterra级数模型" class="headerlink" title="PA的Volterra级数模型"></a>PA的Volterra级数模型</h5><p>一般形式的Volterra模型为：</p><p>(4.3.1-1)</p><p>称为Volterra的kernels，一般只考虑奇数项，那么Volterra在功放中的表示形式如下</p><p>(4.3.1-2)</p><p>为对角项，其它求和项为交叉项。如果我们忽略交叉项，只保留对角项，则简化为如下多项式模型：</p><p>(4.3.1-3)</p><h4 id="4-3-2-线性消除"><a href="#4-3-2-线性消除" class="headerlink" title="4.3.2 线性消除"></a>4.3.2 线性消除</h4><h5 id="闭环方法"><a href="#闭环方法" class="headerlink" title="闭环方法"></a>闭环方法</h5><p>同模拟域类似，可以使用具有数字可控时间延迟单元和复杂抽头加权的抽头延迟线结构，如下图所示，可以通过LMS等等方法调整权重，好处是在数字域处理更加灵活，抽头数可以更多，自适应性强，可以实时调整权重。</p><p><img src="/images/media/4eb4d1f8c0c6d2ad4a4f7cfaea47ecbd.png" alt=""></p><p>图 4 数字域闭环方法</p><h5 id="开环方法"><a href="#开环方法" class="headerlink" title="开环方法"></a>开环方法</h5><p>主要是[1]中的方法，使用WiFi Preamble进行LS信道估计后恢复信号。</p><p>我们同样使用PH模型进行PA建模：</p><p>其中2K-1是该模型的阶数，L是该模型的抽头数。其矩阵形式可表示为：</p><p>其中</p><p>其中的Y是带有噪声的向量，通过LS算法求出B后再进行模型重建。</p><h4 id="4-3-2-非线性消除"><a href="#4-3-2-非线性消除" class="headerlink" title="4.3.2 非线性消除"></a>4.3.2 非线性消除</h4><h5 id="Parallelizable-Hammerstein-模型"><a href="#Parallelizable-Hammerstein-模型" class="headerlink" title="Parallelizable-Hammerstein 模型"></a>Parallelizable-Hammerstein 模型</h5><p>功放的模型可以参考[4]。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Bharadia, D., McMilin, E., &amp; Katti, S. (2013). Full duplex radios. ACM<br>SIGCOMM. <a href="https://doi.org/10.1145/2534169.2486033">https://doi.org/10.1145/2534169.2486033</a></p><p>[2] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). Inherent<br>Self-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.<br>IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.<br><a href="https://doi.org/10.1109/TMTT.2018.2818124">https://doi.org/10.1109/TMTT.2018.2818124</a></p><p>[3] Kolodziej, K. E., Perry, B. T., &amp; Herd, J. S. (2019). In-Band Full-Duplex<br>Technology: Techniques and Systems Survey. IEEE Transactions on Microwave Theory<br>and Techniques, 67(7), 3025–3041. <a href="https://doi.org/10.1109/TMTT.2019.2896561">https://doi.org/10.1109/TMTT.2019.2896561</a></p><p>[4] Isaksson, M., Wisell, D., &amp; Rönnow, D. (2006). A comparative analysis of<br>behavioral models for RF power amplifiers. IEEE Transactions on Microwave Theory<br>and Techniques, 54(1), 348–359. <a href="https://doi.org/10.1109/TMTT.2005.860500">https://doi.org/10.1109/TMTT.2005.860500</a></p><p>[5] Liu, Y., Quan, X., Pan, W., &amp; Tang, Y. (2017). Digitally Assisted Analog<br>Interference Cancellation for In-Band Full-Duplex Radios. IEEE Communications<br>Letters, 21(5), 1079–1082. <a href="https://doi.org/10.1109/LCOMM.2017.2652444">https://doi.org/10.1109/LCOMM.2017.2652444</a></p><p>[6] Kolodziej, K. E., McMichael, J. G., &amp; Perry, B. T. (2016). Multitap RF<br>Canceller for In-Band Full-Duplex Wireless Communications. IEEE Transactions on<br>Wireless Communications, 15(6), 4321–4334.<br><a href="https://doi.org/10.1109/TWC.2016.2539169">https://doi.org/10.1109/TWC.2016.2539169</a></p><p>[7] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,<br>Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.<br>IEEE Communications Magazine, 54(9), 80–87.<br><a href="https://doi.org/10.1109/MCOM.2016.7565192">https://doi.org/10.1109/MCOM.2016.7565192</a></p><p>[8] Choi, Y. S., &amp; Shirani-Mehr, H. (2013). Simultaneous transmission and<br>reception: Algorithm, design and system level performance. IEEE Transactions on<br>Wireless Communications, 12(12), 5992–6010.<br><a href="https://doi.org/10.1109/TWC.2013.101713.121152">https://doi.org/10.1109/TWC.2013.101713.121152</a></p><p>[9] Korpi, D., Tamminen, J., Turunen, M., Huusari, T., Choi, Y. S., Anttila, L.,<br>Talwar, S., &amp; Valkama, M. (2016). Full-duplex mobile device: Pushing the limits.<br>IEEE Communications Magazine, 54(9), 80–87.<br><a href="https://doi.org/10.1109/MCOM.2016.7565192">https://doi.org/10.1109/MCOM.2016.7565192</a></p><p>[10] Khaledian, S., Farzami, F., Smida, B., &amp; Erricolo, D. (2018). Inherent<br>Self-Interference Cancellation for In-Band Full-Duplex Single-Antenna Systems.<br>IEEE Transactions on Microwave Theory and Techniques, 66(6), 2842–2850.<br><a href="https://doi.org/10.1109/TMTT.2018.2818124">https://doi.org/10.1109/TMTT.2018.2818124</a></p><p>[11] Wu, X., Shen, Y., &amp; Tang, Y. (2014). The Power Delay Pro fi le of the<br>Single-Antenna. 13, 1561–1564.</p><p>[12] Full-Duplex Wireless Communications Systems.(2017).</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;全双工系统可以使得频谱利用率为原来的两倍。传统的通信系统一般都是半双工系统，例如在时域区分上下行的TDD和在频域区分上下行信号的FDD，带内全双工（In-Band&lt;br&gt;Full-Duplex）讲的就是在同频率上同时进行收发，这样的话在如今如此紧张的频谱情形下能使频谱利用率加倍，那将十分有用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="EE" scheme="https://blog.difan.tech/categories/EE/"/>
    
    
      <category term="EE" scheme="https://blog.difan.tech/tags/EE/"/>
    
  </entry>
  
  <entry>
    <title>运动营养、减脂</title>
    <link href="https://blog.difan.tech/2021/01/02/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"/>
    <id>https://blog.difan.tech/2021/01/02/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/</id>
    <published>2021-01-01T16:00:00.000Z</published>
    <updated>2022-02-19T14:32:50.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="减脂"><a href="#减脂" class="headerlink" title="减脂"></a>减脂</h1><h2 id="有氧和少吃不是最好方法："><a href="#有氧和少吃不是最好方法：" class="headerlink" title="有氧和少吃不是最好方法："></a>有氧和少吃不是最好方法：</h2><p>原因：</p><p>热量缺口（有氧+少吃）-&gt;</p><ul><li>代谢下降</li><li>蛋白质降低，掉肌肉</li><li>脂肪吸收效率提高: 复胖速度快</li></ul><h2 id="正确的减脂思路"><a href="#正确的减脂思路" class="headerlink" title="正确的减脂思路"></a>正确的减脂思路</h2><ul><li>确定摄入的热量</li><li>亏空用锻炼放上</li><li>做力量训练，提高基础代谢</li><li>控制饮食</li><li>训练之后吃碳水，均匀摄入脂肪，蛋白质</li><li>避免糖脂混合物，鲜榨果汁，避免果糖</li><li>可以少食多餐</li><li>咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶</li><li>2g速溶咖啡大概50mg咖啡因</li><li>人体咖啡因一天小于400mg，不会有影响<br>不要一上来就是低碳水高蛋白，会给肾脏压力大</li></ul><span id="more"></span><h2 id="热量计算"><a href="#热量计算" class="headerlink" title="热量计算"></a>热量计算</h2><p>1kg脂肪 7700大卡，一周不超过1kg最安全</p><p>目标是最大减脂效率（1kg/week），每天1000大卡的热量亏空</p><p>我的代谢：2700大卡，每天1700热量摄入，并且蛋白质增加</p><ul><li>早餐 200大卡</li><li>午餐 800-1000大卡</li><li>晚餐 500大卡</li></ul><h3 id="常见食品热量"><a href="#常见食品热量" class="headerlink" title="常见食品热量"></a>常见食品热量</h3><ul><li>三勺燕麦：100大卡</li><li>一个汉堡  400大卡</li><li>薯条：350大卡</li><li>鸡排：200大卡</li><li>牛排：250大卡</li><li>二两米饭：100大卡</li><li>一片面包：150大卡</li><li>一条鱼：100大卡 80% 蛋白质</li><li>牛/羊肉 120大卡/100g 85%蛋白质</li><li>猪肉 330大卡/100g 脂肪高</li><li>二两米饭：</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;减脂&quot;&gt;&lt;a href=&quot;#减脂&quot; class=&quot;headerlink&quot; title=&quot;减脂&quot;&gt;&lt;/a&gt;减脂&lt;/h1&gt;&lt;h2 id=&quot;有氧和少吃不是最好方法：&quot;&gt;&lt;a href=&quot;#有氧和少吃不是最好方法：&quot; class=&quot;headerlink&quot; title=&quot;有氧和少吃不是最好方法：&quot;&gt;&lt;/a&gt;有氧和少吃不是最好方法：&lt;/h2&gt;&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;热量缺口（有氧+少吃）-&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代谢下降&lt;/li&gt;
&lt;li&gt;蛋白质降低，掉肌肉&lt;/li&gt;
&lt;li&gt;脂肪吸收效率提高: 复胖速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正确的减脂思路&quot;&gt;&lt;a href=&quot;#正确的减脂思路&quot; class=&quot;headerlink&quot; title=&quot;正确的减脂思路&quot;&gt;&lt;/a&gt;正确的减脂思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确定摄入的热量&lt;/li&gt;
&lt;li&gt;亏空用锻炼放上&lt;/li&gt;
&lt;li&gt;做力量训练，提高基础代谢&lt;/li&gt;
&lt;li&gt;控制饮食&lt;/li&gt;
&lt;li&gt;训练之后吃碳水，均匀摄入脂肪，蛋白质&lt;/li&gt;
&lt;li&gt;避免糖脂混合物，鲜榨果汁，避免果糖&lt;/li&gt;
&lt;li&gt;可以少食多餐&lt;/li&gt;
&lt;li&gt;咖啡因➕绿茶 协同效果好早晨或者训练前补充咖啡，早上喝绿茶&lt;/li&gt;
&lt;li&gt;2g速溶咖啡大概50mg咖啡因&lt;/li&gt;
&lt;li&gt;人体咖啡因一天小于400mg，不会有影响&lt;br&gt;不要一上来就是低碳水高蛋白，会给肾脏压力大&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://blog.difan.tech/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="减脂" scheme="https://blog.difan.tech/tags/%E5%87%8F%E8%84%82/"/>
    
      <category term="运动营养" scheme="https://blog.difan.tech/tags/%E8%BF%90%E5%8A%A8%E8%90%A5%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>数字信号处理 -- 基于计算机方法</title>
    <link href="https://blog.difan.tech/2020/12/27/DSP/"/>
    <id>https://blog.difan.tech/2020/12/27/DSP/</id>
    <published>2020-12-26T16:00:00.000Z</published>
    <updated>2020-12-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目录：</strong></p><!-- toc --><blockquote><p>本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记</p></blockquote><span id="more"></span><h1 id="信号与信号处理"><a href="#信号与信号处理" class="headerlink" title="信号与信号处理"></a>信号与信号处理</h1><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h3><ul><li>振幅</li><li>时间<ul><li>连续时间信号<ul><li>振幅也连续：模拟信号</li></ul></li><li>离散时间信号<ul><li>振幅离散：数字信号</li></ul></li></ul></li></ul><h3 id="复数信号和解析信号"><a href="#复数信号和解析信号" class="headerlink" title="复数信号和解析信号"></a>复数信号和解析信号</h3><h4 id="复数信号"><a href="#复数信号" class="headerlink" title="复数信号"></a>复数信号</h4><ul><li><p>Why?</p><ul><li>信号表示更加复杂（相位，幅度） -&gt; 信息量很大 -&gt; 信号处理更加简单，易于处理</li></ul></li><li><p>希尔伯特变换 HT</p><ul><li>$h_{HT} = \frac{1}{\pi t}$</li><li>$H_{HT}(j\Omega) = \begin{cases} -j &amp; \Omega &gt; 0 \\  j &amp;  \Omega &lt; 0  \end{cases} $</li></ul></li></ul><!--这里要用\\\来表示换行--><h4 id="实数信号"><a href="#实数信号" class="headerlink" title="实数信号"></a>实数信号</h4><ul><li>实数信号<ul><li>FT性质 =&gt; 幅度偶对称，相位奇对称</li><li>正频率 + 负频率 $X(j\Omega) = X_p(j\Omega)+X_n(j\Omega)$</li><li>经过HT =&gt; $\hat{X}(j\Omega) = -j X_p(j\Omega)+jX_n(j\Omega)$  =&gt; $\hat{x}(t)$也是实数信号</li></ul></li></ul><h4 id="解析信号"><a href="#解析信号" class="headerlink" title="解析信号"></a>解析信号</h4><p>=&gt; 解析信号  $y(t) = x(t) + j\hat{x}(t)$</p><p>$x(t), \hat{x}(t)$ 为<strong>同相分量</strong>和<strong>正交分量</strong></p><p>$Y(j\Omega) = X(j\Omega)+j\hat{X}(j\Omega) = 2 X_p(j\Omega)$</p><p>我们可以看出<em>解析信号只包含正频率的部分</em></p><h2 id="信号运算"><a href="#信号运算" class="headerlink" title="信号运算"></a>信号运算</h2><ul><li><p>简单运算</p><ul><li>衰减</li><li>延迟 $y(t) = x(t-t_0)$</li><li>相加，相乘</li><li>积分 $y(t) = \int_{-\infty}^{t}x(\tau) d\tau$</li><li>微分 $y(t) = \frac{dx(t)}{dt}$</li><li>傅里叶变换Fourier Transform(FT)  $X(j\Omega) = \int_{-\infty}^{+\infty}x(t) e^{-j\Omega t} dt$</li></ul></li><li><p>滤波</p><ul><li>$y(t) = \int_{-\infty}^{+\infty} h(t-\tau)x(\tau)d\tau$</li><li>低通，高通，带通</li><li>带阻（陷波器3）</li><li>多频带滤波器：多个通带阻带</li><li>梳状滤波器：阻断某个低频的整数倍</li></ul></li></ul><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><ul><li>Why?<ul><li>低频信号无法直接用于传输</li><li>调制到高频进行传输- 原理：利用信号的振幅、相位、频率表示信号</li></ul></li></ul><h1 id="时域离散时间信号"><a href="#时域离散时间信号" class="headerlink" title="时域离散时间信号"></a>时域离散时间信号</h1><p>离散时间信号， Why？</p><blockquote><p>现代计算机、微处理器、嵌入式设备都是处理数字信号的，但是我们的物理世界充斥着连续信号（模拟信号），如声音信号等。而直接处理模拟信号是比较困难的（1G通信），设备器件做的很大（大哥大），而且不便于加密（你树根天线就能窃听到隔壁老王在电话里说什么）。这就涉及到<em>模拟信号数字化</em>（<strong>采样，或者抽样</strong>），转换为数字信号进行处理。</p></blockquote><h2 id="时域表示"><a href="#时域表示" class="headerlink" title="时域表示"></a>时域表示</h2><p>采样： $x[n] = x_a{(t)}|_{t = nT} = x_a(nT)$</p><p>采样频率（抽样频率）： $F_t = \frac{1}{T}$</p><p>采样得到的值由于ADC（数模转换器）的精度问题（例如12 Bit ADC）有<strong>舍入的问题</strong>。</p><h2 id="频域表示"><a href="#频域表示" class="headerlink" title="频域表示"></a>频域表示</h2><p>归一化角频率：$\omega_c$ 为归一化角频率，因为样本$n$是无量纲的，所以应该是弧度/样本，且</p><p>$$<br>\omega = 2\pi f<br>$$</p><p>$f$ 是归一化角频率， 单位是周期/样本，即一个样本多少周期</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>例子2.1：集合平均</strong></p><p>$s[n]=2[n(0.9)^n]$ 和噪声$d(n)$，受干扰后的集合平均可以减少干扰影响</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Program_2_1</span></span><br><span class="line"><span class="comment">% Generation of the ensemble average</span></span><br><span class="line">N = <span class="number">50</span>; <span class="comment">% total number</span></span><br><span class="line">n = <span class="number">0</span> : N<span class="number">-1</span>;</span><br><span class="line">s = <span class="number">2</span>*(n.*<span class="number">0.9</span>.^n); <span class="comment">% generate the original signal s[n]</span></span><br><span class="line">rng();</span><br><span class="line">d = <span class="built_in">rand</span>(N, <span class="number">1</span>) - <span class="number">0.5</span>; <span class="comment">% generate the noise signal d[n]</span></span><br><span class="line"></span><br><span class="line">x1 = s+d&#x27;; <span class="comment">% the corrupted signal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the corrupted signal</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">stem(n, x1);</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Corrupted Signal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the Noise Signal</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">stem(n, d)</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Noise Signal&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Ensemble average</span></span><br><span class="line"><span class="keyword">for</span> m = <span class="number">1</span>:<span class="number">50</span></span><br><span class="line">    rng();</span><br><span class="line">    noise = <span class="built_in">rand</span>(N,<span class="number">1</span>) - <span class="number">0.5</span>;</span><br><span class="line">    x = s + noise&#x27;;</span><br><span class="line">    x1 = x1 + x;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x1 = x1 / N;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot the ensemble average signal</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(n, x1);</span><br><span class="line">xlabel(<span class="string">&#x27;Time Index n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;The Ensemble Average Signal&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/DSP/2-1-01.png" alt=""></p><p><img src="/images/DSP/2-1-02.png" alt=""></p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>使用函数 <code>conv</code>即可作为卷积运算</p><h3 id="抽样率转换"><a href="#抽样率转换" class="headerlink" title="抽样率转换"></a>抽样率转换</h3><p><strong>抽样率转换比:</strong>  $\frac{F_T^{‘}}{F_T} = R$, $F_T$ 是原本的抽样率, 再拿$F_T^{‘}$ 去抽样</p><h3 id="序列分类"><a href="#序列分类" class="headerlink" title="序列分类"></a>序列分类</h3><ul><li>周期、非周期</li><li>能量信号、功率信号</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;!-- toc --&gt;

&lt;blockquote&gt;
&lt;p&gt;本文是我学习《数字信号处理 – 基于计算机的方法》第四版的笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://blog.difan.tech/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DSP" scheme="https://blog.difan.tech/tags/DSP/"/>
    
      <category term="Math" scheme="https://blog.difan.tech/tags/Math/"/>
    
      <category term="SignalProcessing" scheme="https://blog.difan.tech/tags/SignalProcessing/"/>
    
  </entry>
  
  <entry>
    <title>TMUX</title>
    <link href="https://blog.difan.tech/2020/10/09/TMUX/"/>
    <id>https://blog.difan.tech/2020/10/09/TMUX/</id>
    <published>2020-10-08T16:00:00.000Z</published>
    <updated>2021-04-13T09:20:38.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><ul><li><code>tmux new -s window_name</code></li><li>ctrl + b + d : detach 当前的window</li><li><code>tmux a -t window_name</code></li><li>ctrl + b + w : 看一下window， panne</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>维护管理终端正在运行的程序</li><li>执行多个任务</li><li>远程使用时尤其方便，断开连接也不会挂掉正在跑的东西<span id="more"></span></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>Sessions 包含多个windows，表示一个工作区</li><li>Windows 相当于浏览器的tabs</li><li>Panes 一个window分割成几个视觉上分开的Panes</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>session<ul><li>tmux 开启新session</li><li>tmux new -s NAME </li><li>tmux ls 列出现存的session</li><li><C-b> d 分离当前的session</li><li>tmux a 继续上一个session </li><li>tmux a -t 0 指定session 0</li></ul></li><li>window<ul><li><C-b> c 创建window</li><li><C-b> + number 去 第几 window</li><li><C-b> p 上一个window</li><li><C-b> n 下一个window</li><li><C-b> w 列出现有的windows</li></ul></li><li>pane<ul><li><C-b> “ （我这里是 | ）水平方向分割</li><li><C-b> % （我这里是 - ）竖直方向分割</li><li><C-b> z 全屏，然后再按一次恢复</li><li><C-b> <C> ← →来改变pane大小</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tmux new -s window_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ctrl + b + d : detach 当前的window&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tmux a -t window_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ctrl + b + w : 看一下window， panne&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;维护管理终端正在运行的程序&lt;/li&gt;
&lt;li&gt;执行多个任务&lt;/li&gt;
&lt;li&gt;远程使用时尤其方便，断开连接也不会挂掉正在跑的东西
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="tmux" scheme="https://blog.difan.tech/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>Vim 随手记</title>
    <link href="https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    <id>https://blog.difan.tech/2020/05/04/Vim%20%E9%9A%8F%E6%89%8B%E8%AE%B0/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-05-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><span id="more"></span><ul><li><p>i : insert 光标字符之前</p></li><li><p>a : append 光标字符之后加入</p></li><li><p>o : open a line below 当前行下面开一行</p></li><li><p>A : 在本行最后append</p></li><li><p>O : 本行上面插入一行，开头插入</p></li><li><p>I : 在本行开头插入</p></li></ul><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><ul><li>normal<ul><li>使用 gi 快速恢复到原始插入位置</li><li>w 下个单词开头，e下个单词结尾</li><li>b 上个单词开头 </li><li>大写跳动到以空白符为间隔的地方</li><li>f+字符，搜索字符, ; 下一个 ,上一个 F+ 字符反过来搜</li><li>0 行首，$ 行尾</li><li>g 移动到开头，G移动到结尾 H/M/L跳转到屏幕的开头，结尾</li><li>ctrl u ctrl d翻页 cltr F/B</li><li>dw 删除一个单词 delete a world x删除字符</li><li>r replalce一个字符 s 删除当前字符进入插入模式 </li><li>R 不断地替换 S 整行删除，进入插入模式</li><li>c(change) aw 删掉一个词进入插入 C 删除整行进入插入模式 ct” 删除整个“”中的内容</li><li>? / 进行反向前向搜索，n/N下一个上一个 # * 当前单词向上搜索/向下搜索</li></ul></li><li>insert<ul><li>ctrl + w 删除word</li><li>ctrl + u 删除行</li><li>ctrl + h 删除上一个字符</li><li>用ctrl + [ 代替esc</li></ul></li><li>command <ul><li>:vs(vertical split) 竖分屏（左右）</li><li>:sp(split) 上下分屏</li><li>set nu 行号</li><li>% s/word1/word2/g 全局替换</li><li>1,6 s/word1/word2/g 1-6行之间替换</li><li>1,6 self//n 统计1-6行几个匹配self n指number，报告匹配到的次数</li><li>% s/&lt;quack&gt;/word2/g</li></ul></li><li>visual<ul><li>normal 模式 v</li><li>V选行</li><li>ctrl v选方块</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="vim" scheme="https://blog.difan.tech/tags/vim/"/>
    
      <category term="Linux" scheme="https://blog.difan.tech/tags/Linux/"/>
    
      <category term="随手记" scheme="https://blog.difan.tech/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何在CentOS 7上使用FirewallD设置防火墙</title>
    <link href="https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://blog.difan.tech/2020/01/10/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS%207%E4%B8%8A%E4%BD%BF%E7%94%A8FirewallD%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2020-01-10T11:40:44.000Z</published>
    <updated>2020-05-04T08:33:06.038Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7">How To Set Up a Firewall Using FirewallD on CentOS 7</a></p><span id="more"></span><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Firewalld是可用于许多Linux发行版的防火墙管理解决方案，它充当Linux内核提供的iptables数据包过滤系统的前端。 在本指南中，我们将介绍如何为服务器设置防火墙，并向您展示使用firewall-cmd管理工具管理防火墙的基本知识（如果您希望在CentOS中使用iptables，请遵循 <a href="https://www.digitalocean.com/community/tutorials/how-to-migrate-from-firewalld-to-iptables-on-centos-7">这个指南</a>。</p><h2 id="Firewalld-的基本概念"><a href="#Firewalld-的基本概念" class="headerlink" title="Firewalld 的基本概念"></a>Firewalld 的基本概念</h2><p>在开始讨论如何实际使用firewall-cmd实用程序来管理防火墙配置之前，我们应该熟悉该工具引入的一些基本概念。</p><h3 id="Zones-区域"><a href="#Zones-区域" class="headerlink" title="Zones(区域)"></a>Zones(区域)</h3><p>Firewalld守护程序使用称为“区域”的实体管理规则组。 区域基本上是一组规则，它们决定了允许哪些流量，具体取决于您对计算机所连接的网络的信任程度。 为网络接口分配一个Zone来指示防火墙应允许和拒绝哪些行为。</p><p>对于可能经常在网络之间移动的计算机（例如笔记本电脑），这种灵活性提供了一种根据环境更改规则的好方法。 在公共WiFi网络上运行时，您可能有严格的规则禁止大多数流量，而在连接到家庭网络时允许放宽限制。 对于服务器来说，这些区域并不是那么重要，因为网络环境很少更改。</p><p>无论您的网络环境动态性有多强，熟悉防火墙的每个预定义区域背后的概念仍然很有用。 按从最不信任到最受信任的顺序，firewalld中的预定义区域为：</p><ul><li><p><strong>drop</strong>：最低级别的信任度。 所有传入的连接都将被丢弃而不会回复，并且只能进行传出连接。</p></li><li><p><strong>block</strong>：与上述类似，但不仅仅是丢弃连接，而是使用icmp-host-prohibited或icmp6-adm-prohibited消息拒绝传入的请求。</p></li><li><p><strong>public</strong>：代表公共的，不受信任的网络。 您不信任其他计算机，但可能会视情况允许选择的传入连接。</p></li><li><p><strong>external</strong>：external network用于这种情形：您将firewalld当成网关使用。 将其配置为伪NAT，以便您的内部网络保持私有但可访问。</p></li><li><p><strong>internal</strong>：外部区域的另一侧，用于网关的内部。 这些计算机相当值得信赖，并且可以使用一些其他服务。</p></li><li><p><strong>dmz</strong>：用于DMZ（无法访问网络其余部分的隔离计算机）。 仅允许某些传入连接。</p></li><li><p><strong>work</strong>：用于工作机。 信任网络中的大多数计算机。 可能还允许其他一些服务。</p></li><li><p><strong>home</strong>：家庭环境。 通常，这意味着您信任其他大多数计算机，并且将接受其他一些服务。</p></li><li><p><strong>trusted</strong>：信任网络中的所有计算机。 可用选项中最开放的，应谨慎使用。</p></li></ul><p>要使用防火墙，我们可以创建规则并更改区域的属性，然后将网络接口（network interface）分配给最合适的区域（zones）。</p><h3 id="规则永久性"><a href="#规则永久性" class="headerlink" title="规则永久性"></a>规则永久性</h3><p>在firewalld中，可以将规则指定为<strong>永久规则</strong>或<strong>立即规则</strong>。 如果添加或修改规则，则默认情况下，将修改当前运行的防火墙规则。 下次启动时，旧规则将恢复。</p><p>大多数<code>firewall-cmd</code>操作都可以使用<code>--permanent</code>标志来指示应永久防火墙规则作为目标。 这将影响在引导时重新加载的规则。 这种分离意味着您可以在活动的防火墙实例中测试规则，然后在出现问题时重新加载。 您还可以使用<code>--permanent</code>标志随着时间的推移建立一套完整的规则，这些规则将在发出<code>reload</code>命令时立即应用。</p><h2 id="安装并启动防火墙"><a href="#安装并启动防火墙" class="headerlink" title="安装并启动防火墙"></a>安装并启动防火墙</h2><p>firewalld默认安装在一些Linux发行版上，包括许多CentOS 7的映像。但是，您可能需要自己安装firewalld:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install firewalld</span><br></pre></td></tr></table></figure><p>安装firewalld之后，可以启用服务并重新启动服务器。请记住，启用firewalld将导致服务在引导时启动。最好的做法是<strong>先创建防火墙规则</strong>，并在配置此行为之前对其进行测试，以避免潜在的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable firewalld </span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>当服务器重新启动时，你的防火墙应该会打开，你的网络接口应该放入已配置的区域(或退回到已配置的默认区域)，与区域相关的任何规则都将应用于相关的接口。</p><p>我们可以通过键入以下内容来验证该服务正在运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --state</span><br></pre></td></tr></table></figure><p>这表明我们的防火墙已经启动并使用默认配置运行。</p><h2 id="熟悉当前的防火墙规则"><a href="#熟悉当前的防火墙规则" class="headerlink" title="熟悉当前的防火墙规则"></a>熟悉当前的防火墙规则</h2><p>在开始进行修改之前，我们应该熟悉守护进程提供的默认环境和规则。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>我们可以通过输入以下内容来查看当前选择的默认区域：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">public</span><br><span class="line">  interfaces: eth0 eth1</span><br></pre></td></tr></table></figure><p> 在这里，我们可以看到示例服务器具有两个受防火墙控制的网络接口（eth0和eth1）。 目前，它们都根据为public zone定义的规则进行管理。</p><p>我们如何知道与public zone相关的规则？ 我们可以通过输入以下内容来打印默认区域的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">public (default, active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0 eth1</span><br><span class="line">  sources: </span><br><span class="line">  services: ssh dhcpv6-client</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure><p>从输出中可以看出，该区域既是默认区域又是活动区域，并且eth0和eth1接口与此区域相关联（我们已经从之前的查询中了解了所有这些信息）。 但是，我们还可以看到，该区域允许与DHCP客户端（用于IP地址分配）和SSH（用于远程管理）相关的正常操作。</p><h3 id="可替代区"><a href="#可替代区" class="headerlink" title="可替代区"></a>可替代区</h3><p>现在，我们对缺省和活动区域的配置有了很好的了解。我们也可以找到其他区域的信息。要获得可用区域的列表，请输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure><p>我们可以通过在<code>—list-all</code>命令中包含<code>—zone=</code>参数来查看与区域关联的特定配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;home --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">home</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dhcpv6-client ipp-client mdns samba-client ssh</span><br><span class="line">  ports: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>您可以使用–list-all-zones选项输出所有区域定义。 您可能希望将输出通过管道以便于查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-all-zones | less</span><br></pre></td></tr></table></figure><h2 id="为接口选择区域"><a href="#为接口选择区域" class="headerlink" title="为接口选择区域"></a>为接口选择区域</h2><p>除非您已经配置了您的网络接口，否则在防火墙启动时，每个接口都将放在默认区域。</p><h3 id="改变接口的区域"><a href="#改变接口的区域" class="headerlink" title="改变接口的区域"></a>改变接口的区域</h3><p>您可以在会话期间使用<code>—zone=</code>参数和<code>—change-interface=</code>参数在区域之间转换接口。与修改防火墙的所有命令一样，您将需要使用sudo。</p><p>例如，我们可以通过输入以下内容将eth0接口转换到home区域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;home --change-interface&#x3D;eth0</span><br></pre></td></tr></table></figure><blockquote><p>每当将接口转换到新区域时，请注意，您可能正在修改将可操作的服务。例如，在这里，我们将移动到”home”区域，其中有 SSH 可用。这意味着我们的连接不应该断开。默认情况下，某些其他区域未启用 SSH，如果在使用这些区域之一时断开连接，您可能会发现自己无法重新登录。</p></blockquote><p>我们可以通过再次请求活动区域来验证这是否成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">home</span><br><span class="line">  interfaces: eth0</span><br><span class="line">public</span><br><span class="line">  interfaces: eth1</span><br></pre></td></tr></table></figure><h3 id="调整默认区域"><a href="#调整默认区域" class="headerlink" title="调整默认区域"></a>调整默认区域</h3><p>如果所有接口都可以最好地由单个区域处理，那么只需选择最佳默认区域，然后将其用于配置可能更容易。</p><p>您可以使用 参数更改默认区域。这将立即将默认的接口更改回新区域：<code>--set-default-zone=</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --set-default-zone&#x3D;home</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="为应用程序设置规则"><a href="#为应用程序设置规则" class="headerlink" title="为应用程序设置规则"></a>为应用程序设置规则</h2><p>为您希望提供的服务定义防火墙的基本方法非常简单。我们将在这里了解基本思想。</p><h3 id="向区域添加服务"><a href="#向区域添加服务" class="headerlink" title="向区域添加服务"></a>向区域添加服务</h3><p>最简单的方法是将所需的服务或端口添加到正在使用的区域。同样，您可以使用以下选项获取可用服务的列表：<code>--get-services</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>您可以使用命令行参数为区域启用服务。该操作将针对默认区域或参数指定的任何区域。默认情况下，这将仅调整当前防火墙会话。您可以通过包含<code>permanent</code>标志来调整永久防火墙配置。<code>--add-service=--zone=--permanent</code></p><p>例如，如果我们正在运行一个为传统HTTP流量提供服务的web服务器，我们可以通过输入以下命令来允许该会话的公共区域中的接口的流量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;http</span><br></pre></td></tr></table></figure><p>我们可以用这个验证操作是否成功：<code>--zone=--list-all--list-services</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">dhcpv6-client http ssh</span><br></pre></td></tr></table></figure><p>测试完所有功能后，可能需要修改永久防火墙规则，以便在重新启动后服务仍然可用。通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;http</span><br></pre></td></tr></table></figure><p>现在，您的“公共”区域将允许端口80上的HTTP Web通信。如果您的Web服务器配置为使用SSL / TLS，则还需要添加服务。 我们可以通过以下内容将其添加到当前session和永久规则集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-service&#x3D;https</span><br></pre></td></tr></table></figure><h3 id="如果没有合适的服务可用呢"><a href="#如果没有合适的服务可用呢" class="headerlink" title="如果没有合适的服务可用呢?"></a>如果没有合适的服务可用呢?</h3><p>firewalld安装中包含的防火墙服务代表了您可能希望允许访问的应用程序的许多最常见需求。但是，可能会出现这些服务不适合您的需求的情况。</p><p>在这种情况下，你有两种选择：</p><h4 id="为你的区域开一个端口"><a href="#为你的区域开一个端口" class="headerlink" title="为你的区域开一个端口"></a>为你的区域开一个端口</h4><p>支持你特定服务最简单的方法就是在合适的区域(zone)内开放一个端口， 这很容易指定端口或端口范围，以及需要打开的端口相关的协议。</p><p>比如，如果你的应用在5000端口中使用TCP，<br>你可以在public区域内使用这个参数进行增加，协议可以为tcp，udp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;5000&#x2F;tcp</span><br></pre></td></tr></table></figure><p>我们可以通过<code>--list-ports</code>进行确认</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --list-ports</span><br></pre></td></tr></table></figure><p>使用横杠进行连续端口的指定也是可能的，例如，下面的例子就开放了4990到4999的UDP端口，当然同样是在Public zone中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public ---add-port&#x3D;4990-4999&#x2F;udp</span><br></pre></td></tr></table></figure><p>在测试后，我们想把它们增加为永久的防火墙规则，你可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;5000&#x2F;tcp</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --add-port&#x3D;4990-4999&#x2F;udp</span><br><span class="line">sudo firewall-cmd --zone&#x3D;public --permanent --list-ports</span><br></pre></td></tr></table></figure><h4 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h4><p>为您的区域打开端口很容易，但是很难跟踪每个端口的用途。如果您曾经在您的服务器上停止过一个服务，那么您可能很难记住哪些过去被打开了的端口仍然是必需的。为了避免这种情况，可以定义一个服务。</p><p>服务只是具有相关名称和描述的端口的集合。使用服务比端口更容易管理，但是需要一些前期工作。最简单的启动方式是将现有的脚本复制到防火墙查找非标准定义的目录中。<code>/usr/lib/firewalld/services/etc/firewalld/services</code></p><p>例如，我们可以复制SSH服务定义来使用我们的’example’服务定义，如下所示。文件名减去后缀将指示防火墙服务列表中的服务名称:<code>.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;services&#x2F;ssh.xml &#x2F;etc&#x2F;firewalld&#x2F;services&#x2F;example.xml</span><br></pre></td></tr></table></figure><p>首先，该文件将包含您复制的SSH定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>SSH<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该定义的大部分实际上是元数据。 您将要在标签内更改服务的简称。 这是您的服务的易读名称。 您还应该添加描述，以便在需要审核服务时获得更多信息。 您需要进行的实际上会影响服务功能的唯一配置可能是端口定义，您可以在其中定义要打开的端口号和协议。 可以多次指定。</p><p>对于我们的示例服务，假设我们需要为TCP打开7777端口，为UDP打开8888端口。通过按下按钮进入插入模式，我们可以这样修改现有的定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short</span>&gt;</span>Example Service<span class="tag">&lt;/<span class="name">short</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is just an example service.  It probably shouldn&#x27;t be used on a real system.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;tcp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;7777&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">port</span> <span class="attr">protocol</span>=<span class="string">&quot;udp&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新加载防火墙以访问新服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry dropbox-lansync elasticsearch example freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master high-availability http https imap imaps ipp ipp-client ipsec iscsi-target kadmin kerberos kibana klogin kpasswd kshell ldap ldaps libvirt libvirt-tls managesieve mdns mosh mountd ms-wbt mssql mysql nfs nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server</span><br></pre></td></tr></table></figure><p>我们可以看到example服务已经被成功定义。</p><h2 id="创造属于你自己的区域（zones）"><a href="#创造属于你自己的区域（zones）" class="headerlink" title="创造属于你自己的区域（zones）"></a>创造属于你自己的区域（zones）</h2><p>尽管预定义的区域对于大多数用户来说可能绰绰有余，但是定义自己的区域来描述其功能可能会有所帮助。</p><p>例如，您可能要为Web服务器创建一个名为“ publicweb”的zone。 但是，您可能希望为您在专用网络上提供的DNS服务而去配置另一个zone。 您可能需要一个名为“ privateDNS”的zone。</p><p>添加区域时，必须将其添加到永久防火墙配置中。 然后，您可以重新加载以将配置带入正在运行的会话。 例如，我们可以通过键入以下内容来创建我们上面讨论的两个区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --new-zone&#x3D;publicweb</span><br><span class="line">sudo firewall-cmd --permanent --new-zone&#x3D;privateDNS</span><br></pre></td></tr></table></figure><p>您可以通过键入来验证它们是否存在于您的永久配置中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --get-zones</span><br></pre></td></tr></table></figure><p>如前所述，这些在防火墙的当前实例中还不可用,重新加载防火墙，将这些新区域引入活动配置2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br><span class="line">firewall-cmd --get-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block dmz drop external home internal privateDNS public publicweb trusted work</span><br></pre></td></tr></table></figure><p>现在，您可以开始为您的区域分配适当的服务和端口。先调整active instance，然后在测试之后将这些更改转移到永久配置，这通常是一个好主意。例如，对于publicweb专区，您可能希望添加SSH、HTTP和HTTPS服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;ssh</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;http</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">publicweb</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: ssh http https</span><br><span class="line">  ports: </span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>同样，我们可以将DNS服务添加到我们的privateDNS zone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --add-service&#x3D;dns</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --list-all</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">privateDNS</span><br><span class="line">  interfaces: </span><br><span class="line">  sources: </span><br><span class="line">  services: dns</span><br><span class="line">  ports: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>然后，我们可以更改对应zone的网络接口以对其进行测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --change-interface&#x3D;eth0</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --change-interface&#x3D;eth1</span><br></pre></td></tr></table></figure><p>此时，您就有机会测试您的配置了。如果这些值对您有效，您将希望向永久配置添加相同的规则。您可以通过重新应用带有标志的规则来做到这一点:<code>--permanent</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;ssh</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;http</span><br><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --permanent --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --permanent --add-service&#x3D;dns</span><br></pre></td></tr></table></figure><p>在永久地应用这些规则之后，您可以重新启动网络并重新加载防火墙服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart network</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure><p>确认已经成功分配了zones：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --get-active-zones</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">privateDNS</span><br><span class="line">  interfaces: eth1</span><br><span class="line">publicweb</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure><p>确认合适的服务已经在每个zones里面可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;publicweb --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output</span><br><span class="line">http https ssh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone&#x3D;privateDNS --list-services</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns</span><br></pre></td></tr></table></figure><p>现在您已经成功地建立了属于您的区域！如果您想要把其中一个区域设置为其他网络接口的默认区域，记得使用参数<code>--set-defalut-zone=</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --set-default-zone&#x3D;publicweb</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>您现在应该对如何在CentOS系统上日常使用的防火墙服务进行充分的了解。</p><p>Firewalld服务允许您配置依据网络环境的可维护规则和规则集。 它使您可以通过使用区域在不同的防火墙策略之间无缝过渡，并使管理员能够将端口管理抽象为更友好的服务定义。 掌握该系统的使用知识将使您能够利用此工具提供的灵活性和强大功能。</p><p>By Justin Ellingwood</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-7&quot;&gt;How To Set Up a Firewall Using FirewallD on CentOS 7&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.difan.tech/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://blog.difan.tech/tags/CentOS/"/>
    
      <category term="FirewallD" scheme="https://blog.difan.tech/tags/FirewallD/"/>
    
  </entry>
  
  <entry>
    <title>微软新 Edge 浏览器--带给你Chrome一致的体验 安装教程和上手体验</title>
    <link href="https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/"/>
    <id>https://blog.difan.tech/2019/12/16/%E5%BE%AE%E8%BD%AF%E6%96%B0%20Edge%20%E6%B5%8F%E8%A7%88%E5%99%A8--%E5%B8%A6%E7%BB%99%E4%BD%A0Chrome%E4%B8%80%E8%87%B4%E7%9A%84%E4%BD%93%E9%AA%8C%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%92%8C%E4%B8%8A%E6%89%8B%E4%BD%93%E9%AA%8C/</id>
    <published>2019-12-16T02:52:37.000Z</published>
    <updated>2020-05-04T08:32:54.737Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge<br><strong>采用了 Chromium 内核</strong>，当然也兼容以前 IE 的功能。</p></blockquote><span id="more"></span><p>由于最新的Edge采用Chromium内核，对于平时使用Chrome作为使用工具的人来说不会有太大学习成本，基本无缝迁移。最新版本在功耗，性能，UI上都取得了比较不错的表现。</p><p>最新的Edge版采用了Chromium的内核，当然现在没有正式版，可以用<a href="https://www.microsoftedgeinsider.com/zh-cn/">Beta版</a> 来体验。</p><p><img src="https://img-blog.csdnimg.cn/20191215235301329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击Beta版进行下载</p><p><img src="https://img-blog.csdnimg.cn/20191215235921432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191215235957717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看到进去后提示导入chrome收藏，一键导入很方便，UI风格很漂亮，下面看一下开发者工具：</p><p><img src="https://img-blog.csdnimg.cn/20191216000333905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191216001742765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>和之前Chrome的类似，不会有学习成本。新Edge浏览器因为只是测试版，因此插件很少，不过我们可以将<strong>Chrome的插件直接打包过来或者直接访问<a href="https://chrome.google.com/webstore/">Chrome商店</a>进行下载</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20191216002513982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>亲测可直接添加Chrome插件，使用体验没有任何区别，在正常工作环境下（插件数量相同，打开6个TAB），新Edge占用内存较低：</p><p><img src="https://img-blog.csdnimg.cn/20191216004233444.png" alt="在这里插入图片描述"><br>目前来看，优势主要有：</p><ul><li><p>账户可以直接用微软账户，同步不需要翻墙</p></li><li><p>和Chrome一致的的性能，更好的UI</p></li><li><p>平滑滚动好</p><p>要注意的是，现在的Edge Beta版和自带的Edge不是覆盖的，所以可以放心试用。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191216005133562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpZ2Vycm9hcm0=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Edge是微软新一代浏览器。 微软新的 IE 浏览器项目 Project Spartan 在 Build 2015 上正式更名为 Microsoft Edge。最新的 Edge&lt;br&gt;&lt;strong&gt;采用了 Chromium 内核&lt;/strong&gt;，当然也兼容以前 IE 的功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="MicroSoft" scheme="https://blog.difan.tech/tags/MicroSoft/"/>
    
  </entry>
  
  <entry>
    <title>Git 实战</title>
    <link href="https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/"/>
    <id>https://blog.difan.tech/2019/07/09/git%20%E5%AE%9E%E6%88%98/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2021-01-16T09:50:17.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><ul><li>集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作</li><li>分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧</li></ul><span id="more"></span><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;×××&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;×××@gmail.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>会在~ 目录生成一个.gitconfig</p><p>如果你想不是global，则不带–global即可，会在本项目目录下创建.git/config</p><p><code>git init</code> 初始化一个git project</p><p><code>git diff --cached</code> 查看缓存区里有哪些文件被修改了。<code>git diff</code>会显示所有已做但是没有加到缓存区的修改</p><p>add 和commit操作不赘述，commit操作后<code>-a</code>将所有没有加到缓存区的修改也一起提交，不过<strong>不会提交新文件</strong></p><p><code>git remote add origin https://github.com/myname/myproject.git</code></p><p><code>git push origin master</code></p><h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><p>分支在多人协作开发用的多，比如你负责的一个功能需要一个月完成，就可以创建一个分支，只把功能代码提交到这个分支上，最后合并到master分支上</p><p><code>git branch experimental</code> 创建分支</p><p><code>git branch</code> 查看分支</p><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* experimental </span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git checkout experimental</code> 切换到其他分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将experimental分支合并到master</span><br><span class="line">$ git merge -m &#39;merge experimental branch&#39; experimental</span><br></pre></td></tr></table></figure><p>如果有冲突，比如两个分支都修改了同一个文件，就会merge失败，这是在master分支修改对应文件再commit即可。</p><p>当我们完成分支，可以用<code>git branch -d experimental</code> 来删除（只能删除已经合并了的分支，强行删除用<code>-D</code>）</p><p>如果你觉得<strong>合并错了</strong>，可以回到合并前的状态</p><p><code>git reset --hard HEAD^</code></p><h2 id="Git-日志"><a href="#Git-日志" class="headerlink" title="Git 日志"></a>Git 日志</h2><p><code>git log</code></p><p><code>git log --stat</code> 会显示哪些文件被修改</p><p><code>git log --pretty=oneline</code> 会一行显示一条信息</p><p><code>git log --pretty=short</code> 显示简短信息</p><p><code>git log --graph -pretty=oneline</code> 画一个漂亮的历史</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>git diff不仅仅能查看两个文件的差别，也可以看两个branch的区别。 </p><p><code>git diff anotherbranch</code>  + 表示本分支比anotherbranch分支多的，- 表示本分支少的</p><h2 id="分布式工作流程"><a href="#分布式工作流程" class="headerlink" title="分布式工作流程"></a>分布式工作流程</h2><p>如果要经常操作远程分支，可以定义缩写</p><p><code>git remote add myrepo /tmp/myrepo</code></p><p>git pull 相当于两个操作：使用git fetch抓取最新的修改信息，然后git merge</p><p><strong>为什么不需要指定远程仓库？</strong></p><p>因为Git把远程地址存到了配置文件的remote.origin.url</p><p>git 也可以是服务器的地址：</p><p><code>git clone ssh://服务器/账号/仓库名称</code></p><p><code>git push ssh://服务器仓库地址 master:master</code></p><h2 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h2><h3 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h3><p><code>git tag tagname 8c2940</code></p><p><code>git tag</code></p><h3 id="标签对象"><a href="#标签对象" class="headerlink" title="标签对象"></a>标签对象</h3><p><code>git tag -a stable-2 8c315325 -m &quot;stable 2&quot;</code></p><h3 id="签名标签"><a href="#签名标签" class="headerlink" title="签名标签"></a>签名标签</h3><p>签名标签可以让提交和标签更加完整可信</p><h2 id="git-ignore"><a href="#git-ignore" class="headerlink" title="git ignore"></a>git ignore</h2><p>.gitignore 来忽略不需要提交的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.html</span><br><span class="line">!foo.html #foo.html例外</span><br><span class="line">*.[oa] #忽略所有.o .a </span><br></pre></td></tr></table></figure><h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p><code>git reset --hard HEAD^</code> 回到上次提交的状态</p><p><code>git checkout -- hello.rb</code> 恢复一个文件</p><p><code>git revert HEAD</code> 撤销最近的一次提交</p><h2 id="建设私有仓库"><a href="#建设私有仓库" class="headerlink" title="建设私有仓库"></a>建设私有仓库</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>可以导出一个裸仓库，然后用scp命令拷贝到服务器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;home&#x2F;user&#x2F;myrepo&#x2F;.git &#x2F;tmp&#x2F;myrepo.git</span><br><span class="line">scp -r &#x2F;tmp&#x2F;myrepo.git myserver.com:&#x2F;opt&#x2F;git&#x2F;myrepo.git</span><br></pre></td></tr></table></figure><p>对于其他人来说，直接</p><p><code>git clone myserver:com:/opt/git/myrepo.git</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制系统&quot;&gt;&lt;a href=&quot;#版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;版本控制系统&quot;&gt;&lt;/a&gt;版本控制系统&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式 ： 版本库存放在中央服务器，先从中央服务器取得最新的版本，然后开始工作&lt;/li&gt;
&lt;li&gt;分布式 ： 每个人电脑都是一个完整的版本库，安全性高，一台坏掉了也不要紧&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://blog.difan.tech/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://blog.difan.tech/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 16.04 home挂载 系统重装</title>
    <link href="https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"/>
    <id>https://blog.difan.tech/2019/06/09/ubuntu%2016.04%20home%E6%8C%82%E8%BD%BD%20%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/</id>
    <published>2019-06-09T05:39:30.000Z</published>
    <updated>2021-03-29T06:12:00.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-系统重装并挂载"><a href="#Ubuntu-系统重装并挂载" class="headerlink" title="Ubuntu 系统重装并挂载"></a>Ubuntu 系统重装并挂载</h1><p>昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..</p><span id="more"></span><h2 id="linux分区"><a href="#linux分区" class="headerlink" title="linux分区"></a>linux分区</h2><blockquote><p>SWAP分区是LINUX暂时存储数据的交换分区，它主要是把主内存上暂时不用得数据存起来，在需要的时候再调进内存内，且作为SWAP使用的分区不用指定“Mout Point”（载入点），既然它作为交换分区，我们理所当然应给它指定大小，它至少要等于系统上实际内存的量，<strong>一般来说它的大小是内存的一至两倍</strong>。另外你也可以创建和使用一个以上的交换分区，最多16个。</p></blockquote><h3 id="分区的原因"><a href="#分区的原因" class="headerlink" title="分区的原因"></a>分区的原因</h3><p>为什么要自定义多个分区</p><ul><li>在不损失数据的情况下重装系统，比如独立设置/home挂载点,重装系统的时候直接标记回/home，数据不会有任何损失。</li><li>针对不同挂载点的特性分配合适的文件系统以合理发挥性能，比如对/var使用reiserfs，对/home使用xfs，对/使用ext4。</li><li>针对不同的挂载点开启不同的挂载选项，如是否需要即时同步，是否开启日志，是否启用压缩。</li><li>大硬盘搜索范围大，效率低</li><li>磁盘配额只能对分区做设定</li><li>/home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MjQxMDM4LTIzMzllNDk4YzkyZGU1MjIuanBn?x-oss-process=image/format,png" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></li></ul><p>（常见的挂载目录结构）</p><blockquote><p>/ 根目录，存放系统命令和用户数据等（如果下面挂载点没有单独的分区，它们都将在根目录的分区中） /boot boot loader 的静态链接文件，存放与Linux启动相关的程序 /home 用户目录，存放普通用户的数据 /tmp 临时文件 /usr 是Linux系统存放软件的地方,如有可能应将最大空间分给它 /usr/local 自已安装程序安装在此 /var 不断变化的数据，服务器的一些服务、日志放在下面 /opt （Option可选的）附加的应用程序软件包 /bin 基本命令执行文 /dev 设备文件 /etc 主机特定的系统配置 /lib 基本共享库以及内核模块 /media 用于移动介质的挂载点 /mnt 用于临时挂载文件系统或者别的硬件设备（如光驱、软驱） /proc 系统信息的虚拟目录(2.4 和 2.6 内核)，这些信息是在内存中，由系统自己产生的 /root root 用户的目录 /sbin 基本系统命令执行文件 /sys 系统信息的虚拟目录(2.6 内核) /srv 系统提供的用于 service 的数据 /usr/X1186 X-Windows目录，存放一些X-Windows的配置文件 /usr/include 系统头文件，存储一些C语言的头文件 /usr/src Linux内核源代码，Linux系统所安装的内核源代码都保存在此 /usr/bin 对/bin目录的一些补充 /usr/sbin 对/sbin目录的一些补充 /lost+found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下</p></blockquote><h3 id="为什么会有挂载"><a href="#为什么会有挂载" class="headerlink" title="为什么会有挂载"></a>为什么会有挂载</h3><p>因为<strong>linux 下一切皆文件</strong>！换句说法就是linux操作系统将系统中的一切都作为文件来管理。在windows中我们常见的硬件设备（打印机、网卡、声卡…）、磁盘分区等，在linux中统统都被视作文件，对设备、分区的访问就是读写对应的文件。</p><h2 id="linux挂载"><a href="#linux挂载" class="headerlink" title="linux挂载"></a>linux挂载</h2><h3 id="临时挂载"><a href="#临时挂载" class="headerlink" title="临时挂载"></a>临时挂载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mount &#x2F;dev&#x2F;sda11 &#x2F;data   ##sda3分区挂载在data目录下</span><br><span class="line">$ umount &#x2F;data   ##卸载data目录下分区 &#x2F;dev&#x2F;sda11 &#x2F;data   ##sda3分区挂载在data目录下</span><br><span class="line">$ umount &#x2F;data   ##卸载data目录下分区</span><br></pre></td></tr></table></figure><h3 id="永久挂载：开机自动挂载"><a href="#永久挂载：开机自动挂载" class="headerlink" title="永久挂载：开机自动挂载"></a>永久挂载：开机自动挂载</h3><p><strong>需要修改/etc/fstab</strong></p><p><strong><img src="https://img-blog.csdn.net/20180609133109749" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></strong></p><p><strong><img src="https://img-blog.csdn.net/20180609133131519" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">​</strong></p><p><strong>Device</strong></p><p>By default, Ubuntu now uses <a href="http://en.wikipedia.org/wiki/UUID">UUID</a> to identify partitions.</p><p>默认，Ubuntu用uuid识别分区</p><p>To list your devices by UUID use blkid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>使用命令 <code>fdisk -l</code> 可以列出系统中当前连接的硬盘,设备和分区信息.新硬盘没有分区信息,则只显示硬盘大小信息.</p><p><img src="https://img-blog.csdn.net/20180609133150762" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以先mkdir一个目录，比如new_dir，然后挂载分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda11 &#x2F;mnt&#x2F;new_dir</span><br></pre></td></tr></table></figure><p>将所有东西全部cp到new_dir中</p><p>move原有的home </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;</span><br><span class="line">mv &#x2F;home &#x2F;old_home &#x2F;home&#x2F;* &#x2F;mnt&#x2F;new_dir&#x2F;</span><br><span class="line">mv &#x2F;home &#x2F;old_home</span><br></pre></td></tr></table></figure><p>再<code>mkdir</code>一个新的home,将sda11再mount到home上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda11 &#x2F;home</span><br></pre></td></tr></table></figure><p><code>df -h</code>查看硬盘大小和挂载情况</p><p><img src="https://img-blog.csdn.net/20180609133221926" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>最后根据要求，修改/etc/fstab 文件，注意格式要和其他保持一致，查看UUID可以用前文中说的方法。最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a-a</span><br></pre></td></tr></table></figure><p>这样就设置了fstab中的参数，<strong>设置完之后一定要看看生不生效，再继续操作</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu-系统重装并挂载&quot;&gt;&lt;a href=&quot;#Ubuntu-系统重装并挂载&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 系统重装并挂载&quot;&gt;&lt;/a&gt;Ubuntu 系统重装并挂载&lt;/h1&gt;&lt;p&gt;昨天一不小心改变了系统/usr的权限，导致grub引导的Ubuntu系统进不去，查找方法失效后，我使用u盘引导的方式重装ubuntu系统，并恢复原有/home 路径下挂载的近74GB文件。挂载的好处就是这种如果系统崩了，还能保存/home下的文件不丢…..&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.difan.tech/categories/Linux/"/>
    
    
      <category term="ubuntu" scheme="https://blog.difan.tech/tags/ubuntu/"/>
    
      <category term="挂载" scheme="https://blog.difan.tech/tags/%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
</feed>
